# Benchmark CVEs

TODO @esbena Increase the level of detail and formality here? 

The [CVEs](../CVEs) directory contains benchmark CVE entries,
encoded as a JSON file per CVE. A benchmark CVE entry consists of a
CVE identifier, and some additional information that isn't normally
available in an ordinary CVE.

For a CVE to be eligible as a benchmark CVE, the CVE must be
publicly accessible and it must be for open-source software.

The basic content of a benchmark CVE is described by the following
(informal) TypeScript type:

```typescript
{
  CVE: CVEString;
  state: CVEState;
  repository: URLString;
  prePatch: {
    commit: CommitID;
    weaknesses: {
      location: SourceLocation;
      explanation: string;
    }[];
  };
  postPatch: {
    commit: CommitID;
    weaknesses?: {
      location: SourceLocation;
      explanation: string;
    }[];
  };
}
```

The formal benchmark CVE format is defined by this
[JSON-schema](../schemas/BCVE.schema.json), which is explained in this 
[markdown file](docs/jsonschema/README.md) as `BCVE`.

With an an example instantiation being:

```json
{
    "CVE": "CVE-2020-8203",
    "state": "ACCEPT",
    "repository": "https://github.com/lodash/lodash.git",
    "prePatch": {
        "commit": "e7b28ea6cb17b4ca021e7c9d66218c8c89782f32",
        "weaknesses": [
            {
                "location": {
                    "file": "lodash.js",
                    "line": 2559
                },
                "explanation": "Prototype pollution in utility function"
            }
        ]
    },
    "postPatch": {
        "commit": "c84fe82760fb2d3e03a63379b297a1cc1a2fce12"
    }
}
```

Additionally. A benchmark CVE is considered "complete" if all of the following hold:

- `state` is `ACCEPTED`, meaning that no further work on the CVE is expected, and that the vulnerability has been acknowledged
- `prePatch` exists and contains at least one relevant weakness, meaning that the vulnerability was caused by a source code mistake
- `postPatch` exists and contains zero relevant weaknesses, meaning that the vulnerability has been fixed properly

With this definition, the ideal analysis tool produces at least one
relevant alert on the `prePatch` commit, and all such alerts are gone
in the `postPatch` commit for a complete benchmark CVE. This means
that the ideal analysis tool would have classified the `prePatch`
commit as vulnerable, and that it recognises the `postPatch`
commit as a sufficient fix.

Incomplete benchmark CVEs are not as valuable as complete benchmark
CVEs for benchmarking due to their inherent ambiguities: "Do the
maintainers agree that this is an unintended behaviour?", "Could an
analysis even have produced an alert?", "Should the analysis produce
fewer alerts on the `postPatch` commit?". As a consequence, incomplete
benchmark CVEs are ignored by default in the tooling of this project.


## Theory: commits related to a CVE

Generally speaking, there are five different kinds of commits that are
relevant for a CVE. This classification also suits the situation where
multiple parallel versions of an application are vulnerable to the
same CVE.

- `preIntroduction`: the commit just before the vulnerability was introduced
- `postIntroduction`: the commit that introduces the vulnerability
- `patchBase`: the commit that a complete patch is applied to
- `prePatch`: the commit just before the vulnerability is fixed
- `postPatch`: the commit that fixes the vulnerability

That is: the `preIntroduction` and `postPatch` commits are not
expected to be affected by the vulnerability described in the CVE,
while `postIntroduction`, `patchBase`, and `prePatch` are.

## Practice: commits related to a CVE

In practice, it may be hard to find the exact `preIntroduction` and
`postIntroduction` commits. 

Ideally, security fixes are small, surgical commits, resulting in
`patchBase` being equal to `prePatch`. Practically speaking, a
security fix may involve several commits that together enables
`postPatch` to address the vulnerability completely. That is, there
may be several commit between `patchBase` and `prePatch` that each
partially address the vulnerability.

Finally, it may be the case that it is later discovered that
`preIntroduction` or `postPatch` actually are vulnerable to the CVE as
well for reasons that were unknown at the time the CVE was published.

In the name of simplicity, this project currently only concerns itself
with a single `prePatch` and `postPatch` commit for each CVE.
