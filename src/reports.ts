import * as csv from "csv-string";
import * as fs from "fs";
import * as I from "immutable";
import * as mdescape from "markdown-escape";
import mdtable from "markdown-table";
import * as path from "path";
import * as txttable from "table";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  BCVERun,
  CVEString,
  Dir,
  Format,
  RuleID,
  SourceLocation,
  ToolID
} from "./types";
enum AlertClassification {
  MATCHES_WEAKNESS,
  UNKNOWN
}
function getClassification(_alert: BCVEAlert) {
  return AlertClassification.UNKNOWN; // XXX make this smarter
}
enum CVECommitKind {
  patchBase = "patchBase",
  postPatch = "postPatch"
}

interface SimpleTable {
  title: string;
  headers: string[];
  rows: string[][];
}

let tableConfigs: { [kind: string]: txttable.TableUserConfig } = {
  stdTable: {
    drawHorizontalLine: (l, s) => l <= 1 || l === s
  }
};

function writeTable(
  fileNamePrefix: string,
  table: SimpleTable,
  outDir: Dir,
  format: Format
) {
  fs.mkdirSync(outDir, { recursive: true });

  let out = path.join(outDir, `${fileNamePrefix}-table.${format}`);
  console.log(`Writing table to: ${out}`);

  let tableString: string;
  switch (format) {
    case "txt":
      tableString = txttable.table(
        [table.headers].concat(table.rows),
        tableConfigs.stdTable
      );
      tableString = `${table.title}\n${tableString}`;
      break;
    case "md":
      tableString = mdtable([table.headers].concat(table.rows));
      tableString = `## ${table.title}\n${tableString}`;
      break;
    case "csv":
      tableString = csv.stringify([table.headers].concat(table.rows));
      break;
    case "html":
    default:
      throw new Error(`Unsupported table format: ${format}`);
  }
  fs.writeFileSync(out, tableString + "\n", {
    encoding: "utf8"
  });
}

function makeResultsReports(bcves: BCVE[], outDir: Dir, format: Format) {
  let bcvesByCVE = I.Set(bcves).groupBy(bcve => bcve.CVE),
    cves = bcvesByCVE
      .keySeq()
      .sort()
      .toArray(),
    toolIDs = I.Set(bcves)
      .flatMap(bcve => [bcve.postPatch.runs, bcve.patchBase.runs])
      .flatMap(runs => runs)
      .map(run => run.toolID)
      .sort()
      .toArray();

  let cve2kind2tool2rule2classification2count: I.Map<
    CVEString,
    I.Map<
      CVECommitKind,
      I.Map<ToolID, I.Map<RuleID, I.Map<AlertClassification, number>>>
    >
  > = I.Set(bcves)
    .groupBy(bcve => bcve.CVE)
    .toMap()
    .map(bcves => {
      let map = I.Map([
        [CVECommitKind.postPatch, bcves.flatMap(bcve => bcve.postPatch.runs)],
        [CVECommitKind.patchBase, bcves.flatMap(bcve => bcve.patchBase.runs)]
      ]);
      return map.map(runs =>
        runs
          .groupBy(run => run.toolID)
          .toMap()
          .map(runs =>
            runs
              .flatMap(run => run.alerts)
              .groupBy(a => a.ruleID)
              .toMap()
              .map(alerts =>
                alerts
                  .groupBy(getClassification)
                  .toMap()
                  .map(alerts => alerts.count())
              )
          )
      );
    });
  function getPatchBaseTpRules(cve: CVEString, toolID: ToolID): I.Set<RuleID> {
    return cve2kind2tool2rule2classification2count
      .get(
        cve,
        I.Map<
          CVECommitKind,
          I.Map<ToolID, I.Map<RuleID, I.Map<AlertClassification, number>>>
        >()
      )
      .get(
        CVECommitKind.patchBase,
        I.Map<ToolID, I.Map<RuleID, I.Map<AlertClassification, number>>>()
      )
      .get(toolID, I.Map<RuleID, I.Map<AlertClassification, number>>())
      .map((a, rule) =>
        a.get(AlertClassification.MATCHES_WEAKNESS, 0) > 0 ? rule : undefined
      )
      .filter(x => x !== undefined)
      .toSet();
  }

  writeTable(
    `Negative-delta-alert-counts-rules`,
    buildResultsReportTable(
      `Rules with negative delta counts for patchBase -> postPatch`,
      bcves,
      bcve => (bcve.postPatch.runs || []).concat(bcve.patchBase.runs),
      (runs, cve, toolID) => {
        let patchBase = cve2kind2tool2rule2classification2count
            .get(cve)
            .get(CVECommitKind.patchBase),
          postPatch = cve2kind2tool2rule2classification2count
            .get(cve)
            .get(CVECommitKind.postPatch);
        if (
          !patchBase.has(toolID) ||
          !postPatch.has(toolID) ||
          runs.some(r => r.status !== BCVEResultStatus.SUCCESS)
        ) {
          return;
        }
        let patchBaseCounts: I.Map<RuleID, number> = patchBase
            .get(toolID)
            .map(x => x.valueSeq().reduce((a, b) => a + b, 0)),
          postPatchCounts: I.Map<RuleID, number> = postPatch
            .get(toolID)
            .map(x => x.valueSeq().reduce((a, b) => a + b, 0)),
          diffCounts = patchBaseCounts.map(
            (patchBaseCount, r) => postPatchCounts.get(r, 0) - patchBaseCount
          );

        return diffCounts
          .entrySeq()
          .filter(([_, delta]) => delta < 0)
          .map(
            ([rule, delta]) =>
              `${rule}: ${delta} (${postPatchCounts.get(rule, 0)})`
          )
          .sort()
          .join(", ");
      },
      cves,
      toolIDs
    ),
    outDir,
    format
  );

  writeTable(
    `Delta-alert-counts-for-TP-queries`,
    buildResultsReportTable(
      `Delta and remaining alert counts on postPatch for patchBase TP queries`,
      bcves,
      bcve => (bcve.postPatch.runs || []).concat(bcve.patchBase.runs),
      (_runs, cve, toolID) => {
        let tpRules = getPatchBaseTpRules(cve, toolID);
        if (tpRules.isEmpty()) {
          return undefined;
        }
        let sums = tpRules
          .map(rule => {
            let patchBaseAlertsForTPRule: number = cve2kind2tool2rule2classification2count
              .get(cve)
              .get(CVECommitKind.patchBase)
              .get(toolID)
              .get(rule)
              .reduce((a, b) => a + b, 0);
            let postPatchAlertsForTPRule: number = cve2kind2tool2rule2classification2count
              .get(cve)
              .get(CVECommitKind.postPatch)
              .get(toolID)
              .get(rule, I.Map<AlertClassification, number>())
              .reduce((a, b) => a + b, 0);
            return {
              delta: postPatchAlertsForTPRule - patchBaseAlertsForTPRule,
              remaining: postPatchAlertsForTPRule
            };
          })
          .reduce(
            (a, b) => ({
              delta: a.delta + b.delta,
              remaining: a.remaining + b.remaining
            }),
            { delta: 0, remaining: 0 }
          );
        return `${sums.delta} (${sums.remaining})`;
      },
      cves,
      toolIDs
    ),
    outDir,
    format
  );
  function mkRunSelectorByKind(kind: CVECommitKind) {
    return function runSelectorByKind(bcve: BCVE): BCVERun[] {
      return kind === CVECommitKind.postPatch
        ? bcve.postPatch.runs || []
        : bcve.patchBase.runs || [];
    };
  }

  for (const kind of Object.keys(CVECommitKind) as CVECommitKind[]) {
    let runSelectorByKind = mkRunSelectorByKind(kind);
    writeTable(
      `${kind}-status`,
      buildResultsReportTable(
        `${kind} status`,
        bcves,
        runSelectorByKind,
        runs => {
          return I.Set(runs)
            .map(run => run.status)
            .sort()
            .join(", ");
        },
        cves,
        toolIDs
      ),
      outDir,
      format
    );

    for (let classification of Object.values(AlertClassification)) {
      writeTable(
        `${kind}-${classification}-rules`,
        buildResultsReportTable(
          `${kind} ${classification} rules`,
          bcves,
          runSelectorByKind,
          runs => {
            return I.Set(runs)
              .flatMap(run =>
                (run.alerts || [])
                  .filter(a => getClassification(a) === classification)
                  .map(a => a.ruleID)
              )
              .filter(r => r)
              .sort()
              .join(", ");
          },
          cves,
          toolIDs
        ),
        outDir,
        format
      );
      writeTable(
        `${kind}-${classification}-alerts`,
        buildResultsReportTable(
          `${kind} ${classification} alerts`,
          bcves,
          runSelectorByKind,
          runs => {
            let reduced = runs.reduce(
              (c, r) =>
                r.alerts === undefined
                  ? c
                  : c +
                    I.Seq(r.alerts).count(
                      r => getClassification(r) === classification
                    ),
              0
            );
            return reduced === undefined ? undefined : reduced + "";
          },
          cves,
          toolIDs
        ),
        outDir,
        format
      );

      writeTable(
        `${kind}-${classification}-alerts-for-TP-queries`,
        buildResultsReportTable(
          `${kind} ${classification} alerts for TP queries`,
          bcves,
          runSelectorByKind,
          (runs, cve, toolID) => {
            let tpRules = getPatchBaseTpRules(cve, toolID);

            if (tpRules.isEmpty()) {
              return undefined;
            }
            let reduced = runs.reduce(
              (c, r) =>
                r.alerts === undefined
                  ? c
                  : c +
                    I.Seq(r.alerts).count(
                      r =>
                        getClassification(r) === classification &&
                        tpRules.has(r.ruleID)
                    ),
              0
            );
            return reduced === undefined ? undefined : reduced + "";
          },
          cves,
          toolIDs
        ),
        outDir,
        format
      );

      writeTable(
        `${kind}-${classification}-links`,
        buildResultsReportTable(
          `${kind} ${classification} links`,
          bcves,
          runSelectorByKind,
          (runs, cve) => {
            return runs
              .map(run =>
                (run.alerts || []).filter(
                  a => getClassification(a) === classification
                )
              )
              .map(alerts =>
                alerts.length > 100
                  ? `(${alerts.length} links)`
                  : I.Set(alerts)
                      .groupBy(a => a.ruleID)
                      .map((alerts, rule) => {
                        let alertStrings = alerts
                          .map(w => {
                            if (w.format !== "simple") {
                              throw new Error(
                                `Can only handle weaknesses in the 'simple' format ${JSON.stringify(
                                  w
                                )}`
                              );
                            }
                            if (!w.location) {
                              return undefined; // TODO remove this case, it is a hack that supports indicating knowledge about the existince of unspecified FPs
                            }
                            let bcves = bcvesByCVE.get(cve);
                            let url = makeSourceURL(
                              bcves./* singletons as they are grouped by CVE */ first(),
                              w.location,
                              "patchBase"
                            );
                            if (format === Format.md) {
                              let text = formatSourceLocation(w.location);
                              return `[${mdescape(text)}](${mdescape(url)})`;
                            } else {
                              return url;
                            }
                          })
                          .filter(u => u !== undefined);
                        return `${rule}: ${alertStrings.sort().join(", ")}`;
                      })
                      .valueSeq()
                      .sort()
                      .join(". ")
              )
              .join(" ");
          },
          cves,
          toolIDs
        ),
        outDir,
        format
      );
    }
  }
}

function formatSourceLocation(l: SourceLocation) {
  return `${l.file}:${l.line}`;
}
function makeSourceURL(
  bcve: BCVE,
  location: SourceLocation,
  kind: "patchBase" | "postPatch"
): string {
  let githubRepoPattern = /^https:\/\/github.com\/([^/]+)\/([^/]+)\.git$/;
  let github = bcve.repository.match(githubRepoPattern);
  if (github) {
    let [, owner, repo] = github,
      sha = bcve[kind].commit;
    // https://github.com/GoogleChrome/rendertron.git
    return `https://github.com/${owner}/${repo}/blob/${sha}/${location.file}#L${location.line}`;
  }
  return undefined;
}
function buildResultsReportTable(
  title: string,
  bcves: BCVE[],
  runSelector: (bcve: BCVE) => BCVERun[],
  runsMapper: (runs: BCVERun[], cve: CVEString, toolID: ToolID) => string,
  cves: CVEString[],
  toolIDs: ToolID[]
): SimpleTable {
  let byCVEAndToolID = I.Set(bcves)
    .groupBy(bcve => bcve.CVE)
    .map((cvesByCVE, cve) =>
      cvesByCVE
        .flatMap(runSelector)
        .filter(r => r !== undefined)
        .groupBy(runByCVE => runByCVE.toolID)
        .map((allRunsByCVEAndToolID, toolID) =>
          runsMapper(allRunsByCVEAndToolID.toSet().toArray(), cve, toolID)
        )
    );
  let weaknessDescriptions = I.Set(bcves)
    .groupBy(bcve => bcve.CVE)
    .map(bcves =>
      bcves
        .flatMap(bcve =>
          bcve.patchBase.weaknesses.map(w => {
            if (w.format !== "simple") {
              throw new Error(
                `Can only handle weaknesses in the 'simple' format. Got: ${JSON.stringify(
                  w
                )} for ${bcve.CVE}`
              );
            }

            return w.format === "simple" && w.explanation;
          })
        )
        .join(", ")
    );
  let rows = cves.map(cve => {
    let rowName = cve,
      rowValues = toolIDs
        .map(toolID => byCVEAndToolID.get(cve, I.Map()).get(toolID))
        .map(v => {
          return v === undefined ? "" : v + "";
        });
    return [rowName].concat([weaknessDescriptions.get(cve)]).concat(rowValues);
  });
  return {
    title,
    headers: ["CVE", "Descriptions"].concat(toolIDs),
    rows
  };
}
function makeOverviewReport(bcves: BCVE[], outDir: Dir, format: Format) {
  writeTable(
    "overview",
    {
      title: "Overview",
      headers: ["CVE", "CWEs", "Repository", "Weaknesses", "Downloaded"],
      rows: bcves
        .map(bcve => {
          let patcbBaseDownloaded =
              bcve.patchBase.localSourceDirectory &&
              fs.existsSync(bcve.patchBase.localSourceDirectory),
            postPatchDownloaded =
              bcve.postPatch.localSourceDirectory &&
              fs.existsSync(bcve.postPatch.localSourceDirectory),
            downloaded =
              patcbBaseDownloaded && postPatchDownloaded
                ? "ALL"
                : patcbBaseDownloaded || postPatchDownloaded
                ? "SOME"
                : "NONE";
          return [
            bcve.CVE,
            bcve.CWEs.sort().join(" "),
            bcve.repository,
            "" + bcve.patchBase.weaknesses.length,
            downloaded
          ];
        })
        .sort((r1, r2) => r1.toString().localeCompare(r2.toString()))
    },
    outDir,
    format
  );
}

export async function reportMaker(
  bcves: BCVE[],
  outDir: Dir,
  format: Format
): Promise<void> {
  makeOverviewReport(bcves, outDir, format);
  makeResultsReports(bcves, outDir, format);
}
