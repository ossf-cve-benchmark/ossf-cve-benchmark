import { BCVE, CVEState, CVEString, Dir, File } from "./types";
import { assert, readBCVEFile } from "./util";
import * as fs from "fs";
import * as I from "immutable";
import * as path from "path";
interface Ref {
  matches(bcve: BCVE): boolean;
}

const cvePattern = /^(?:CVE-(1999|2\d{3})-(0\d{2}[0-9]|[1-9]\d{3,}))$/;
const cwePattern = /^CWE-(\d+)$/;

class AnyRef implements Ref {
  public matches(_: BCVE) {
    return true;
  }
  toString(): string {
    return "AnyRef()";
  }
}

class IncompleteRef implements Ref {
  public matches(bcve: BCVE) {
    let complete =
      // `state` is `ACCEPTED`
      (bcve.state === undefined || bcve.state === CVEState.ACCEPTED) &&
      // `patchBase` exists and contains at least one relevant weakness
      bcve.patchBase &&
      bcve.patchBase.weaknesses &&
      bcve.patchBase.weaknesses.length > 0 &&
      // `postPatch` exists and contains zero relevant weaknesses
      bcve.postPatch &&
      (bcve.postPatch.weaknesses === undefined ||
        bcve.postPatch.weaknesses.length === 0);
    return !complete;
  }
  toString(): string {
    return "AnyRef()";
  }
}

class CVERef implements Ref {
  constructor(private cve: CVEString) {
    if (!cvePattern.exec(cve)) {
      throw new Error(`Invalid CVE for CVERef: ${cve}`);
    }
  }
  public matches(bcve: BCVE) {
    return this.cve === bcve.CVE;
  }
  toString(): string {
    return `CveRef(${this.cve})`;
  }
}

class YearRef implements Ref {
  constructor(private year: number) {
    if (isNaN(this.year)) {
      throw new Error(`Year is NaN (${this.year})`);
    }
  }
  public matches(bcve: BCVE) {
    return this.year === +bcve.CVE.match(cvePattern)[1];
  }
  toString(): string {
    return `YearRef(${this.year})`;
  }
}

class ExtensionRef implements Ref {
  constructor(private ext: string) {}
  public matches(bcve: BCVE) {
    return [bcve.patchBase.weaknesses, bcve.postPatch.weaknesses]
      .filter(ws => !!ws)
      .flatMap(ws => ws)
      .filter(w => w?.location)
      .some(w => w.location.file.endsWith(`.${this.ext}`));
  }
  toString(): string {
    return `ExtensionRef(${this.ext})`;
  }
}

class CWERef implements Ref {
  constructor(private cweNumber: number) {}
  public matches(bcve: BCVE) {
    return bcve.CWEs.map(cwe => +cwe.match(cwePattern)[1]).includes(
      this.cweNumber
    );
  }
  toString(): string {
    return `CWERef(${this.cweNumber})`;
  }
}

class MitreCWETopRef implements Ref {
  private targetCWEnumbers: number[];
  constructor(private limit: number, private year: number) {
    let data: { [year: number]: number[] } = {
      // https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html#cwe_top_25
      2019: [
        119,
        79,
        20,
        20,
        12,
        89,
        41,
        19,
        35,
        22,
        78,
        78,
        28,
        47,
        73,
        43,
        61,
        94,
        79,
        40,
        77,
        42,
        50,
        26,
        295
      ],
      // https://cwe.mitre.org/top25/archive/2020/2020_cwe_top25.html#cwe_top_25
      2020: [
        79,
        787,
        20,
        125,
        119,
        89,
        200,
        416,
        352,
        78,
        190,
        22,
        476,
        287,
        434,
        732,
        94,
        522,
        611,
        798,
        502,
        269,
        400,
        306,
        862
      ]
    };
    if (!Object.keys(data).includes(year + "")) {
      throw new Error(
        `No top-CWE data for year ${year} (has data for ${JSON.stringify(
          Object.keys(data)
        )})`
      );
    }
    this.targetCWEnumbers = data[year].slice(0, limit);
    if (this.targetCWEnumbers.length !== limit) {
      throw new Error(
        `Got ${data[year].length} CWEs from ${year}, but the requested number of CWEs is ${limit}`
      );
    }
  }
  public matches(bcve: BCVE) {
    let bcveCWENumbers = bcve.CWEs.map(cwe => +cwe.match(cwePattern)[1]);
    return this.targetCWEnumbers.some(targetCWENumber =>
      bcveCWENumbers.includes(targetCWENumber)
    );
  }
  toString(): string {
    return `MitreCWETopRef(${this.limit}, ${this.year})`;
  }
}

export function filterRawInputLine(line: string) {
  let trimmed = line.trim();
  return trimmed.length > 0 && !trimmed.startsWith("#");
}

export function parse(s: string): Ref {
  if (s === "*") {
    return new AnyRef();
  }
  let match = s.match(cvePattern);
  if (match) {
    return new CVERef(s);
  }
  match = s.match(/^year:(\d+)$/);
  if (match) {
    return new YearRef(+match[1]);
  }
  match = s.match(/^ext:(.*)$/);
  if (match) {
    return new ExtensionRef(match[1]);
  }
  match = s.match(/^CWE-(\d+)$/);
  if (match) {
    return new CWERef(+match[1]);
  }
  match = s.match(/^mitre-cwe-top:(\d+):(\d+)$/);
  if (match) {
    return new MitreCWETopRef(+match[1], +match[2]);
  }
  match = s.match(/^incomplete$/);
  if (match) {
    return new IncompleteRef();
  }
  throw new Error(`Could not parse '${s}' as a Ref`);
}
function pad(str: string, max: number): string {
  return str.length < max ? pad("0" + str, max) : str;
}
export function resolve(refs: Ref[], bcvesDir: Dir, sourcesDir?: Dir): BCVE[] {
  return I.Set(fs.readdirSync(bcvesDir))
    .filter(f => f.match(/(.*)\.json/))
    .map((f: File): BCVE => readBCVEFile(path.join(bcvesDir, f)))
    .filter(bcve => refs.some(ref => ref.matches(bcve)))
    .map(bcve => {
      if (sourcesDir) {
        if (bcve.patchBase?.commit) {
          bcve.patchBase.localSourceDirectory = path.join(
            sourcesDir,
            bcve.CVE,
            bcve.patchBase.commit
          );
          assert(bcve.patchBase.localSourceDirectory.startsWith(sourcesDir));
        }
        if (bcve.postPatch?.commit) {
          bcve.postPatch.localSourceDirectory = path.join(
            sourcesDir,
            bcve.CVE,
            bcve.postPatch.commit
          );
          assert(bcve.postPatch.localSourceDirectory.startsWith(sourcesDir));
        }
      }
      // normalize CWEs to be of the form (CWE-\d\d\d\d)
      bcve.CWEs = bcve.CWEs.map(cwe => {
        let match = cwe.match(/(CWE-)(\d+)/);
        if (match) {
          return match[1] + pad((+match[2]).toString(), 4);
        }
      });
      return bcve;
    })
    .sortBy(bcve => bcve.CVE)
    .toArray();
}
