// XXX most of this file should be moved elsewhere
import * as React from "react";
import { ToolID } from "src/types";
import { Alert, Weakness, CommitData } from "./shared-types";

const fetchCache = new Map<string, any>();
export async function cachingJSONFetch(url: string): Promise<any> {
  if (!fetchCache.has(url)) {
    fetchCache.set(url, await (await fetch(url)).json());
  }
  return fetchCache.get(url);
}
export async function cachingTextFetch(url: string): Promise<string> {
  if (!fetchCache.has(url)) {
    fetchCache.set(url, await (await fetch(url)).text());
  }
  return fetchCache.get(url);
}

export function mkSimpleURL(
  path: string,
  params: { [k: string]: string }
): string {
  let paramsString = Object.entries(params)
    .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    .join("&");
  return `${path}?${paramsString}`;
}

export function compareToolIDs(t1: ToolID, t2: ToolID) {
  return t1.localeCompare(t2);
}

export function groupAlertsByTool(alerts: Alert[], toolIDs: string[]) {
  return toolIDs.map(toolID => ({
    toolID,
    alerts: alerts.filter(a => a.toolID === toolID)
  }));
}

export async function getSource(
  CVE: string,
  commit: string,
  file: string
): Promise<string> {
  return (
    (await cachingTextFetch(
      mkSimpleURL("/sources", {
        CVE,
        commit,
        file
      })
    )) || undefined // XXX this is a hacky way to handle ""
  );
}
export function makeToolColumnKey(toolID: string) {
  return "tool-column-for-" + toolID;
}
export function getToolIcon(toolID: string, toolIDs: string[]) {
  let order = getToolOrderID(toolID, toolIDs);
  let icons = [
    "\u25A2",
    "\u25B3",
    "\u25EF",
    "\u25C7",
    "\u25A3",
    "\u25C8",
    "\u25C9"
  ];
  return icons[order] || "?";
}
export function getToolOrderID(toolID: string, toolIDs: string[]): number {
  return toolIDs.indexOf(toolID);
}

export function makeCompactLocationString(file: string, line: number) {
  return `${file}:${line}`;
}
export type SetSourceFocus = (o: {
  source: string;
  line: number;
  file: string;
  commit: string;
}) => void;
export type AlertCountComparison = {
  toolID: string;
  conclusion: RelevantQueryResultCountChangeConclusion;
  counts: { before: number; after: number; ruleID: string; ruleURL: string }[];
};
export enum RelevantQueryResultCountChangeConclusion {
  Negative = "Negative",
  NeutralOrPositive = "NeutralOrPositive",
  Uncomputable = "Uncomputable",
  Missing = "Missing"
}

export function mkRuleListSentence(
  rulesAndUrls: { ruleID: string; url?: string }[]
) {
  rulesAndUrls = Array.from(rulesAndUrls).sort((r1, r2) =>
    r1.ruleID.localeCompare(r2.ruleID)
  );
  return rulesAndUrls.map(({ ruleID, url }, i) => {
    return (
      <span key={i}>
        {i > 0 && ", "}
        <a href={url}>
          <span className="ruleID">{ruleID}</span>
        </a>
      </span>
    );
  });
}
export function mkToolIDString(toolID: string) {
  return <span className="toolID">{toolID}</span>;
}

export const icons = {
  // XXX move this closer to the React components
  // XXX control the colors in a less hacky way
  checkmark: (
    <span
      style={{
        textShadow: `0px 0px lightgray`,
        color: "transparent"
      }}
    >
      {"\u2714"}
    </span>
  ),
  cross: (
    <span
      style={{
        textShadow: `0px 0px lightgray`,
        color: "transparent"
      }}
    >
      {"\u274C"}
    </span>
  )
};

export function mkCommitUrl(commit: CommitData) {
  return <a href={commit.permalink}>{commit.commit.slice(0, 7)}</a>;
}
type RelevantRuleAlertCounts = {
  before: number;
  after: number;
  ruleID: string;
  ruleURL: string;
};
export function getRelevantRuleAlertCounts(
  alerts: Alert[],
  unpatchedCommit: string,
  patchedCommit: string
): RelevantRuleAlertCounts[] {
  let relevantRuleAlertsMap: {
    [ruleID: string]: RelevantRuleAlertCounts;
  } = {};
  alerts
    .filter(a => a.isForRuleOnATarget)
    .forEach(a => {
      relevantRuleAlertsMap[a.ruleID] = relevantRuleAlertsMap[a.ruleID] || {
        ruleID: a.ruleID,
        ruleURL: a.url, // XXX assuming 1:1 relationship between ID and URL (fine, but it should be documented)
        before: 0,
        after: 0
      };
      if (a.commit === unpatchedCommit) {
        relevantRuleAlertsMap[a.ruleID].before++;
      }
      if (a.commit === patchedCommit) {
        relevantRuleAlertsMap[a.ruleID].after++;
      }
    });
  return Object.values(relevantRuleAlertsMap);
}

export function getRelevantRuleAlertCountsConclusion(
  counts: RelevantRuleAlertCounts[],
  hasBeforeAndAfter: boolean
) {
  if (!hasBeforeAndAfter) {
    return RelevantQueryResultCountChangeConclusion.Missing;
  }
  if (counts.every(v => v.before === 0)) {
    return RelevantQueryResultCountChangeConclusion.Uncomputable;
  }
  if (counts.some(v => v.after - v.before < 0)) {
    return RelevantQueryResultCountChangeConclusion.Negative;
  }
  return RelevantQueryResultCountChangeConclusion.NeutralOrPositive;
}
export function getCSSQualifierClassForConclusion(
  conclusion: RelevantQueryResultCountChangeConclusion
) {
  let map = {
    [RelevantQueryResultCountChangeConclusion.Negative]: "good",
    [RelevantQueryResultCountChangeConclusion.NeutralOrPositive]: "bad",
    [RelevantQueryResultCountChangeConclusion.Uncomputable]: "uncomputable",
    [RelevantQueryResultCountChangeConclusion.Missing]: "missing"
  };
  return map[conclusion];
}

export function makeComparisons(
  toolIDs: string[],
  alerts: Alert[],
  unpatchedCommit: string,
  patchCommit: string,
  tool2commitWithRun: { [toolID: string]: string[] }
) {
  let comparisons: AlertCountComparison[] = [];
  toolIDs.forEach(toolID => {
    let counts = getRelevantRuleAlertCounts(
      alerts.filter(a => a.toolID === toolID),
      unpatchedCommit,
      patchCommit
    );
    let conclusion = getRelevantRuleAlertCountsConclusion(
      counts,
      (tool2commitWithRun[toolID] || []).includes(unpatchedCommit) &&
        (tool2commitWithRun[toolID] || []).includes(patchCommit)
    );

    comparisons.push({
      toolID,
      conclusion: conclusion,
      counts: counts
    });
  });
  return comparisons;
}
export function getCve2tool2commitRuns(
  runs: {
    CVE: string;
    toolID: string;
    commit: string;
  }[]
) {
  let mapped: {
    [cve: string]: { [toolID: string]: string[] };
  } = {};
  runs.forEach(r => {
    mapped[r.CVE] = mapped[r.CVE] || {};
    mapped[r.CVE][r.toolID] = mapped[r.CVE][r.toolID] || [];
    mapped[r.CVE][r.toolID].push(r.commit);
  });
  return mapped;
}
export function countLocations(es: (Alert | Weakness)[]): number {
  return new Set(es.map(e => `${e.file}:${e.line}`)).size; // XXX hacky equality
}
