import * as React from "react";
import CVEResultSummarization from "./CVEResultSummarization";
import * as MyCodeMirrors from "./MyCodeMirrors";
import {
  cachingJSONFetch,
  cachingTextFetch,
  getSource,
  mkSimpleURL
} from "./util";
import { Alert, CommitData, Weakness } from "./shared-types";

function byLineSorter(a1: Weakness & Alert, a2: Weakness & Alert) {
  // this line-sorting is apparently important for CodeMirror performance
  let cmp = a1.line - a2.line;
  if (cmp !== 0) {
    return cmp;
  }
  return a1.explanation.localeCompare(a2.explanation);
}
async function getSortedAlerts(cve: string) {
  let alerts: Alert[] = await cachingJSONFetch(
    mkSimpleURL("/data/getAlerts", {
      CVE: cve
    })
  );
  return alerts.sort(byLineSorter);
}
async function getSortedWeaknesses(cve: string) {
  let weaknesses: Weakness[] = await cachingJSONFetch(
    mkSimpleURL("/data/getCVEWeaknesses", {
      CVE: cve
    })
  );
  return weaknesses.sort(byLineSorter);
}

// TODO reformulate data entirely? Rely on the stable BCVE type instead?
type Props = {
  CVE: string;
  toolIDs: string[];
  toolRuns: { [toolID: string]: string[] };
  CWEs: string[];
};
type State = {
  source?: string;
  commit?: string;
  file?: string;
  line?: number;
  alerts: Alert[];
  weaknesses: Weakness[];
  unpatchedCommit?: CommitData;
  patchCommit?: CommitData;
  repository?: string;
};

export class CVEResults extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { alerts: [], weaknesses: [] };
  }
  async componentDidMount() {
    let weaknesses = await getSortedWeaknesses(this.props.CVE);

    let { patchCommit, unpatchedCommit } = await cachingJSONFetch(
      mkSimpleURL("/data/getCVECommits", {
        CVE: this.props.CVE
      })
    );
    let repository = await cachingTextFetch(
      mkSimpleURL("/data/getCVERepository", {
        CVE: this.props.CVE
      })
    );
    let selection = weaknesses[0],
      alerts = await getSortedAlerts(this.props.CVE),
      source =
        selection &&
        (await getSource(this.props.CVE, selection.commit, selection.file));
    this.setState({
      alerts,
      weaknesses,
      file: selection?.file,
      line: selection?.line,
      source,
      commit: selection?.commit,
      patchCommit: patchCommit,
      unpatchedCommit: unpatchedCommit,
      repository: repository
    });
  }
  render() {
    if (this.state.unpatchedCommit === undefined) {
      return null; // XXX not yet mounted
    }
    let self = this;
    function setSourceFocus(o: {
      source: string;
      line: number;
      file: string;
      commit: string;
    }) {
      self.setState(o);
    }

    function isRelevant(a: Weakness & Alert) {
      return a.file === self.state.file && a.commit === self.state.commit;
    }
    return (
      <div>
        <h2>{self.props.CVE}</h2>
        <h3>
          <a href={self.state.repository}>
            {extractRepoSlug(self.state.repository)}
          </a>
        </h3>
        <CVEResultSummarization
          CVE={self.props.CVE}
          toolIDs={self.props.toolIDs}
          setSourceFocus={setSourceFocus}
          alerts={self.state.alerts}
          weaknesses={self.state.weaknesses}
          patchCommit={self.state.patchCommit}
          unpatchedCommit={self.state.unpatchedCommit}
          toolRuns={self.props.toolRuns}
          CWEs={this.props.CWEs}
        />{" "}
        <hr />
        <h2 className="source-code">Source code</h2>
        <MyCodeMirrors.default.AnnotatedCodeMirror
          toolIDs={self.props.toolIDs}
          source={self.state.source}
          file={self.state.file}
          fileUrl={getFileUrl(self.state.commit, self.state.file, [
            (self.state.patchCommit, self.state.unpatchedCommit)
          ])}
          line={self.state.line}
          gutterAnnotations={self.state.alerts.filter(isRelevant)}
          lineAnnotations={self.state.weaknesses.filter(isRelevant)}
        />
      </div>
    );
  }
}
function extractRepoSlug(repository: string) {
  let githubRepoPattern = /^https:\/\/github.com\/([^/]+)\/([^/]+)\.git$/;
  let github = repository.match(githubRepoPattern);
  if (github) {
    let [, owner, repo] = github;
    return `${owner}/${repo}`;
  }
  return undefined; // XXX
}

function getFileUrl(commit: string, file: string, commitData: CommitData[]) {
  // XXX make this less hacky
  let permalink = commitData.find(c => c.commit === commit)?.permalink;
  if (permalink) {
    let githubCommitPattern = /^(https:\/\/github.com\/[^/]+\/[^/]+)\/commit\/([a-f0-9]+)$/;
    let github = permalink.match(githubCommitPattern);
    if (github) {
      return `${github[1]}/blob/${github[2]}/${file}`;
    }
  }
  return undefined; // XXX
}
