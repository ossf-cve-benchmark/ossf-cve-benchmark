import { BCVE, CVEState, CVEString } from "./types";

interface Selector {
  matches(bcve: BCVE): boolean;
}

const cvePattern = /^(?:CVE-(1999|2\d{3})-(0\d{2}[0-9]|[1-9]\d{3,}))$/;
const cwePattern = /^CWE-(\d+)$/;

class AnySelector implements Selector {
  public matches(_: BCVE) {
    return true;
  }
  toString(): string {
    return "AnySelector()";
  }
}

class IncompleteSelector implements Selector {
  public matches(bcve: BCVE) {
    let complete =
      // `state` is `ACCEPTED`
      (bcve.state === undefined || bcve.state === CVEState.ACCEPTED) &&
      // `prePatch` exists and contains at least one relevant weakness
      bcve.prePatch &&
      bcve.prePatch.weaknesses &&
      bcve.prePatch.weaknesses.length > 0 &&
      // `postPatch` exists and contains zero relevant weaknesses
      bcve.postPatch &&
      (bcve.postPatch.weaknesses === undefined ||
        bcve.postPatch.weaknesses.length === 0);
    return !complete;
  }
  toString(): string {
    return "AnySelector()";
  }
}

class CVESelector implements Selector {
  constructor(private cve: CVEString) {
    if (!cvePattern.exec(cve)) {
      throw new Error(`Invalid CVE for CVESelector: ${cve}`);
    }
  }
  public matches(bcve: BCVE) {
    return this.cve === bcve.CVE;
  }
  toString(): string {
    return `CveSelector(${this.cve})`;
  }
}

class YearSelector implements Selector {
  constructor(private year: number) {
    if (isNaN(this.year)) {
      throw new Error(`Year is NaN (${this.year})`);
    }
  }
  public matches(bcve: BCVE) {
    return this.year === +bcve.CVE.match(cvePattern)[1];
  }
  toString(): string {
    return `YearSelector(${this.year})`;
  }
}

class ExtensionSelector implements Selector {
  constructor(private ext: string) {}
  public matches(bcve: BCVE) {
    return [bcve.prePatch.weaknesses, bcve.postPatch.weaknesses]
      .filter(ws => !!ws)
      .flatMap(ws => ws)
      .filter(w => w?.location)
      .some(w => w.location.file.endsWith(`.${this.ext}`));
  }
  toString(): string {
    return `ExtensionSelector(${this.ext})`;
  }
}

class CWESelector implements Selector {
  constructor(private cweNumber: number) {}
  public matches(bcve: BCVE) {
    return bcve.CWEs.map(cwe => +cwe.match(cwePattern)[1]).includes(
      this.cweNumber
    );
  }
  toString(): string {
    return `CWESelector(${this.cweNumber})`;
  }
}

class MitreCWETopSelector implements Selector {
  private targetCWEnumbers: number[];
  constructor(private limit: number, private year: number) {
    let data: { [year: number]: number[] } = {
      // https://cwe.mitre.org/top25/archive/2019/2019_cwe_top25.html#cwe_top_25
      2019: [
        119,
        79,
        20,
        20,
        12,
        89,
        41,
        19,
        35,
        22,
        78,
        78,
        28,
        47,
        73,
        43,
        61,
        94,
        79,
        40,
        77,
        42,
        50,
        26,
        295
      ],
      // https://cwe.mitre.org/top25/archive/2020/2020_cwe_top25.html#cwe_top_25
      2020: [
        79,
        787,
        20,
        125,
        119,
        89,
        200,
        416,
        352,
        78,
        190,
        22,
        476,
        287,
        434,
        732,
        94,
        522,
        611,
        798,
        502,
        269,
        400,
        306,
        862
      ]
    };
    if (!Object.keys(data).includes(year.toString())) {
      throw new Error(
        `No top-CWE data for year ${year} (has data for ${JSON.stringify(
          Object.keys(data)
        )})`
      );
    }
    this.targetCWEnumbers = data[year].slice(0, limit);
    if (this.targetCWEnumbers.length !== limit) {
      throw new Error(
        `Got ${data[year].length} CWEs from ${year}, but the requested number of CWEs is ${limit}`
      );
    }
  }
  public matches(bcve: BCVE) {
    let bcveCWENumbers = bcve.CWEs.map(cwe => +cwe.match(cwePattern)[1]);
    return this.targetCWEnumbers.some(targetCWENumber =>
      bcveCWENumbers.includes(targetCWENumber)
    );
  }
  toString(): string {
    return `MitreCWETopSelector(${this.limit}, ${this.year})`;
  }
}

export function filterRawInputLine(line: string): boolean {
  let trimmed = line.trim();
  return trimmed.length > 0 && !trimmed.startsWith("#");
}

export function getSupportedSyntaxExplanations(): string[] {
  // XXX this ought to be better in sync with the parse function below!
  return [
    "wildcard, ex. '*'",
    "CVE identifier, ex. 'CVE-2020-15119'",
    "year, ex. 'year:2020'",
    "file name extension, ex. 'ext:js'",
    "CWE identifier, ex. 'CWE-079'",
    "MITRE CWE top list, ex. 'mitre-cwe-top:25:2020'",
    "incomplete, ex. 'incomplete'"
  ].sort();
}
export function parse(s: string): Selector {
  if (s === "*") {
    return new AnySelector();
  }
  let match = s.match(cvePattern);
  if (match) {
    return new CVESelector(s);
  }
  match = s.match(/^year:(\d+)$/);
  if (match) {
    return new YearSelector(+match[1]);
  }
  match = s.match(/^ext:(.*)$/);
  if (match) {
    return new ExtensionSelector(match[1]);
  }
  match = s.match(/^CWE-(\d+)$/);
  if (match) {
    return new CWESelector(+match[1]);
  }
  match = s.match(/^mitre-cwe-top:(\d+):(\d+)$/);
  if (match) {
    return new MitreCWETopSelector(+match[1], +match[2]);
  }
  match = s.match(/^incomplete$/);
  if (match) {
    return new IncompleteSelector();
  }
  throw new Error(`Could not parse '${s}' as a Selector`);
}
export function filter(selectors: Selector[], bcves: BCVE[]): BCVE[] {
  return bcves.filter(bcve => selectors.some(ref => ref.matches(bcve)));
}
