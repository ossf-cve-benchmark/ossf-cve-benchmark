import * as fs from "fs";
import * as I from "immutable";
import * as path from "path";
import * as selectors from "./selectors";
import { BCVE, BCVERun, Config, Export, StandaloneRun, ToolID } from "./types";
import {
  anonymizeBCVEs,
  readBCVEFiles,
  readExportFile,
  readLogFile,
  readStdinLines,
  setDifference
} from "./util";

export async function filterToCommandlineSelectors(
  bcves: BCVE[],
  selectorStrings: string[]
): Promise<BCVE[]> {
  if (selectorStrings.length === 1 && selectorStrings[0] === "-") {
    selectorStrings = (await readStdinLines()).filter(
      selectors.filterRawInputLine
    );
  }
  return selectors.filter(selectorStrings.map(selectors.parse), bcves);
}

export async function getBCVEsWithRuns(
  config: Config,
  args: {
    import?: string;
    selectors: string[];
    tool: ToolID[];
    no_sources?: boolean;
    allow_incomplete?: boolean;
    anonymize: boolean;
  },
  allowUnmatchedTools: boolean
): Promise<BCVE[]> {
  let bcves;

  if (args.import) {
    let imported = readExportFile(args.import);
    bcves = await filterToCommandlineSelectors(imported, args.selectors);
    if (!allowUnmatchedTools) {
      checkForMissingToolIDsInRuns(
        args.tool,
        bcves.flatMap(bcve =>
          [bcve.postPatch, bcve.prePatch]
            .flatMap(c => c.runs || [])
            .flatMap(r => r.toolID)
        )
      );
    }
    restrictRunsToSpecififiedToolIDs(bcves, new Set(args.tool));
  } else {
    bcves = await buildFullExportObject(config, args, allowUnmatchedTools);
  }
  if (args.anonymize) {
    anonymizeBCVEs(bcves);
  }
  return bcves;
}
function restrictRunsToSpecififiedToolIDs(
  bcves: BCVE[],
  toolIDs: Set<ToolID>
): void {
  bcves.forEach(bcve =>
    [bcve.prePatch, bcve.postPatch].forEach(c => {
      if (c.runs !== undefined) {
        c.runs = filterRunsToChosenToolIDs(
          c.runs,
          toolIDs.size === 0 ? undefined : toolIDs
        );
      }
    })
  );
}

function filterRunsToChosenToolIDs<T extends BCVERun | StandaloneRun>(
  runs: T[],
  toolIDs?: Set<ToolID>
): T[] {
  return toolIDs === undefined ? runs : runs.filter(r => toolIDs.has(r.toolID));
}
export async function buildFullExportObject(
  config: Config,
  args: {
    selectors: string[];
    tool: ToolID[];
    no_sources?: boolean;
    allow_incomplete?: boolean;
    anonymize: boolean;
  },
  allowUnmatchedTools: boolean
): Promise<Export> {
  let bcves = await filterToCommandlineSelectors(
      readBCVEFiles(
        config.bcves,
        args.no_sources ? undefined : config.sources,
        args.allow_incomplete
      ),
      args.selectors
    ),
    cves = new Set(bcves.map(bcve => bcve.CVE)),
    runs = fs.existsSync(config.results)
      ? fs
          .readdirSync(config.results)
          .map(f => path.join(config.results, f))
          .map(f => {
            try {
              return readLogFile(f);
            } catch (e) {
              console.error(`Ignoring invalid log file ${f}`);
            }
          })
          .filter(l => !!l)
          .flatMap(l => l.runs)
          .filter(run => cves.has(run.CVE))
      : [],
    toolIDs = new Set(args.tool);

  if (!allowUnmatchedTools) {
    checkForMissingToolIDsInRuns(
      args.tool,
      runs.map(r => r.toolID)
    );
  }
  linkRuns(
    bcves,
    filterRunsToChosenToolIDs(runs, toolIDs.size === 0 ? undefined : toolIDs)
  );
  if (args.anonymize) {
    anonymizeBCVEs(bcves);
  }
  return bcves;
}

function checkForMissingToolIDsInRuns(
  initialToolIDs: ToolID[],
  filteredToolIDs: ToolID[]
) {
  let missingToolIDs = setDifference(
    new Set(initialToolIDs),
    new Set(filteredToolIDs)
  );
  if (missingToolIDs.size !== 0) {
    let missingString = JSON.stringify([...missingToolIDs].sort()),
      availableString = JSON.stringify([...new Set(filteredToolIDs)].sort());
    throw new Error(
      `No runs for: ${missingString}. Has runs for: ${availableString}.`
    );
  }
}
function linkRuns(bcves: BCVE[], runs: StandaloneRun[]) {
  let bcvesByCVE = I.Set(bcves)
    .groupBy(bcve => bcve.CVE)
    .map(bcves => bcves.first<BCVE>());
  runs.forEach(standaloneRun => {
    let { CVE, commit, ...linkedRun } = standaloneRun;
    if (!bcvesByCVE.has(CVE)) {
      console.error(
        `Ignoring the run from ${standaloneRun.toolID} for ${CVE}, since there is no backing benchmark data.`
      );
      return;
    }
    let bcve = bcvesByCVE.get(CVE);
    switch (commit) {
      case bcve.prePatch.commit:
        bcve.prePatch.runs = bcve.prePatch.runs || [];
        bcve.prePatch.runs.push(linkedRun);
        break;
      case bcve.postPatch.commit:
        bcve.postPatch.runs = bcve.postPatch.runs || [];
        bcve.postPatch.runs.push(linkedRun);
        break;
      default:
        console.error(
          `Ignoring the run from ${standaloneRun.toolID} for commit ${
            standaloneRun.commit
          }, since ${CVE} (${JSON.stringify([
            bcve.prePatch.commit,
            bcve.postPatch.commit
          ])}) do not contain that commit.`
        );
    }
  });
}
