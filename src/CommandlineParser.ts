import * as argparse from "argparse";
import { getSupportedSyntaxExplanations } from "./selectors";

enum Command {
  LIST,
  FILTER,
  TOOLS,
  RUN,
  EXPORT,
  REPORT,
  DOWNLOAD_COMMITS,
  UPLOAD_COMMITS,
  CHECK
}
enum Arg {
  CONFIG,
  BCVES,
  SOURCES,
  RESULTS,
  RUN_TOOL,
  FILTER_TOOL,
  NO_SOURCES,
  ANONYMIZE,
  ALLOW_INCOMPLETE,
  SELECTORS,
  IMPORT
  // XXX expand to include all of the non-shared args as well
}

export function mkCommandlineParser(
  exit_on_error: boolean
): argparse.ArgumentParser {
  /**
   * The user-facing help strings.
   */
  const help = {
    main: () => {
      return [
        "CLI for ossf-cve-benchmark",
        "",
        "The following commands are available:"
      ]
        .concat(
          Object.keys(Command)
            .filter(k => isNaN(Number(k)))
            .map(
              (k: keyof typeof Command) =>
                `- ${getCommandName(Command[k])}: ${help.getCommandHelp(
                  Command[k]
                )}`
            )
            .sort()
        )
        .join("\n");
    },
    getArgumentHelp: (arg: Arg) => {
      switch (arg) {
        case Arg.CONFIG:
          return "The configuration file to use (default: config.json of the working directory)";
        case Arg.BCVES:
          return "The directory that contains the benchmark CVEs (default: `/CVEs` of the project directory.)";
        case Arg.SOURCES:
          return "The directory that contains source code of the benchmark CVE commits (default: `/work/sources` of the project directory.)";
        case Arg.RESULTS:
          return "The directory that contains analysis tool driver results (default: `/work/results` of the project directory.)";
        case Arg.NO_SOURCES:
          return "Assumes no commits of any benchmark CVE are available locally when set.";
        case Arg.ANONYMIZE:
          return "Anonymizes the IDs of tools and rules when set.";
        case Arg.ALLOW_INCOMPLETE:
          return "Enables the use of incomplete benchmark CVEs when set";
        case Arg.IMPORT:
          return "The file to import data from instead of files in local directories.";
        case Arg.SELECTORS:
          return [
            "The CVE selectors that select the benchmark CVEs to use (disjunctive)."
          ]
            .concat(["Selectors:"])
            .concat(getSupportedSyntaxExplanations().map(l => `- ${l}`))
            .concat([
              "",
              "If a single '-' is used as a selector, the above selectors are read from stdin."
            ])
            .join("\n");
        case Arg.RUN_TOOL:
          return "The IDs of the analysis tool driver to run. The ID is used to look up the driver in the configuration file. (repeatable)";
        case Arg.FILTER_TOOL:
          return "The ID of the analysis tool driver to use results for. (repeatable)";
      }
    },
    getCommandHelp: (command: Command) => {
      switch (command) {
        case Command.LIST:
          return "Lists the selected CVEs";
        case Command.FILTER:
          return "Filters CVEs by inspecting the CVE data content (similar to grep)";
        case Command.TOOLS:
          return "Displays the analysis tools that are available for the `run` command";
        case Command.RUN:
          return "Runs analysis tools on the source code of the selected CVEs";
        case Command.EXPORT:
          return "Exports the selected data to a single, distributable file";
        case Command.REPORT:
          return "Generates reports of different kinds";
        case Command.DOWNLOAD_COMMITS:
          return "Downloads the relevant commits for the selected CVEs";
        case Command.CHECK:
          return "Checks if the provided files are valid according to a schema";
        case Command.UPLOAD_COMMITS:
          return "Uploads the relevant commits for the selected CVEs";
      }
    }
  };

  let ArgumentParser = argparse.ArgumentParser,
    parser = new ArgumentParser({
      add_help: true,
      prog: "bin/cli",
      description: help.main(),
      formatter_class: argparse.RawTextHelpFormatter,
      exit_on_error: exit_on_error
    }),
    rootParser = parser,
    subparsers = rootParser.add_subparsers({ dest: "command" });

  function getArgumentName(arg: Arg) {
    switch (arg) {
      case Arg.CONFIG:
        return "--config";
      case Arg.BCVES:
        return "--bcves";
      case Arg.SOURCES:
        return "--sources";
      case Arg.RESULTS:
        return "--results";
      case Arg.RUN_TOOL:
        return "--tool";
      case Arg.FILTER_TOOL:
        return "--tool";
      case Arg.NO_SOURCES:
        return "--no_sources";
      case Arg.ANONYMIZE:
        return "--anonymize";
      case Arg.ALLOW_INCOMPLETE:
        return "--allow-incomplete";
      case Arg.IMPORT:
        return "--import";
      case Arg.SELECTORS:
        return "selectors";
    }
  }
  function isBooleanArg(arg: Arg) {
    switch (arg) {
      case Arg.ANONYMIZE:
      case Arg.ALLOW_INCOMPLETE:
      case Arg.NO_SOURCES:
        return true;
      default:
        return false;
    }
  }

  function addArg(
    arg: Arg,
    parser: argparse.ArgumentParser,
    options: argparse.ArgumentOptions = {}
  ) {
    options = { ...options };
    if (isBooleanArg(arg)) {
      options.action = "store_true";
    }
    if (arg === Arg.SELECTORS) {
      options.nargs = "+";
    }
    if (arg === Arg.FILTER_TOOL || arg === Arg.RUN_TOOL) {
      options.action = "append";
    }
    if (arg === Arg.RUN_TOOL) {
      options.required = true;
    }
    options.help = help.getArgumentHelp(arg);
    parser.add_argument(getArgumentName(arg), options);
  }

  function addOptionalArgs(args: Arg[], parser: argparse.ArgumentParser) {
    args.forEach(arg => {
      addArg(arg, parser, { required: false });
    });
  }
  function addArgs(args: Arg[], parser: argparse.ArgumentParser) {
    args.forEach(arg => {
      addArg(arg, parser, {});
    });
  }
  function getCommandName(command: Command) {
    switch (command) {
      case Command.REPORT:
        return "report";
      case Command.LIST:
        return "list";
      case Command.FILTER:
        return "filter";
      case Command.TOOLS:
        return "tools";
      case Command.RUN:
        return "run";
      case Command.EXPORT:
        return "export";
      case Command.DOWNLOAD_COMMITS:
        return "download-commits";
      case Command.CHECK:
        return "check";
      case Command.UPLOAD_COMMITS:
        return "upload-commits";
    }
  }
  function addSubParser(
    command: Command,
    callback: (parser: argparse.ArgumentParser) => void
  ): void {
    callback(
      subparsers.add_parser(getCommandName(command), {
        add_help: true,
        description: help.getCommandHelp(command),
        formatter_class: argparse.RawTextHelpFormatter
      })
    );
  }

  addSubParser(Command.DOWNLOAD_COMMITS, parser => {
    addOptionalArgs([Arg.CONFIG, Arg.BCVES, Arg.SOURCES], parser);
    addArgs([Arg.SELECTORS], parser);
    parser.add_argument("--anonymous", {
      required: false,
      action: "store_true"
    });
  });

  addSubParser(Command.UPLOAD_COMMITS, parser => {
    addOptionalArgs([Arg.CONFIG, Arg.BCVES, Arg.SOURCES], parser);
    addArgs([Arg.SELECTORS], parser);
  });

  addSubParser(Command.RUN, parser => {
    addOptionalArgs([Arg.CONFIG, Arg.BCVES, Arg.SOURCES, Arg.RESULTS], parser);
    addArgs([Arg.RUN_TOOL, Arg.SELECTORS], parser);
  });

  addSubParser(Command.EXPORT, parser => {
    addOptionalArgs(
      [
        Arg.CONFIG,
        Arg.BCVES,
        Arg.SOURCES,
        Arg.RESULTS,
        Arg.ANONYMIZE,
        Arg.ALLOW_INCOMPLETE,
        Arg.NO_SOURCES,
        Arg.FILTER_TOOL
      ],
      parser
    );
    addArgs([Arg.SELECTORS], parser);
    parser.add_argument("--export", {
      required: false
    });
    parser.add_argument("--no-export-file", {
      required: false,
      action: "store_true"
    });
  });

  addSubParser(Command.REPORT, parser => {
    addOptionalArgs(
      [
        Arg.CONFIG,
        Arg.BCVES,
        Arg.SOURCES,
        Arg.RESULTS,
        Arg.ANONYMIZE,
        Arg.ALLOW_INCOMPLETE,
        Arg.NO_SOURCES,
        Arg.IMPORT
      ],
      parser
    );
    addArgs([Arg.FILTER_TOOL, Arg.SELECTORS], parser);
    parser.add_argument("--kind", {
      required: true,
      choices: ["txt", "server"]
    });
  });

  addSubParser(Command.TOOLS, parser => {
    addOptionalArgs([Arg.CONFIG], parser);
  });

  addSubParser(Command.CHECK, parser => {
    parser.add_argument("--schema", {
      required: true,
      choices: ["BCVE", "Log", "Export", "Config"]
    });
    parser.add_argument("files", { nargs: "+" });
  });

  addSubParser(Command.LIST, parser => {
    addOptionalArgs([Arg.CONFIG, Arg.BCVES, Arg.SOURCES], parser);
    addArgs([Arg.SELECTORS], parser);
    parser.add_argument("--full", {
      required: false,
      action: "store_true"
    });
  });

  addSubParser(Command.FILTER, parser => {
    addOptionalArgs([Arg.CONFIG, Arg.BCVES], parser);
    addArgs([Arg.SELECTORS], parser);
    parser.add_argument("-v", "--invert-match", {
      required: false,
      action: "store_true"
    });
  });

  return rootParser;
}
