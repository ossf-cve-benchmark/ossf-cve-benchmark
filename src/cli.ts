import {
  BCVE,
  Config,
  Dir,
  Export,
  File,
  Format,
  ToolID,
  StandaloneRun,
  CVEState,
  CVEString
} from "./types";

import {
  readConfigFile,
  readExportFile,
  readLogFile,
  writeExportFile,
  writeJSONFile
} from "./util";
import * as reports from "./reports";
import ExploreServer from "./explore-server";
import * as cp from "child_process";
import * as fs from "fs";
import * as I from "immutable";
import * as os from "os";
import * as path from "path";
import * as readline from "readline";
import parser from "./CommandlineParser";
import * as download from "./download";
import * as refs from "./refs";
import * as validation from "./validation";
import * as upload from "./upload";
function getToolsSrcRoot() {
  return path.resolve(path.join(getProjectRoot(), "contrib", "tools"));
}
function getProjectRoot() {
  return path.resolve(path.join(__dirname, "..", ".."));
}
function getDefaultConfig(root: Dir): Config {
  return {
    bcvesDir: path.resolve(path.join(root, "CVEs")),
    sourcesDir: path.resolve(path.join(root, "work", "sources")),
    resultsDir: path.resolve(path.join(root, "work", "results")),
    reportsDir: path.resolve(path.join(root, "work", "reports")),
    exportFile: path.resolve(path.join(root, "work", "export", "export.json")),
    reportFormat: Format.txt,
    tools: {},
    viewerRepo: undefined
  };
}

function getConfig(args: RawArguments): Config {
  let implicitConfigFile = "config.json";
  let configFile =
      args.config || fs.existsSync(implicitConfigFile)
        ? implicitConfigFile
        : undefined,
    defaultConfig = getDefaultConfig(
      configFile ? path.dirname(configFile) : "."
    ),
    providedConfig: Config = configFile
      ? readConfigFile(configFile as string)
      : undefined,
    baseConfig: Config = { ...defaultConfig, ...providedConfig },
    fullConfig: Config = {
      bcvesDir: (args.bcves_dir as Dir) || baseConfig.bcvesDir,
      sourcesDir: (args.sources_dir as Dir) || baseConfig.sourcesDir,
      resultsDir: (args.results_dir as Dir) || baseConfig.resultsDir,
      reportsDir: (args.report_dir as Dir) || baseConfig.reportsDir,
      exportFile: (args.export_file as File) || baseConfig.exportFile,
      reportFormat:
        Format[args.report_format as keyof typeof Format] ||
        baseConfig.reportFormat,
      tools: baseConfig.tools,
      viewerRepo: (args.viewer_repo as string) || baseConfig.viewerRepo
    };
  Object.entries(fullConfig).forEach(([k, v]) => {
    if (!v) {
      if (k === "viewerRepo") {
        return;
      }
      throw new Error(`Invalid config value for ${k}: ${v}`);
    }
  });
  return fullConfig;
}
async function buildExportObject(
  config: Config,
  args: {
    refs: string[];
    tool_id: ToolID[];
    no_sources: boolean;
    allow_incomplete: boolean;
    anonymize: boolean;
  }
) {
  // process arguments
  let bcves = await resolveCommandlineRefs(
    config.bcvesDir,
    args.no_sources ? undefined : config.sourcesDir,
    args.refs
  );
  if (bcves.length === 0) {
    throw new Error(
      `Nothing to export: ${JSON.stringify(args)} resolves to 0 BCVEs`
    );
  }

  if (!args.allow_incomplete) {
    bcves = bcves
      .filter(
        bcve =>
          // `state` is `ACCEPTED`
          bcve.state === undefined || bcve.state === CVEState.ACCEPTED
      )
      .filter(
        bcve =>
          // `patchBase` exists and contains at least one relevant weakness
          bcve.patchBase &&
          bcve.patchBase.weaknesses &&
          bcve.patchBase.weaknesses.length > 0
      )
      .filter(
        bcve =>
          // `postPatch` exists and contains zero relevant weaknesses
          bcve.postPatch &&
          (bcve.postPatch.weaknesses === undefined ||
            bcve.postPatch.weaknesses.length === 0)
      );

    if (bcves.length === 0) {
      throw new Error(
        `Nothing to export: ${JSON.stringify(
          args
        )} resolves to 0 complete BCVEs`
      );
    }
  }

  let toolIDsFromArgs = args.tool_id ? I.Set(args.tool_id) : I.Set(),
    runsFromArgs: StandaloneRun[] = toolIDsFromArgs.isEmpty()
      ? /* optimization: skip reading logs, also prevents invalid and irrelevant log files from blocking other tasks*/ []
      : fs
          .readdirSync(config.resultsDir)
          .map(f => path.join(config.resultsDir, f))
          .map(f => {
            try {
              return readLogFile(f);
            } catch (e) {
              console.error(`Ignoring invalid log file ${f}`);
            }
          })
          .filter(l => !!l)
          .flatMap(l => l.runs);

  // relate arguments
  let bcvesByCVE = I.Set(bcves)
      .groupBy(bcve => bcve.CVE)
      .map(bcves => bcves.first<BCVE>()),
    cvesInBCVEs = bcvesByCVE.keySeq().toSet(),
    runs = runsFromArgs.filter(r => cvesInBCVEs.has(r.CVE)),
    toolIDsInRuns = I.Set(runs).map(r => r.toolID),
    toolIDs = toolIDsFromArgs.intersect(toolIDsInRuns);

  let missingToolIDs = I.Set(toolIDsFromArgs).subtract(toolIDs);
  if (!missingToolIDs.isEmpty()) {
    let missingString = JSON.stringify(missingToolIDs.sort().toArray()),
      availableString = JSON.stringify(toolIDsInRuns.sort().toArray());
    if (runs.length === 0) {
      throw new Error(
        `No runs to export for: ${missingToolIDs}. None of the ${runsFromArgs.length} runs matched the CVE filter.`
      );
    }
    throw new Error(
      `No runs to export for: ${missingString}. Can export for: ${availableString}.`
    );
  }
  let anonymousToolIDs = new Map();
  let anonymousRuleIDs = new Map();
  function anonymize(run: StandaloneRun) {
    if (!anonymousToolIDs.has(run.toolID)) {
      anonymousToolIDs.set(run.toolID, `tool-${anonymousToolIDs.size}`);
    }
    run.toolID = anonymousToolIDs.get(run.toolID);
    (run.alerts || []).forEach(a => {
      if (!anonymousRuleIDs.has(a.ruleID)) {
        anonymousRuleIDs.set(a.ruleID, `rule-${anonymousRuleIDs.size}`);
      }
      a.ruleID = anonymousRuleIDs.get(a.ruleID);
      a.url = undefined;
    });
  }
  // populate bcve with runs
  runs
    .filter(run => toolIDs.has(run.toolID))
    .forEach(standaloneRun => {
      let { CVE, commit, ...linkedRun } = standaloneRun;
      if (args.anonymize) {
        anonymize(linkedRun as StandaloneRun);
      }
      let bcve = bcvesByCVE.get(CVE);

      switch (commit) {
        case bcve.patchBase.commit:
          bcve.patchBase.runs = bcve.patchBase.runs || [];
          bcve.patchBase.runs.push(linkedRun);
          break;
        case bcve.postPatch.commit:
          bcve.postPatch.runs = bcve.postPatch.runs || [];
          bcve.postPatch.runs.push(linkedRun);
          break;
        default:
          console.error(
            `Ignoring the run from ${standaloneRun.toolID} for commit ${
              standaloneRun.commit
            }, since ${CVE} (${JSON.stringify([
              bcve.patchBase.commit,
              bcve.postPatch.commit
            ])}) do not contain that commit.`
          );
      }
    });
  return bcves;
}
const commands: { [option: string]: ArgumentsHandler } = {
  "download-commits": async (
    config: Config,
    args: { anonymous: boolean; refs: string[] }
  ) => {
    (
      await resolveCommandlineRefs(
        config.bcvesDir,
        config.sourcesDir,
        args.refs
      )
    ).forEach(bcve => download.download(bcve, args.anonymous));
  },
  run: async (config: Config, args: { refs: string[]; tool_id: ToolID }) => {
    let bcves = await resolveCommandlineRefs(
        config.bcvesDir,
        config.sourcesDir,
        args.refs
      ),
      tmp = fs.mkdtempSync(path.join(os.tmpdir(), "bcves-run-")),
      targetsFile = path.join(tmp, "targets.json"),
      toolID = args.tool_id;
    let tool = config.tools[toolID];
    if (!tool) {
      console.error(
        `No config entry for tool at config.tools["${args.tool_id}"].

Aavailable tools: ${JSON.stringify(Object.keys(config.tools))} }.

Register additional tools by adding them to the tools section of the configuration file.
See ${path.resolve(__dirname, "../../contrib/tools/README.md")} for details.`
      );
      process.exit(1);
    }
    writeJSONFile(targetsFile, bcves);
    fs.mkdirSync(config.resultsDir, { recursive: true });
    let toolArgs = [...tool.args, toolID, targetsFile, config.resultsDir];
    console.log(
      `Spawning child-process: '${tool.bin},  ${toolArgs.join(" ")}'`
    );
    return new Promise((resolve, reject) => {
      let isDone = false;
      function finish(e?: any) {
        if (isDone) {
          return;
        }
        console.log(
          `Spawned child-process finished${
            e ? `with error: ${JSON.stringify(e)}` : ""
          }`
        );
        isDone = true;
        if (e) {
          reject(e);
        } else {
          resolve();
        }
      }

      try {
        let child = cp.spawn(tool.bin, toolArgs);
        child.stdout.setEncoding("utf8");
        child.stderr.setEncoding("utf8");

        child.stdout.pipe(process.stdout, { end: false });
        child.stderr.pipe(process.stderr, { end: false });

        child.on("error", function(e) {
          finish(e);
        });
        child.on("exit", function() {
          finish();
        });
      } catch (e) {
        finish(e);
      }
    });
  },
  report: async (config: Config, _args: {}) => {
    let bcves: Export = readExportFile(config.exportFile);

    await reports.reportMaker(
      bcves,
      config.reportsDir,
      config.reportFormat as Format
    );
  },
  export: async (
    config: Config,
    args: {
      refs: string[];
      tool_id: ToolID[];
      no_export_file: boolean;
      no_sources: boolean;
      allow_incomplete: boolean;
      anonymize: boolean;
    }
  ) => {
    let bcves = await buildExportObject(config, args);
    if (args.no_export_file) {
      console.log(JSON.stringify(bcves));
    } else {
      fs.mkdirSync(path.dirname(config.exportFile), { recursive: true });
      writeExportFile(config.exportFile, bcves);
    }
  },
  explore: async (
    config: Config,
    args: {
      refs: string[];
      tool_id: ToolID[];
      no_sources: boolean;
      allow_incomplete: boolean;
      port: number;
      anonymize: boolean;
    }
  ) => {
    let bcves = await buildExportObject(config, args);
    await new ExploreServer(bcves, args.port).start();
  },
  "upload-commits": async (
    config: Config,
    args: { refs: string[]; repository_root: string }
  ) => {
    (
      await resolveCommandlineRefs(
        config.bcvesDir,
        config.sourcesDir,
        args.refs
      )
    ).forEach(bcve => upload.upload(bcve, args.repository_root));
  },
  tools: async (config: Config, _args: {}) => {
    let toolsRoot = getToolsSrcRoot();
    let configured = Object.keys(config.tools),
      available = fs
        .readdirSync(toolsRoot)
        .map(f => path.join(toolsRoot, f))
        .filter(d => fs.lstatSync(d).isDirectory())
        .sort(),
      installer = available.filter(d => {
        let bin = path.join(d, "bin");

        return (
          fs.existsSync(bin) &&
          fs.readdirSync(bin).some(f => f.match(/^install\.(sh|cmd)$/))
        );
      });
    console.log(
      [
        "Configured:",
        ...configured.map(t => `- ${t}`),
        "",
        "Available, with installer:",
        ...installer
          .map(f => path.relative(getProjectRoot(), f))
          .map(t => `- ${t}`),
        "",
        "Available:",
        ...available
          .map(f => path.relative(getProjectRoot(), f))
          .map(t => `- ${t}`)
      ].join("\n")
    );
  },

  check: async (
    _config: Config,
    args: { schema: "BCVE" | "Log" | "Export"; files: string[] }
  ) => {
    let validator = validation.makeValidator(),
      schemaName =
        validation.SchemaName[
          args.schema as keyof typeof validation.SchemaName
        ];
    if (!schemaName) {
      throw new Error(
        `${args.schema} is not in ${Object.keys(validation.SchemaName)}`
      );
    }
    let schemaID = validation.getSchemaID(schemaName),
      errors: string[] = args.files
        .map(file => {
          if (!fs.existsSync(file)) {
            return { file, error: `File does not exist` };
          }

          try {
            let data: any = JSON.parse(fs.readFileSync(file, "utf8"));
            return { file, data };
          } catch (e) {
            return { file, error: `Is not valid JSON: '${e.message}'` };
          }
        })
        .flatMap(({ file, data, error }) => {
          if (error) {
            return [{ file, error }];
          }
          let valid = validator.validate(schemaID, data);
          if (!valid) {
            return [
              {
                file,
                error: `Is not valid a valid ${
                  args.schema
                }-file: ${validator.errorsText()}`
              }
            ];
          }
          return [];
        })
        .map(({ file, error }) => `${file}: ${error}`)
        .sort();

    if (errors.length > 0) {
      console.error(
        `Validation failed:\n${errors.map(e => `  - ${e}`).join("\n")}`
      );
    }
  },
  list: async function(
    config: Config,
    args: { refs: string[]; full: boolean }
  ) {
    let resolved = await resolveCommandlineRefs(
      config.bcvesDir,
      config.sourcesDir,
      args.refs
    );
    resolved
      .map(bcve => (args.full ? JSON.stringify(bcve, null, 4) : bcve.CVE))
      .forEach(l => console.log(l));
  },
  filter: async function(
    config: Config,
    args: { refs: string[]; invert_match: boolean }
  ) {
    function toCVEs(refStrings: string[]): I.Set<CVEString> {
      return I.Set(
        refs
          .resolve(
            refStrings.map(refs.parse),
            config.bcvesDir,
            config.sourcesDir
          )
          .map(bcve => bcve.CVE)
      );
    }
    let stdInCVEs = toCVEs(
      (await readStdinLines()).filter(refs.filterRawInputLine)
    );
    let argCVEs = toCVEs(args.refs);
    let result = args.invert_match
      ? stdInCVEs.subtract(argCVEs)
      : stdInCVEs.intersect(argCVEs);
    result.forEach(l => console.log(l));
  }
};

interface RawArguments {
  [option: string]: string | string[] | boolean | number;
}

interface ArgumentsHandler {
  (config: Config, args: RawArguments): Promise<void>;
}

async function readStdinLines() {
  let rl = readline.createInterface({
    input: process.stdin,
    terminal: false
  });
  let lines = [];
  for await (let ref of rl) {
    lines.push(ref);
  }
  return lines;
}
async function resolveCommandlineRefs(
  bcvesDir: Dir,
  sourcesDir: Dir,
  refStrings: string[]
): Promise<BCVE[]> {
  if (refStrings.length === 1 && refStrings[0] === "-") {
    refStrings = (await readStdinLines()).filter(refs.filterRawInputLine);
  }
  return refs.resolve(refStrings.map(refs.parse), bcvesDir, sourcesDir);
}

function main() {
  let args: {
    [option: string]: string | string[] | boolean;
  } = parser.parse_args();
  let command = commands[args.command as string];
  if (!command) {
    parser.print_help();
    process.exit(1);
  }
  let config = getConfig(args);
  command(config, args)
    .then(() => process.exit(0))
    .catch(e => {
      console.error(`Error: Command '${args.command}' failed:`);
      console.error(e.message);
      console.error(e.stack);
      process.exit(1);
    });
}

main();
