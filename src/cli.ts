import * as cp from "child_process";
import * as fs from "fs";
import * as os from "os";
import * as path from "path";
import ExploreServer from "../contrib/reports/explore-server/src/server";
import * as reports from "../contrib/reports/flat-files/src";
import {
  buildFullExportObject,
  filterToCommandlineSelectors,
  getBCVEsWithRuns
} from "./bcves-from-cli";
import { mkCommandlineParser } from "./CommandlineParser";
import { getConfig, getToolsSrcRoot } from "./config";
import * as repositories from "./repositories";
import * as selectors from "./selectors";
import { Config, CVEString, ToolID } from "./types";
import {
  readBCVEFiles,
  readStdinLines,
  setDifference,
  setIntersection,
  writeDriverInputsFile,
  writeExportFile
} from "./util";
import * as validation from "./validation";

const commands: { [option: string]: ArgumentsHandler } = {
  "download-commits": async (
    config: Config,
    args: {
      anonymous: boolean;
      selectors: string[];
      allow_incomplete: boolean;
      non_fatal_validation_errors: boolean;
    }
  ) => {
    (
      await filterToCommandlineSelectors(
        readBCVEFiles(
          config.bcves,
          config.sources,
          args.allow_incomplete,
          !args.non_fatal_validation_errors
        ),
        args.selectors
      )
    ).forEach(bcve =>
      repositories.downloadCommitsForCVE(
        bcve,
        args.anonymous,
        config.canonicalRepositoriesRoot
      )
    );
  },
  run: async (
    config: Config,
    args: {
      selectors: string[];
      tool: ToolID[];
      allow_incomplete: boolean;
      non_fatal_validation_errors: boolean;
    }
  ) => {
    let docReference = `Register tools by adding them to the tools section of the configuration file.
See "docs/analysis-tools.md" for details.`;

    if (config.tools === undefined || Object.keys(config.tools).length === 0) {
      throw new Error(
        `No tools registered in the configuration file: can not run anything.

${docReference}`
      );
    }
    let bcves = await getBCVEsWithRuns(
      config,
      { ...args, anonymize: false },
      true
    );

    for (let toolID of args.tool) {
      if (!config.tools[toolID]) {
        throw new Error(
          `No config entry for tool at config.tools["${toolID}"].

Available tools: ${JSON.stringify(Object.keys(config.tools))} }.

${docReference}`
        );
      }
    }

    for await (let toolID of args.tool) {
      let tool = config.tools[toolID],
        tmp = fs.mkdtempSync(path.join(os.tmpdir(), "bcves-run-")),
        driverInputs = path.join(tmp, "driver-inputs.json");

      writeDriverInputsFile(
        driverInputs,
        {
          bcves,
          config,
          toolID
        },
        !args.non_fatal_validation_errors
      );
      let toolArgs = [...tool.args, driverInputs];
      console.log(
        `Spawning child-process: '${tool.bin} ${toolArgs.join(" ")}'`
      );
      fs.mkdirSync(config.results, { recursive: true });
      await new Promise<void>((resolve, reject) => {
        let isDone = false;
        function finish(e?: any) {
          if (isDone) {
            return;
          }
          console.log(
            `Spawned child-process finished${
              e ? `with error: ${JSON.stringify(e)}` : ""
            }`
          );
          isDone = true;
          if (e) {
            reject(e);
          } else {
            resolve();
          }
        }

        try {
          let child = cp.spawn(tool.bin, toolArgs);
          child.stdout.setEncoding("utf8");
          child.stderr.setEncoding("utf8");

          child.stdout.pipe(process.stdout, { end: false });
          child.stderr.pipe(process.stderr, { end: false });

          child.on("error", function (e) {
            finish(e);
          });
          child.on("exit", function () {
            finish();
          });
        } catch (e) {
          finish(e);
        }
      });
    }
  },
  export: async (
    config: Config,
    args: {
      selectors: string[];
      tool: ToolID[];
      no_export_file: boolean;
      no_sources: boolean;
      allow_incomplete: boolean;
      anonymize: boolean;
      non_fatal_validation_errors: boolean;
    }
  ) => {
    let bcves = await buildFullExportObject(config, args, false);
    if (args.no_export_file) {
      console.log(JSON.stringify(bcves));
    } else {
      fs.mkdirSync(path.dirname(config.export), { recursive: true });
      writeExportFile(config.export, bcves, !args.non_fatal_validation_errors);
    }
  },
  report: async (
    config: Config,
    args: {
      import?: string;
      selectors: string[];
      tool: ToolID[];
      no_sources: boolean;
      allow_incomplete: boolean;
      port: number;
      anonymize: boolean;
      kind: string;
      non_fatal_validation_errors: boolean;
    }
  ) => {
    let bcves = await getBCVEsWithRuns(config, args, false);
    switch (args.kind) {
      case "txt": {
        return await reports.reportMaker(
          bcves,
          config.reports,
          reports.Format.txt
        );
      }
      case "server": {
        return await new ExploreServer(bcves, 8080).start();
      }
      default:
        throw new Error(`Unhandled report kind: ${args.kind}`);
    }
  },
  "upload-commits": async (
    config: Config,
    args: {
      selectors: string[];
      allow_incomplete: boolean;
      auth_token: string;
      non_fatal_validation_errors: boolean;
    }
  ) => {
    await Promise.all(
      (
        await filterToCommandlineSelectors(
          readBCVEFiles(
            config.bcves,
            config.sources,
            args.allow_incomplete,
            !args.non_fatal_validation_errors
          ),
          args.selectors
        )
      ).map(async bcve =>
        repositories.uploadCVECommitsToCanonicalRepository(
          bcve,
          config.canonicalRepositoriesRoot,
          args.auth_token
        )
      )
    );
  },
  tools: async (config: Config) => {
    let toolsRoot = getToolsSrcRoot();
    let configured = Object.keys(config.tools),
      readmes = fs
        .readdirSync(toolsRoot)
        .map(f => path.join(toolsRoot, f, "README.md"))
        .filter(f => fs.existsSync(f)),
      installers = fs
        .readdirSync(toolsRoot)
        .map(f => path.join(toolsRoot, f, "installers"))
        .filter(d => fs.existsSync(d) && fs.lstatSync(d).isDirectory())
        .flatMap(d => fs.readdirSync(d).map(f => path.join(d, f)))
        .filter(f => {
          try {
            fs.accessSync(f, fs.constants.X_OK);
            return true;
          } catch (e) {
            return false;
          }
        });
    console.log(
      [
        `Configured tools in ${path.resolve(config.config)}:`,
        ...configured.map(t => `- ${t}`),
        "",
        "Available driver installers:",
        ...installers
          .map(f => path.relative(".", f))
          .sort()
          .map(t => `- ${t}`),
        "",
        "Available driver READMEs:",
        ...readmes
          .map(f => path.relative(".", f))
          .sort()
          .map(t => `- ${t}`)
      ].join("\n")
    );
  },

  validate: async (
    _config: Config,
    args: { schema: "BCVE" | "Log" | "Export"; files: string[] }
  ) => {
    let validator = validation.makeValidator(),
      schemaName =
        validation.SchemaName[
          args.schema as keyof typeof validation.SchemaName
        ];
    if (!schemaName) {
      throw new Error(
        `${args.schema} is not in ${JSON.stringify(
          Object.keys(validation.SchemaName)
        )}`
      );
    }
    let filesToValidate = args.files.flatMap(f =>
      fs.lstatSync(f).isDirectory()
        ? fs.readdirSync(f).map(c => path.resolve(f, c))
        : [f]
    );
    let schemaID = validation.getSchemaID(schemaName),
      errors: string[] = filesToValidate
        .map(file => {
          if (!fs.existsSync(file)) {
            return { file, error: `File does not exist` };
          }

          try {
            let data: any = JSON.parse(fs.readFileSync(file, "utf8"));
            return { file, data };
          } catch (e) {
            return {
              file,
              error: `Is not valid JSON: '${(e as Error).message}'`
            };
          }
        })
        .flatMap(({ file, data, error }) => {
          if (error) {
            return [{ file, error }];
          }
          let valid = validator.validate(schemaID, data);
          if (!valid) {
            return [
              {
                file,
                error: `Is not valid a valid ${
                  args.schema
                }-file: ${validator.errorsText()}`
              }
            ];
          }
          return [];
        })
        .map(({ file, error }) => `${file}: ${error}`)
        .sort();

    if (errors.length > 0) {
      console.error(
        `Validation failed:\n${errors.map(e => `  - ${e}`).join("\n")}`
      );
    } else {
      console.log(`Validation succeeded for ${filesToValidate.length} files`);
    }
  },
  list: async function (
    config: Config,
    args: {
      selectors: string[];
      full: boolean;
      allow_incomplete: boolean;
      non_fatal_validation_errors: boolean;
    }
  ) {
    let resolved = await filterToCommandlineSelectors(
      readBCVEFiles(
        config.bcves,
        config.sources,
        args.allow_incomplete,
        !args.non_fatal_validation_errors
      ),
      args.selectors
    );
    resolved
      .map(bcve => (args.full ? JSON.stringify(bcve, null, 4) : bcve.CVE))
      .forEach(l => console.log(l));
  },
  filter: async function (
    config: Config,
    args: {
      selectors: string[];
      invert_match: boolean;
      allow_incomplete: boolean;
      non_fatal_validation_errors: boolean;
    }
  ) {
    function toCVEs(selectorstrings: string[]): Set<CVEString> {
      return new Set(
        selectors
          .filter(
            selectorstrings.map(selectors.parse),
            readBCVEFiles(
              config.bcves,
              config.sources,
              args.allow_incomplete,
              !args.non_fatal_validation_errors
            )
          )
          .map(bcve => bcve.CVE)
      );
    }
    let stdInCVEs = toCVEs(
      (await readStdinLines()).filter(selectors.filterRawInputLine)
    );
    let argCVEs = toCVEs(args.selectors);
    let result = args.invert_match
      ? setDifference(stdInCVEs, argCVEs)
      : setIntersection(stdInCVEs, argCVEs);
    result.forEach(l => console.log(l));
  }
};

interface RawArguments {
  [option: string]: string | string[] | boolean | number;
}

interface ArgumentsHandler {
  (config: Config, args: RawArguments): Promise<void>;
}

function main() {
  let parser = mkCommandlineParser(false);
  let args: {
    [option: string]: string | string[] | boolean;
    command: string;
  } = parser.parse_args();
  let { command, ...options } = args;

  let commandFunction = commands[command];
  if (!commandFunction) {
    parser.print_help();
    process.exit(1);
  }
  let config = getConfig(options);
  commandFunction(config, args)
    .then(() => process.exit(0))
    .catch((e: Error) => {
      console.error(`Error: Command '${args.command}' failed:`);
      console.error(e.message);
      console.error(e.stack);
      process.exit(1);
    });
}

main();
