// TODO structure this project properly so this module can use type-imports (at least)
type CommitData = {
  CVE: string;
  kind: string;
  commit: string;
};
type FileData = {
  file: string;
};
type AnnotationData = {
  line: number;
  kind: string;
  msg: string;
};
type AnnotationCounts = {
  [toolID: string]: number;
};
function mkSimpleURL(path: string, params: { [k: string]: string }): string {
  let paramsString = Object.entries(params)
    .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    .join("&");
  return `${path}?${paramsString}`;
}
function mkTable(data: (string | Element)[][]): Element {
  let table = document.createElement("table");
  table.setAttribute("class", "mkTable");
  let thead = table.appendChild(document.createElement("thead"));
  let tbody = table.appendChild(document.createElement("tbody"));
  let head = true;
  for (let rowData of data) {
    let subtable = head ? thead : tbody;
    head = false;
    let row = subtable.appendChild(document.createElement("tr"));
    for (let cellData of rowData) {
      row
        .appendChild(document.createElement("td"))
        .appendChild(
          cellData instanceof Element
            ? cellData
            : document.createTextNode(cellData)
        );
    }
  }

  return table;
}

async function makeCVEsArea() {
  let commits: CommitData[] = await (await fetch("/data/getCommits")).json();
  let toolIDs: string[] = [];
  let annotationCountsMap: Map<CommitData, AnnotationCounts> = new Map();
  for await (let c of commits) {
    let annotationCounts: AnnotationCounts = await (
      await fetch(
        mkSimpleURL("/data/getCVEAnnotationCounts", {
          CVE: c.CVE,
          commit: c.commit
        })
      )
    ).json();
    annotationCountsMap.set(c, annotationCounts);
  }
  for await (let c of commits) {
    Object.keys(annotationCountsMap.get(c)).forEach(k => toolIDs.push(k));
  }
  toolIDs = Array.from(new Set(toolIDs)).sort();

  let table: (string | Element)[][] = [["CVE", "kind", "commit", ...toolIDs]];

  for (let c of commits) {
    let link = document.createElement("a");
    link.setAttribute(
      "href",
      mkSimpleURL("", {
        CVE: c.CVE,
        commit: c.commit
      })
    );
    link.appendChild(document.createTextNode(c.commit));

    table.push([
      c.CVE,
      c.kind,
      link,
      ...toolIDs.map(t => "" + (annotationCountsMap.get(c)[t] || ""))
    ]);
  }
  return mkTable(table);
}

async function makeCommitArea(cve: string, commit: string) {
  let toolIDs: string[] = [];
  let annotationCountsMap: Map<FileData, AnnotationCounts> = new Map();
  let files: FileData[] = await (
    await fetch(
      mkSimpleURL("/data/getFiles", {
        CVE: cve,
        commit: commit
      })
    )
  ).json();
  for await (let f of files) {
    let annotationCounts: AnnotationCounts = await (
      await fetch(
        mkSimpleURL("/data/getFileAnnotationCounts", {
          CVE: cve,
          commit: commit,
          file: f.file
        })
      )
    ).json();
    annotationCountsMap.set(f, annotationCounts);
  }
  for await (let f of files) {
    Object.keys(annotationCountsMap.get(f)).forEach(k => toolIDs.push(k));
  }
  toolIDs = Array.from(new Set(toolIDs)).sort();

  let table: (string | Element)[][] = [["File", ...toolIDs]];

  for (let f of files) {
    let link = document.createElement("a");
    link.setAttribute(
      "href",
      mkSimpleURL("", {
        CVE: cve,
        commit: commit,
        file: f.file
      })
    );
    link.appendChild(document.createTextNode(f.file));

    table.push([
      link,
      ...toolIDs.map(t => "" + (annotationCountsMap.get(f)[t] || ""))
    ]);
  }
  let codeMirrorElement = document.createElement("div");
  let bcve: any = await (
    await fetch(
      mkSimpleURL("/data/getCVE", {
        CVE: cve
      })
    )
  ).json();
  delete bcve?.patchBase?.runs;
  delete bcve?.patchBase?.localSourceDirectory;
  delete bcve?.postPatch?.runs;
  delete bcve?.postPatch?.localSourceDirectory;
  let editor = CodeMirror(codeMirrorElement, {
    value: JSON.stringify(bcve, null, 4),
    lineNumbers: true,
    readOnly: true,
    mode: { name: "javascript", json: "true" }
  });
  let content = document.createElement("div");
  content.appendChild(document.createTextNode(`${cve} ${commit}`));
  content.appendChild(codeMirrorElement);
  content.appendChild(mkTable(table));
  setTimeout(function() {
    editor.refresh();
  }, 1);

  return content;
}

async function makeCodeArea(
  parent: Element,
  cve: string,
  commit: string,
  file: string
) {
  let annotations: AnnotationData[] = await (
    await fetch(
      mkSimpleURL("/data/getAnnotations", {
        CVE: cve,
        commit: commit,
        file: file
      })
    )
  ).json();
  annotations.sort((a1, a2) => {
    let cmp = a1.line - a2.line;
    if (cmp !== 0) {
      return cmp;
    }
    return a1.msg.localeCompare(a2.msg);
  });

  let codeMirrorElement = document.createElement("div");
  let source: string =
    (await (
      await fetch(
        mkSimpleURL("/sources", {
          CVE: cve,
          commit: commit,
          file: file
        })
      )
    ).text()) || "SOURCE CODE NOT FOUND";

  // TODO improve language inference
  let mode, name;
  if (file.match(/.*\.jsx?$/)) {
    name = "javascript";
    mode = "typescript";
  }
  if (file.match(/.*\.tsx?$/)) {
    name = "javascript";
    mode = "typescript";
  }
  if (file.match(/.*\.json$/)) {
    name = "javascript";
    mode = "json";
  }
  let editor = CodeMirror(codeMirrorElement, {
    value: source,
    lineNumbers: true,
    readOnly: true,
    mode: { name, mode }
  });
  function focusLine(line: number) {
    let pos = { ch: 0, line: line - 1 };
    editor.focus();
    editor.scrollIntoView(pos, 400);
  }
  let table = [
    ["Line", "Message"],
    ...annotations.map(a => {
      let link = document.createElement("a");
      link.setAttribute("href", `#L${a.line}`);
      link.addEventListener("click", () => focusLine(a.line));
      link.appendChild(document.createTextNode(a.msg));
      return ["" + a.line, link];
    })
  ];

  let content = parent.appendChild(document.createElement("div"));
  content.appendChild(document.createTextNode(`${file} (${cve} ${commit})`));
  content.appendChild(mkTable(table));
  content.appendChild(codeMirrorElement);
  for (let a of annotations) {
    let annotation = document.createElement("div");
    let icon = document.createElement("span");
    annotation.className = "line-annotation";
    icon.appendChild(document.createTextNode("!!"));
    annotation.appendChild(icon);
    annotation.appendChild(document.createTextNode(a.msg));
    icon.className = "line-annotation-icon";
    editor.addLineWidget(a.line - 1, annotation, { coverGutter: false });
  }
  editor.setSize("90%", "90%");
  setTimeout(function() {
    editor.refresh();
  }, 1);
  let hashLine = window.location.hash.match(/#L(\d+)/);
  if (hashLine) {
    focusLine(+hashLine[1]);
  }
  return content;
}

(async function() {
  const urlParams = new URLSearchParams(window.location.search);

  let cve = urlParams.get("CVE"),
    commit = urlParams.get("commit"),
    file = urlParams.get("file");
  let content: Element = document.getElementById("content");
  if (cve && commit && file) {
    await makeCodeArea(content, cve, commit, file);
  } else if (cve && commit) {
    content.appendChild(await makeCommitArea(cve, commit));
  } else {
    content.appendChild(await makeCVEsArea());
  }
})();
