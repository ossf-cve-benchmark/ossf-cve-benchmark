/**
 * Various small utility functions.
 * NB: this file is scheduled to be broken up into more thematic units.
 */
import * as cp from "child_process";
import * as fs from "fs";
import path from "path";
import * as readline from "readline";
import * as sarif from "sarif";
import {
  BCVE,
  BCVEAlert,
  BCVELog,
  BCVERun,
  Config,
  CVEState,
  Dir,
  DriverInputs,
  Export,
  File
} from "./persistent-types";
import * as validation from "./validation";

/**
 * @returns the root directory of this project.
 */
export function getProjectRoot(): Dir {
  let root;
  if (__filename.endsWith("/util.ts")) {
    // happens during testing with jest
    root = path.resolve(path.join(__dirname, ".."));
  } else {
    root = path.resolve(path.join(__dirname, "..", "..", ".."));
  }
  if (!fs.existsSync(root)) {
    throw new Error(`Could the project directory does not exist?! (${root})`);
  }
  return root;
}

/**
 * @returns the tools/contrib directory of this project.
 */
export function getToolsRoot(): Dir {
  let root = path.resolve(path.join(getProjectRoot(), "contrib", "tools"));
  if (!fs.existsSync(root)) {
    throw new Error(
      `Could the contrib/tools directory does not exist?! (${root})`
    );
  }
  return root;
}

export function readJSONFile<T>(file: File): T {
  let content = fs.readFileSync(file, "utf8").trim();
  try {
    return JSON.parse(content) as T;
  } catch (e) {
    console.error(`Could not parse ${file} as a JSON file ('${content}')`);
    throw e;
  }
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function writeJSONFile(file: File, value: any): void {
  try {
    fs.writeFileSync(file, JSON.stringify(value), "utf8");
  } catch (e) {
    console.error(`Could not write ${file} as a JSON file.`);
    throw e;
  }
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function assert(v: any): void {
  if (!v) {
    throw new Error(`AssertionError: ${JSON.stringify(v)} is falsy`);
  }
}

export function writeExportFile(
  file: File,
  o: Export,
  validationErrorsAreFatal: boolean
): void {
  validateAndWrite(
    o,
    file,
    validation.SchemaName.Export,
    validationErrorsAreFatal
  );
}

export function readExportFile(
  file: File,
  validationErrorsAreFatal: boolean
): Export {
  return readAndValidate(
    file,
    validation.SchemaName.Export,
    validationErrorsAreFatal
  );
}

export function writeDriverInputsFile(
  file: File,
  o: DriverInputs,
  validationErrorsAreFatal: boolean
): void {
  validateAndWrite(
    o,
    file,
    validation.SchemaName.DriverInputs,
    validationErrorsAreFatal
  );
}

export function readDriverInputsFile(
  file: File,
  validationErrorsAreFatal: boolean
): DriverInputs {
  return readAndValidate(
    file,
    validation.SchemaName.DriverInputs,
    validationErrorsAreFatal
  );
}

export function isComplete(bcve: BCVE) {
  // `state` is `ACCEPTED`
  return (
    (bcve.state === undefined || bcve.state === CVEState.PUBLISHED) &&
    // `prePatch` exists and contains at least one relevant weakness
    bcve.prePatch &&
    bcve.prePatch.weaknesses &&
    bcve.prePatch.weaknesses.length > 0 &&
    // `postPatch` exists and contains zero relevant weaknesses
    bcve.postPatch &&
    (bcve.postPatch.weaknesses === undefined ||
      bcve.postPatch.weaknesses.length === 0)
  );
}

export function readBCVEFiles(
  dir: Dir,
  sourcesDir: Dir,
  allowIncomplete: boolean,
  validationErrorsAreFatal: boolean
): BCVE[] {
  function pad(str: string, max: number): string {
    return str.length < max ? pad("0" + str, max) : str;
  }

  let bcves = fs
    .readdirSync(dir)
    .map(
      (f: File): BCVE =>
        readBCVEFile(path.join(dir, f), validationErrorsAreFatal)
    )
    .filter(bcve => (allowIncomplete ? true : isComplete(bcve)));

  // enchance data slightly
  bcves.forEach(bcve => {
    if (sourcesDir) {
      if (bcve.prePatch?.commit) {
        bcve.prePatch.localSourceDirectory = path.join(
          sourcesDir,
          bcve.CVE,
          bcve.prePatch.commit
        );
        assert(bcve.prePatch.localSourceDirectory.startsWith(sourcesDir));
      }
      if (bcve.postPatch?.commit) {
        bcve.postPatch.localSourceDirectory = path.join(
          sourcesDir,
          bcve.CVE,
          bcve.postPatch.commit
        );
        assert(bcve.postPatch.localSourceDirectory.startsWith(sourcesDir));
      }
    }
    // normalize CWEs to be of the form (CWE-\d\d\d\d)
    bcve.CWEs = bcve.CWEs.map(cwe => {
      let match = cwe.match(/(CWE-)(\d+)/);
      if (match) {
        return match[1] + pad((+match[2]).toString(), 4);
      }
    });
    return bcve;
  });

  return bcves;
}

export function anonymizeBCVEs(bcves: BCVE[]): void {
  let anonymousToolIDs = new Map();
  let anonymousRuleIDs = new Map();
  function anonymize(run: BCVERun) {
    if (!anonymousToolIDs.has(run.toolID)) {
      anonymousToolIDs.set(run.toolID, `tool-${anonymousToolIDs.size}`);
    }
    run.toolID = anonymousToolIDs.get(run.toolID);
    (run.alerts || []).forEach(a => {
      if (!anonymousRuleIDs.has(a.ruleID)) {
        anonymousRuleIDs.set(a.ruleID, `rule-${anonymousRuleIDs.size}`);
      }
      a.ruleID = anonymousRuleIDs.get(a.ruleID);
      a.url = undefined;
    });
  }
  bcves.forEach(bcve =>
    [bcve.postPatch, bcve.prePatch].forEach(c =>
      (c.runs || []).forEach(r => anonymize(r))
    )
  );
}
export function readBCVEFile(
  file: File,
  validationErrorsAreFatal: boolean
): BCVE {
  return readAndValidate(
    file,
    validation.SchemaName.BCVE,
    validationErrorsAreFatal
  );
}

export function writeLogFile(
  file: File,
  o: BCVELog,
  validationErrorsAreFatal: boolean
): void {
  validateAndWrite(
    o,
    file,
    validation.SchemaName.Log,
    validationErrorsAreFatal
  );
}

export function readLogFile(
  file: File,
  validationErrorsAreFatal: boolean
): BCVELog {
  return readAndValidate(
    file,
    validation.SchemaName.Log,
    validationErrorsAreFatal
  );
}

function readAndValidate<T>(
  file: File,
  schemaName: validation.SchemaName,
  validationErrorsAreFatal: boolean
): T {
  let o: T = readJSONFile(file);
  validation.validateSingle(o, schemaName, validationErrorsAreFatal, file);
  return o;
}

function validateAndWrite<T>(
  o: T,
  file: File,
  schemaName: validation.SchemaName,
  validationErrorsAreFatal: boolean
): void {
  try {
    validation.validateSingle(o, schemaName, validationErrorsAreFatal);
    writeJSONFile(file, o);
  } catch (e) {
    throw new Error(
      `Could not validate and write ${file} as ${schemaName}: ${
        (e as Error).message
      }: ${JSON.stringify(o, null, 2)}`
    );
  }
}

export async function readStdinLines(): Promise<string[]> {
  let rl = readline.createInterface({
    input: process.stdin,
    terminal: false
  });
  let lines = [];
  for await (let ref of rl) {
    lines.push(ref);
  }
  return lines;
}

export function setDifference<T>(a: Set<T>, b: Set<T>): Set<T> {
  return new Set([...a].filter(x => !b.has(x)));
}
export function setIntersection<T>(a: Set<T>, b: Set<T>): Set<T> {
  return new Set([...a].filter(x => b.has(x)));
}

/**
 * Runs `bin` with `args` in a child process.
 *
 * @return a promise that resolves/rejects when the child process terminates.
 */
export function spawnChildProcess(
  bin: File,
  args: string[],
  piping: boolean,
  showLog: boolean
): Promise<void> {
  if (showLog) {
    console.log(`Spawning child process: '${bin} ${args.join(" ")}'`);
  }
  return new Promise<void>((resolve, reject) => {
    let isDone = false;
    function finish(e?: any) {
      if (isDone) {
        return;
      }
      if (showLog) {
        console.log(
          `Spawned child process finished${
            e ? `with error: ${JSON.stringify(e)}` : ""
          }`
        );
      }
      isDone = true;
      if (e) {
        reject(e);
      } else {
        resolve();
      }
    }

    try {
      let child = cp.spawn(bin, args);
      if (piping) {
        child.stdout.setEncoding("utf8");
        child.stderr.setEncoding("utf8");
        child.stdout.pipe(process.stdout, { end: false });
        child.stderr.pipe(process.stderr, { end: false });
      } else {
        let showOutputs = false;
        // need to attach these listeners to avoid (occasional) subprocess failures
        child.stdout.on("data", function (data: { toString: () => string }) {
          if (showOutputs) {
            console.log(`stdout: ${data.toString()}`);
          }
        });
        child.stderr.on("data", function (data: { toString: () => string }) {
          if (showOutputs) {
            console.log(`stderr: ${data.toString()}`);
          }
        });
      }
      child.on("error", function (e) {
        finish(e);
      });
      child.on("exit", function () {
        finish();
      });
    } catch (e) {
      finish(e);
    }
  });
}

export function rangeToArray(start: number, end: number): number[] {
  let result = [];
  for (let i = start; i < end; i += 1) {
    result.push(i);
  }
  return result;
}

export function convertSarifLogToAlerts(log: sarif.Log): BCVEAlert[] {
  return log.runs.flatMap(run =>
    run.results.map(
      (r: sarif.Result): BCVEAlert => {
        let loc = r.locations[0].physicalLocation,
          file = loc.artifactLocation.uri,
          lines = rangeToArray(loc.region.startLine, loc.region.endLine),
          location = { file, lines };
        return {
          location,
          ruleID: r.ruleId
        };
      }
    )
  );
}

/**
 * A user error that should be presented nicely.
 */
export class UserError extends Error {
  public foo: number;
  constructor(message: string) {
    super(`User error: ${message}`);
    this.foo = 42;
  }
}

export function checkUserProvidedFile(file: File | Dir) {
  if (!fs.existsSync(file)) {
    throw new UserError(`ENOENT: no such file or directory ${file}`);
  }
}
