import * as fs from "fs";
import path from "path";
import * as readline from "readline";
import {
  BCVE,
  BCVELog,
  BCVERun,
  Config,
  CVEState,
  Dir,
  DriverInputs,
  Export,
  File
} from "./types";
import * as validation from "./validation";
export function readJSONFile<T>(file: File): T {
  let content = fs.readFileSync(file, "utf8").trim();
  try {
    return JSON.parse(content) as T;
  } catch (e) {
    console.error(`Could not parse ${file} as a JSON file ('${content}')`);
    throw e;
  }
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function writeJSONFile(file: File, value: any): void {
  try {
    fs.writeFileSync(file, JSON.stringify(value), "utf8");
  } catch (e) {
    console.error(`Could not write ${file} as a JSON file.`);
    throw e;
  }
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function assert(v: any): void {
  if (!v) {
    throw new Error(`AssertionError: ${JSON.stringify(v)} is falsy`);
  }
}

export function writeExportFile(file: File, o: Export): void {
  validateAndWrite(o, file, validation.SchemaName.Export);
}

export function readExportFile(file: File): Export {
  return readAndValidate(file, validation.SchemaName.Export);
}

export function writeDriverInputsFile(file: File, o: DriverInputs): void {
  validateAndWrite(o, file, validation.SchemaName.DriverInputs);
}

export function readDriverInputsFile(file: File): DriverInputs {
  return readAndValidate(file, validation.SchemaName.DriverInputs);
}

export function readBCVEFiles(
  dir: Dir,
  sourcesDir: Dir,
  allowIncomplete: boolean
): BCVE[] {
  function pad(str: string, max: number): string {
    return str.length < max ? pad("0" + str, max) : str;
  }

  let bcves = fs
    .readdirSync(dir)
    .map((f: File): BCVE => readBCVEFile(path.join(dir, f)))
    .filter(bcve =>
      allowIncomplete
        ? true
        : // `state` is `ACCEPTED`
          (bcve.state === undefined || bcve.state === CVEState.ACCEPTED) &&
          // `prePatch` exists and contains at least one relevant weakness
          bcve.prePatch &&
          bcve.prePatch.weaknesses &&
          bcve.prePatch.weaknesses.length > 0 &&
          // `postPatch` exists and contains zero relevant weaknesses
          bcve.postPatch &&
          (bcve.postPatch.weaknesses === undefined ||
            bcve.postPatch.weaknesses.length === 0)
    );

  // enchance data slightly
  bcves.forEach(bcve => {
    if (sourcesDir) {
      if (bcve.prePatch?.commit) {
        bcve.prePatch.localSourceDirectory = path.join(
          sourcesDir,
          bcve.CVE,
          bcve.prePatch.commit
        );
        assert(bcve.prePatch.localSourceDirectory.startsWith(sourcesDir));
      }
      if (bcve.postPatch?.commit) {
        bcve.postPatch.localSourceDirectory = path.join(
          sourcesDir,
          bcve.CVE,
          bcve.postPatch.commit
        );
        assert(bcve.postPatch.localSourceDirectory.startsWith(sourcesDir));
      }
    }
    // normalize CWEs to be of the form (CWE-\d\d\d\d)
    bcve.CWEs = bcve.CWEs.map(cwe => {
      let match = cwe.match(/(CWE-)(\d+)/);
      if (match) {
        return match[1] + pad((+match[2]).toString(), 4);
      }
    });
    return bcve;
  });

  return bcves;
}

export function anonymizeBCVEs(bcves: BCVE[]): void {
  let anonymousToolIDs = new Map();
  let anonymousRuleIDs = new Map();
  function anonymize(run: BCVERun) {
    if (!anonymousToolIDs.has(run.toolID)) {
      anonymousToolIDs.set(run.toolID, `tool-${anonymousToolIDs.size}`);
    }
    run.toolID = anonymousToolIDs.get(run.toolID);
    (run.alerts || []).forEach(a => {
      if (!anonymousRuleIDs.has(a.ruleID)) {
        anonymousRuleIDs.set(a.ruleID, `rule-${anonymousRuleIDs.size}`);
      }
      a.ruleID = anonymousRuleIDs.get(a.ruleID);
      a.url = undefined;
    });
  }
  bcves.forEach(bcve =>
    [bcve.postPatch, bcve.prePatch].forEach(c =>
      (c.runs || []).forEach(r => anonymize(r))
    )
  );
}
export function readBCVEFile(file: File): BCVE {
  return readAndValidate(file, validation.SchemaName.BCVE);
}

export function writeLogFile(file: File, o: BCVELog): void {
  validateAndWrite(o, file, validation.SchemaName.Log);
}

export function readLogFile(file: File): BCVELog {
  return readAndValidate(file, validation.SchemaName.Log);
}

export function readConfigFile(file: File): Config {
  return readAndValidate(file, validation.SchemaName.Config);
}

function readAndValidate<T>(file: File, schemaName: validation.SchemaName): T {
  let o: T = readJSONFile(file);
  try {
    validation.validateSingle(o, schemaName);
    return o;
  } catch (e) {
    throw new Error(
      `Could not read and validate ${file} as ${schemaName}: ${
        (e as Error).message
      }`
    );
  }
}

function validateAndWrite<T>(
  o: T,
  file: File,
  schemaName: validation.SchemaName
): void {
  try {
    validation.validateSingle(o, schemaName);
    writeJSONFile(file, o);
  } catch (e) {
    throw new Error(
      `Could not validate and write ${file} as ${schemaName}: ${
        (e as Error).message
      }`
    );
  }
}

export async function readStdinLines(): Promise<string[]> {
  let rl = readline.createInterface({
    input: process.stdin,
    terminal: false
  });
  let lines = [];
  for await (let ref of rl) {
    lines.push(ref);
  }
  return lines;
}

export function setDifference<T>(a: Set<T>, b: Set<T>): Set<T> {
  return new Set([...a].filter(x => !b.has(x)));
}
export function setIntersection<T>(a: Set<T>, b: Set<T>): Set<T> {
  return new Set([...a].filter(x => b.has(x)));
}
