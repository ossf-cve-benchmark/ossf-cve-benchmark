import * as axios from "axios";
import * as cp from "child_process";
import * as fs from "fs";
import * as path from "path";
import { BCVE, CommitID, Dir, RepositoryIdentifier } from "./types";
import { assert } from "./util";

function tryParseGitHubRepositoryURL(repository: RepositoryIdentifier) {
  let url;
  try {
    url = new URL(repository);
  } catch (e) {
    return undefined;
  }
  if (url.protocol.match(/https?:/) && url.host === "github.com") {
    let parsed = url.pathname.match(/^\/(.+?)\/(.+?).git$/);
    if (parsed) {
      return { host: url.host, org: parsed[1], repo: parsed[2] };
    }
  }

  return undefined;
}

function mkGitUrl(host: string, path: string) {
  return `git@${host}:${path}.git`;
}
function downloadCommitFromRepository(
  repository: RepositoryIdentifier,
  commit: CommitID,
  dir: Dir,
  anonymous: boolean
): boolean {
  assert(repository);
  assert(commit);
  assert(dir);
  console.log(`Progress: Downloading ${repository} ${commit} to ${dir} ...`);

  if (fs.existsSync(dir)) {
    console.log("Progres: Download target already exists, skipping download.");
  } else {
    // use authorized clones if possible
    let github = tryParseGitHubRepositoryURL(repository),
      repositoryUrlToUse =
        github && !anonymous
          ? mkGitUrl(github.host, `${github.org}/${github.repo}`)
          : repository;

    let parent = path.dirname(dir);
    fs.mkdirSync(parent, { recursive: true });
    let DOWNLOAD = true;
    try {
      if (DOWNLOAD) {
        cp.execFileSync("git", ["clone", "--quiet", repositoryUrlToUse, dir]);
        console.log("Progress: Download complete.");
      } else {
        console.log(
          "Progress: Skipping download due to configuration. Would have run:"
        );
        console.log(
          ["git", ["clone", "--quiet", repositoryUrlToUse, dir].join(" ")].join(
            " "
          )
        );
      }
    } catch (e) {
      fs.rmdirSync(dir, { recursive: true });
      console.log(
        `Progress: Download of ${repository} ${commit} to ${dir} failed: ${
          (e as Error).message
        }`
      );
      console.error(e);
    }
  }
  if (!fs.existsSync(dir)) {
    console.log(
      `Progres: Downloaded ${dir} does not exist, skipping checkout ...`
    );
    return false;
  } else {
    console.log(`Progres: Downloaded ${dir} exists, checking out ${commit}.`);
    try {
      cp.execFileSync("git", ["-C", dir, "checkout", "--quiet", commit]);
      console.log("Progress: Checkout complete.");
      return true;
    } catch (e) {
      console.log(
        `Progress: Checkout of ${repository} ${commit} to ${dir} failed: ${
          (e as Error).message
        }`
      );
      fs.rmdirSync(dir, { recursive: true });
      console.error(e);
      return false;
    }
  }
}

function uploadCommitsToRepository(
  bcve: BCVE,
  repository: RepositoryIdentifier
): void {
  type CommitKind = "prePatch" | "postPatch";
  function uploadCommit(
    dir: Dir,
    commit: CommitID,
    repository: RepositoryIdentifier,
    branchName: CommitKind
  ) {
    if (!fs.existsSync(dir)) {
      console.error(
        `Source code directory ${dir} does not exist: can not upload commit to ${repository}`
      );
      return;
    }
    let args = ["-C", dir, "push", repository];
    // store with a convenient name, possibly overriding old upload
    cp.execFileSync("git", [
      ...args,
      `--force-with-lease`,
      `${commit}:refs/heads/${branchName}`
    ]);
    // store permantly
    cp.execFileSync("git", [...args, `${commit}:refs/heads/commit-${commit}`]);
  }
  uploadCommit(
    bcve.prePatch.localSourceDirectory,
    bcve.prePatch.commit,
    repository,
    "prePatch"
  );
  uploadCommit(
    bcve.postPatch.localSourceDirectory,
    bcve.postPatch.commit,
    repository,
    "postPatch"
  );
}

export function downloadCommitFromARepository(
  candidateRepositories: RepositoryIdentifier[],
  commit: CommitID,
  dir: Dir,
  anonymous: boolean
): void {
  for (let repo of candidateRepositories) {
    let result = downloadCommitFromRepository(repo, commit, dir, anonymous);
    if (result) {
      break;
    }
  }
}

export function makeCandidateRepositoryList(
  bcve: BCVE,
  canonicalRepositoriesRoot: string
): RepositoryIdentifier[] {
  return [
    bcve.repository,
    getCanonicalRepositoryIdentifier(bcve, canonicalRepositoriesRoot)
  ];
}
export function downloadCommitsForCVE(
  bcve: BCVE,
  anonymous: boolean,
  canonicalRepositoriesRoot: string
): void {
  let repositories = makeCandidateRepositoryList(
    bcve,
    canonicalRepositoriesRoot
  );
  downloadCommitFromARepository(
    repositories,
    bcve.prePatch.commit,
    bcve.prePatch.localSourceDirectory,
    anonymous
  );
  downloadCommitFromARepository(
    repositories,
    bcve.postPatch.commit,
    bcve.postPatch.localSourceDirectory,
    anonymous
  );
}

function getCanonicalRepositoryIdentifier(
  bcve: BCVE,
  canonicalRepositoriesRoot: string
): RepositoryIdentifier {
  return `${canonicalRepositoriesRoot}/${bcve.CVE}.git`;
}

function repositoryExists(repository: RepositoryIdentifier): boolean {
  try {
    let github = tryParseGitHubRepositoryURL(repository);
    let remote = repository;
    if (github) {
      remote = mkGitUrl(github.host, `${github.org}/${github.repo}`);
    }
    console.log(`Checking for existence of ${remote}`);
    cp.execFileSync("git", ["ls-remote", "-q", remote]);
    return true;
  } catch (e) {
    return false;
  }
}

async function createRepository(
  repository: RepositoryIdentifier,
  authToken: string
) {
  let github = tryParseGitHubRepositoryURL(repository);
  if (github) {
    let url = `https://api.${github.host}/orgs/${github.org}/repos`;
    let parameters = {
      name: github.repo,
      // lock down the repository as much as possible:
      private: true,
      has_issues: false,
      has_projects: false,
      has_wiki: false,
      is_template: false
    };
    let options = {
      headers: {
        Authorization: `token ${authToken}`
      }
    };
    console.log(`Creating repository: ${repository} using token: ${authToken}`);
    await axios.default.post(url, parameters, options);
    return;
  }
  throw new Error(`Can not (yet) create repository ${repository}`);
}

export async function uploadCVECommitsToCanonicalRepository(
  bcve: BCVE,
  canonicalRepositoriesRoot: string,
  authToken: string
): Promise<void> {
  let repository = getCanonicalRepositoryIdentifier(
    bcve,
    canonicalRepositoriesRoot
  );
  if (!repositoryExists(repository)) {
    await createRepository(repository, authToken);
  }
  let github = tryParseGitHubRepositoryURL(repository);
  if (github) {
    repository = mkGitUrl(github.host, `${github.org}/${github.repo}`);
  }
  uploadCommitsToRepository(bcve, repository);
}
