import * as cp from "child_process";
import { BCVE, CommitID, Dir, RepositoryIdentifier } from "./types";
import * as fs from "fs";
import * as path from "path";
import { assert } from "./util";

function downloadCommitFromRepository(
  repository: RepositoryIdentifier,
  commit: CommitID,
  dir: Dir,
  anonymous: boolean
): boolean {
  assert(repository);
  assert(commit);
  assert(dir);
  console.log(`Progress: Downloading ${repository} ${commit} to ${dir} ...`);

  if (fs.existsSync(dir)) {
    console.log("Progres: Download target already exists, skipping download.");
  } else {
    // use authorized clones if possible
    let githubHttpsUrlPattern = /^https:\/\/github.com\/(.+?)\/(.+?).git$/,
      match = repository.match(githubHttpsUrlPattern),
      repositoryUrlToUse =
        match && !anonymous
          ? `git@github.com:${match[1]}/${match[2]}.git`
          : repository;

    let parent = path.dirname(dir);
    fs.mkdirSync(parent, { recursive: true });
    let DOWNLOAD = true;
    try {
      if (DOWNLOAD) {
        cp.execFileSync("git", ["clone", "--quiet", repositoryUrlToUse, dir]);
        console.log("Progress: Download complete.");
      } else {
        console.log(
          "Progress: Skipping download due to configuration. Would have run:"
        );
        console.log(
          ["git", ["clone", "--quiet", repositoryUrlToUse, dir].join(" ")].join(
            " "
          )
        );
      }
    } catch (e) {
      fs.rmdirSync(dir, { recursive: true });
      console.log(
        `Progress: Download of ${repository} ${commit} to ${dir} failed: ${
          (e as Error).message
        }`
      );
      console.error(e);
    }
  }
  if (!fs.existsSync(dir)) {
    console.log(
      `Progres: Downloaded ${dir} does not exist, skipping checkout ...`
    );
    return false;
  } else {
    console.log(`Progres: Downloaded ${dir} exists, checking out ${commit}.`);
    try {
      cp.execFileSync("git", ["-C", dir, "checkout", "--quiet", commit]);
      console.log("Progress: Checkout complete.");
      return true;
    } catch (e) {
      console.log(
        `Progress: Checkout of ${repository} ${commit} to ${dir} failed: ${
          (e as Error).message
        }`
      );
      fs.rmdirSync(dir, { recursive: true });
      console.error(e);
      return false;
    }
  }
}

function uploadCommitsToRepository(
  bcve: BCVE,
  repository: RepositoryIdentifier
): void {
  function uploadCommit(
    dir: Dir,
    commit: CommitID,
    repository: RepositoryIdentifier,
    branchName: string
  ) {
    cp.execFileSync("git", [
      "-C",
      dir,
      "push",
      repository,
      `${commit}:refs/heads/${branchName}`
    ]);
  }
  uploadCommit(
    bcve.prePatch.localSourceDirectory,
    bcve.prePatch.commit,
    repository,
    "prePatch"
  );
  uploadCommit(
    bcve.postPatch.localSourceDirectory,
    bcve.postPatch.commit,
    repository,
    "postPatch"
  );
}

export function downloadCommitFromARepository(
  candidateRepositories: RepositoryIdentifier[],
  commit: CommitID,
  dir: Dir,
  anonymous: boolean
): void {
  for (let repo of candidateRepositories) {
    let result = downloadCommitFromRepository(repo, commit, dir, anonymous);
    if (result) {
      break;
    }
  }
}

export function makeCandidateRepositoryList(
  bcve: BCVE,
  canonicalRepositoriesRoot: string
): RepositoryIdentifier[] {
  return [
    bcve.repository,
    getCanonicalRepositoryIdentifier(bcve, canonicalRepositoriesRoot)
  ];
}
export function downloadCommitsForCVE(
  bcve: BCVE,
  anonymous: boolean,
  canonicalRepositoriesRoot: string
): void {
  let repositories = makeCandidateRepositoryList(
    bcve,
    canonicalRepositoriesRoot
  );
  downloadCommitFromARepository(
    repositories,
    bcve.prePatch.commit,
    bcve.prePatch.localSourceDirectory,
    anonymous
  );
  downloadCommitFromARepository(
    repositories,
    bcve.postPatch.commit,
    bcve.postPatch.localSourceDirectory,
    anonymous
  );
}

function getCanonicalRepositoryIdentifier(
  bcve: BCVE,
  canonicalRepositoriesRoot: string
): RepositoryIdentifier {
  return `${canonicalRepositoriesRoot}/${bcve.CVE}.git`;
}

export function uploadCVECommitsToCanonicalRepository(
  bcve: BCVE,
  canonicalRepositoriesRoot: string
): void {
  let repository = getCanonicalRepositoryIdentifier(
    bcve,
    canonicalRepositoriesRoot
  );
  uploadCommitsToRepository(bcve, repository);
}
