import "module-alias/register";
import * as http from "http";
import * as path from "path";
import * as fs from "fs";
import * as url from "url";
import { File, BCVE, CVEString, CommitID, CommitDescription } from "@types";

export namespace Types {
  export type CommitData = {
    CVE: string;
    kind: string;
    commit: string;
  };
  export type FileData = {
    file: string;
  };
  export type AnnotationData = {
    line: number;
    kind: string;
    msg: string;
  };
  export type AnnotationCounts = {
    [toolID: string]: number;
  };
}

export default class ExploreServer {
  constructor(private bcves: BCVE[], private port: number) {}

  resolveSourceFileRequest(CVE: CVEString, commit: CommitID, file: File) {
    if (file === undefined) {
      return undefined;
    }
    let bcve = this.bcves.find(bcve => bcve.CVE === CVE);
    if (bcve === undefined) {
      console.warn(`Could not find ${CVE} among the hosted CVEs.`);
      return undefined;
    }
    let localSourceDirectory;
    if (bcve.patchBase?.commit === commit) {
      localSourceDirectory = bcve.patchBase.localSourceDirectory;
    } else if (bcve.postPatch?.commit === commit) {
      localSourceDirectory = bcve.postPatch.localSourceDirectory;
    } else {
      console.warn(
        `Could not find commit ${commit} for ${CVE} among the hosted CVEs.`
      );
      return undefined;
    }

    if (localSourceDirectory === undefined) {
      console.warn(`No local sources for commit ${commit} of ${CVE}.`);
      return undefined;
    }

    let resolved = path.resolve(path.join(localSourceDirectory, file));
    if (!resolved.startsWith(localSourceDirectory)) {
      console.warn(
        `The ${file} for ${commit} of ${CVE} does not reside in ${localSourceDirectory}.`
      );
      return undefined;
    }
    if (!fs.existsSync(resolved)) {
      console.warn(
        `The file ${resolved} for ${commit} of ${CVE} does not exist.`
      );
      return undefined;
    }
    return resolved;
  }

  getCommits(): Types.CommitData[] {
    return this.bcves.flatMap(bcve => {
      let commits = [];
      if (bcve.patchBase) {
        commits.push({
          CVE: bcve.CVE,
          kind: "patchBase",
          commit: bcve.patchBase.commit
        });
      }
      if (bcve.postPatch) {
        commits.push({
          CVE: bcve.CVE,
          kind: "postPatch",
          commit: bcve.postPatch.commit
        });
      }
      return commits;
    });
  }

  getBCVE(cve: CVEString) {
    // TODO (performance) use a persistent map here
    return this.bcves.find(bcve => bcve.CVE === cve);
  }

  getFiles(cve: CVEString, commit: CommitID): Types.FileData[] {
    function getFiles(commitDescription: CommitDescription): string[] {
      let alerts = (commitDescription.runs || []).flatMap(r =>
        (r.alerts || []).map(a => a.location.file)
      );
      return alerts;
    }
    let bcve = this.getBCVE(cve);
    let files = [];
    if (bcve.patchBase && bcve.patchBase.commit === commit) {
      files.push(...getFiles(bcve.patchBase));
    }
    if (bcve.postPatch && bcve.postPatch.commit === commit) {
      files.push(...getFiles(bcve.postPatch));
    }
    files = Array.from(new Set(files));
    return files.map(f => ({ file: f }));
  }

  getAnnotations(
    cve: CVEString,
    commit: CommitID,
    file: File
  ): Types.AnnotationData[] {
    function getAnnotations(
      commitDescription: CommitDescription,
      file: File
    ): Types.AnnotationData[] {
      let alerts = (commitDescription.runs || []).flatMap(r =>
        (r.alerts || [])
          .filter(a => a.location.file === file)
          .map(a => ({
            line: a.location.line,
            kind: r.toolID,
            msg: `${r.toolID}:${a.classification}:${a.ruleID}: ${a.explanation}`
          }))
      );
      return alerts;
    }
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return [];
    }
    if (bcve.patchBase && bcve.patchBase.commit === commit) {
      return getAnnotations(bcve.patchBase, file);
    }
    if (bcve.postPatch && bcve.postPatch.commit === commit) {
      return getAnnotations(bcve.postPatch, file);
    }
  }
  getAnnotationCounts(
    cve: CVEString,
    commit: CommitID,
    file?: File
  ): Types.AnnotationCounts {
    function getAnnotationCounts(
      commitDescription: CommitDescription
    ): Types.AnnotationCounts {
      let counts: Types.AnnotationCounts = {};
      (commitDescription.runs || []).forEach(r => {
        counts[r.toolID] = counts[r.toolID] || 0;
        counts[r.toolID] += (r.alerts || []).filter(a =>
          file === undefined ? true : a.location.file === file
        ).length;
      });
      return counts;
    }
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return {};
    }
    if (bcve.patchBase && bcve.patchBase.commit === commit) {
      return getAnnotationCounts(bcve.patchBase);
    }
    if (bcve.postPatch && bcve.postPatch.commit === commit) {
      return getAnnotationCounts(bcve.postPatch);
    }
  }

  listen(req: http.IncomingMessage, res: http.ServerResponse) {
    console.log(`Got request: ${req.url}`);
    let codemirrorDir = path.dirname(require.resolve("codemirror"));
    let parsedUrl = url.parse(req.url, true);
    switch (parsedUrl.pathname) {
      case "/": {
        res.setHeader("Content-Type", "text/html");
        let html = `<html>
  <head>
    <script src="lib/codemirror.js"></script>
    <script src="/lib/codemirror/mode/javascript.js"></script>
    <link rel="stylesheet" href="lib/codemirror.css">
    <link rel="stylesheet" href="lib/style.css">
  </head>
  <body>
    <div id="content"></div>
    <script type="text/javascript" src="lib/script.js"></script>
  </body>
</html>
`;
        res.writeHead(200);
        res.end(html);
        break;
      }
      case "/sources": /*?CVE=...&commit=...&file=...*/ {
        let file;
        try {
          file = this.resolveSourceFileRequest(
            parsedUrl.query.CVE as string,
            parsedUrl.query.commit as string,
            parsedUrl.query.file as string
          );
        } catch (e) {
          console.error("Ignoring `resolveSourceFileRequest` error:");
          console.error(e);
          file = undefined;
        }
        if (file === undefined) {
          res.writeHead(404);
          res.end();
        } else {
          let src = fs.readFileSync(file);
          res.setHeader("Content-Type", "text/plain");
          res.writeHead(200);
          res.end(src);
        }
        break;
      }
      case "/data/getCommits": /* */ {
        res.setHeader("Content-Type", "application/json");
        res.writeHead(200);
        res.end(JSON.stringify(this.getCommits()));
        break;
      }
      case "/data/getCVE": /* CVE=...*/ {
        res.setHeader("Content-Type", "application/json");
        res.writeHead(200);
        res.end(JSON.stringify(this.getBCVE(parsedUrl.query.CVE as string)));
        break;
      }

      case "/data/getFiles": /* CVE=...&commit=...*/ {
        res.setHeader("Content-Type", "application/json");
        res.writeHead(200);
        res.end(
          JSON.stringify(
            this.getFiles(
              parsedUrl.query.CVE as string,
              parsedUrl.query.commit as string
            )
          )
        );
        break;
      }
      case "/data/getCVEAnnotationCounts": /* CVE=...&commit=...*/ {
        res.setHeader("Content-Type", "application/json");
        res.writeHead(200);
        res.end(
          JSON.stringify(
            this.getAnnotationCounts(
              parsedUrl.query.CVE as string,
              parsedUrl.query.commit as string
            )
          )
        );
        break;
      }
      case "/data/getFileAnnotationCounts": /* CVE=...&commit=...&file=...*/ {
        res.setHeader("Content-Type", "application/json");
        res.writeHead(200);
        res.end(
          JSON.stringify(
            this.getAnnotationCounts(
              parsedUrl.query.CVE as string,
              parsedUrl.query.commit as string,
              parsedUrl.query.file as string
            )
          )
        );
        break;
      }
      case "/data/getAnnotations": /* CVE=...&commit=...&file=...*/ {
        res.setHeader("Content-Type", "application/json");
        res.writeHead(200);
        res.end(
          JSON.stringify(
            this.getAnnotations(
              parsedUrl.query.CVE as string,
              parsedUrl.query.commit as string,
              parsedUrl.query.file as string
            )
          )
        );
        break;
      }

      case "/lib/codemirror.js": {
        let src = fs.readFileSync(path.join(codemirrorDir, "codemirror.js"));
        res.setHeader("Content-Type", "text/javascript");
        res.writeHead(200);
        res.end(src);
        break;
      }
      case "/lib/codemirror.css": {
        let src = fs.readFileSync(path.join(codemirrorDir, "codemirror.css"));
        res.setHeader("Content-Type", "text/css");
        res.writeHead(200);
        res.end(src);
        break;
      }
      case "/lib/codemirror/mode/javascript.js": {
        let src = fs.readFileSync(
          path.join(codemirrorDir, "../mode/javascript/javascript.js")
        );
        res.setHeader("Content-Type", "text/javascript");
        res.writeHead(200);
        res.end(src);
        break;
      }

      case "/lib/script.js": {
        let src = fs.readFileSync(require.resolve("./explore-client"));
        res.setHeader("Content-Type", "text/javascript");
        res.writeHead(200);
        res.end(src);
        break;
      }
      case "/lib/style.css": {
        let src = `
.line-annotation {
    font-size: 100%;
    background: #f50;
    color: #000;
    padding: 1px;
    margin: 1px;
}
.line-annotation-icon {
    color: #000;
    background-color: #a11;
    border-radius: 75%;
}
.mkTable {
    border-collapse: collapse;
    margin: 25px 0;
}
.mkTable thead tr {
    background-color: #a3a3a3;
    color: #ffffff;
    text-align: left;
}
.mkTable th,
.mkTable td {
    padding: 10px;
}
.mkTable tbody tr {
    border-bottom: 1px solid #dddddd;
}
.mkTable tbody tr:nth-of-type(even) {
    background-color: #f3f3f3;
}
`;
        res.setHeader("Content-Type", "text/css");
        res.writeHead(200);
        res.end(src);
        break;
      }
      default:
        res.writeHead(404);
        res.end(JSON.stringify({ error: "Resource not found" }));
    }
  }

  public async start() {
    return new Promise((resolve, reject) => {
      try {
        const server = http.createServer((req, res) => this.listen(req, res)),
          host = "localhost";
        server.listen(this.port, host, () => {
          console.log(`Server is running on http://${host}:${this.port}`);
          server.on("close", () => {
            console.log("Server closed");
            resolve();
          });
        });
      } catch (e) {
        reject(e);
      }
    });
  }
}
