import * as http from "http";
import * as path from "path";
import * as fs from "fs";
import * as url from "url";
import {
  File,
  BCVE,
  CVEString,
  CommitID,
  CommitDescription,
  ToolID,
  RuleID,
  CWEString
} from "./types";
import * as ClientTypes from "./explore/shared-types";
function makePermalink(bcve: BCVE, commit: CommitID) {
  let githubRepoPattern = /^https:\/\/github.com\/([^/]+)\/([^/]+)\.git$/;
  let github = bcve.repository.match(githubRepoPattern);
  if (github) {
    let [, owner, repo] = github;
    return `https://github.com/${owner}/${repo}/commit/${commit}`;
  }
  return undefined; // XXX
}

function buildTargetsMap(bcves: BCVE[]): TargetsMap {
  let weaknessLocations = bcves
    .flatMap(bcve =>
      [bcve.patchBase, bcve.postPatch].map(c => ({
        CVE: bcve.CVE,
        commit: c.commit,
        weaknesses: c.weaknesses
      }))
    )
    .flatMap(g =>
      (g.weaknesses || [])
        .filter(w => !!w.location)
        .map(w => ({
          CVE: g.CVE,
          commit: g.commit,
          file: w.location.file,
          line: w.location.line
        }))
    );
  let targets = new Map();
  weaknessLocations.forEach(l => {
    if (!targets.has(l.CVE)) {
      targets.set(l.CVE, new Map());
    }

    let byCVE = targets.get(l.CVE);
    if (!byCVE.has(l.commit)) {
      byCVE.set(l.commit, new Map());
    }

    let byCVEAndCommit = byCVE.get(l.commit);
    if (!byCVEAndCommit.has(l.file)) {
      byCVEAndCommit.set(l.file, new Set());
    }

    let byCVEAndCommitAndFile = byCVEAndCommit.get(l.file);
    byCVEAndCommitAndFile.add(l.line);
  });
  return targets;
}

function buildRulesOnATargetMap(
  bcves: BCVE[],
  targets: TargetsMap
): RulesOnTargetMap {
  let unmapped = bcves.flatMap(bcve =>
    (bcve.patchBase.runs || []).flatMap(r =>
      (r.alerts || [])
        .filter(
          a =>
            a.location &&
            isOnTarget(
              bcve.CVE,
              bcve.patchBase.commit,
              a.location.file,
              a.location.line,
              targets
            )
        )
        .map(a => ({
          CVE: bcve.CVE,
          toolID: r.toolID,
          ruleID: a.ruleID
        }))
    )
  );
  let rulesOnATarget = new Map();
  unmapped.forEach(u => {
    if (!rulesOnATarget.has(u.CVE)) {
      rulesOnATarget.set(u.CVE, new Map());
    }

    let byCVE = rulesOnATarget.get(u.CVE);
    if (!byCVE.has(u.toolID)) {
      byCVE.set(u.toolID, new Set());
    }

    let byCVEAndToolID = byCVE.get(u.toolID);
    byCVEAndToolID.add(u.ruleID);
  });
  return rulesOnATarget;
}

function isOnTarget(
  cve: CVEString,
  commit: CommitID,
  file: File,
  line: number,
  targets: TargetsMap
): boolean {
  return !!targets
    .get(cve)
    ?.get(commit)
    ?.get(file)
    ?.has(line);
}

function isForRuleOnATarget(
  cve: CVEString,
  toolID: ToolID,
  ruleID: RuleID,
  rulesOnATarget: RulesOnTargetMap
): boolean {
  return !!rulesOnATarget
    .get(cve)
    ?.get(toolID)
    ?.has(ruleID);
}

type TargetsMap = Map<CVEString, Map<CommitID, Map<File, Set<number>>>>;
type RulesOnTargetMap = Map<CVEString, Map<ToolID, Set<RuleID>>>;
export default class ExploreServer {
  private targets: TargetsMap = new Map();
  private rulesOnATarget: RulesOnTargetMap = new Map();
  constructor(private bcves: BCVE[], private port: number) {
    this.targets = buildTargetsMap(bcves);
    this.rulesOnATarget = buildRulesOnATargetMap(bcves, this.targets);
  }

  resolveSourceFileRequest(CVE: CVEString, commit: CommitID, file: File) {
    if (file === undefined) {
      return undefined;
    }
    let bcve = this.bcves.find(bcve => bcve.CVE === CVE);
    if (bcve === undefined) {
      console.warn(`Could not find ${CVE} among the hosted CVEs.`);
      return undefined;
    }
    let localSourceDirectory;
    if (bcve.patchBase?.commit === commit) {
      localSourceDirectory = bcve.patchBase.localSourceDirectory;
    } else if (bcve.postPatch?.commit === commit) {
      localSourceDirectory = bcve.postPatch.localSourceDirectory;
    } else {
      console.warn(
        `Could not find commit ${commit} for ${CVE} among the hosted CVEs.`
      );
      return undefined;
    }

    if (localSourceDirectory === undefined) {
      console.warn(`No local sources for commit ${commit} of ${CVE}.`);
      return undefined;
    }

    let resolved = path.resolve(path.join(localSourceDirectory, file));
    if (!resolved.startsWith(localSourceDirectory)) {
      console.warn(
        `The ${file} for ${commit} of ${CVE} does not reside in ${localSourceDirectory}.`
      );
      return undefined;
    }
    if (!fs.existsSync(resolved)) {
      console.warn(
        `The file ${resolved} for ${commit} of ${CVE} does not exist.`
      );
      return undefined;
    }
    return resolved;
  }

  getCommits(bcves: BCVE[]): ClientTypes.CommitData[] {
    return bcves.flatMap(bcve => {
      let commits = [];
      if (bcve.patchBase) {
        commits.push({
          CVE: bcve.CVE,
          commit: bcve.patchBase.commit,
          permalink: makePermalink(bcve, bcve.patchBase.commit)
        });
      }
      if (bcve.postPatch) {
        commits.push({
          CVE: bcve.CVE,
          commit: bcve.postPatch.commit,
          permalink: makePermalink(bcve, bcve.postPatch.commit)
        });
      }
      return commits;
    });
  }

  getBCVE(cve: CVEString) {
    // TODO (performance) use a persistent map here
    return this.bcves.find(bcve => bcve.CVE === cve);
  }

  getFiles(cve: CVEString, commit: CommitID): ClientTypes.FileData[] {
    function getFiles(commitDescription: CommitDescription): string[] {
      let alerts = (commitDescription.runs || []).flatMap(r =>
        (r.alerts || []).map(a => a.location?.file).filter(f => f !== undefined)
      );
      return alerts;
    }
    let bcve = this.getBCVE(cve);
    let files = [];
    if (bcve.patchBase && bcve.patchBase.commit === commit) {
      files.push(...getFiles(bcve.patchBase));
    }
    if (bcve.postPatch && bcve.postPatch.commit === commit) {
      files.push(...getFiles(bcve.postPatch));
    }
    files = Array.from(new Set(files));
    return files.map(f => ({ file: f }));
  }
  getAlertsForBCVE(bcve: BCVE): ClientTypes.Alert[] {
    let targets = this.targets,
      rulesOnATarget = this.rulesOnATarget;

    function getAlerts(
      commitDescription: CommitDescription
    ): ClientTypes.Alert[] {
      let alerts = (commitDescription.runs || []).flatMap(r =>
        (r.alerts || [])
          .filter(a => !!a.location)
          .map(a => ({
            CVE: bcve.CVE,
            commit: commitDescription.commit,
            file: a.location.file,
            line: a.location.line,
            toolID: r.toolID,
            ruleID: a.ruleID,
            explanation: a.explanation,
            isOnTarget: isOnTarget(
              bcve.CVE,
              commitDescription.commit,
              a.location.file,
              a.location.line,
              targets
            ),
            isForRuleOnATarget: isForRuleOnATarget(
              bcve.CVE,
              r.toolID,
              a.ruleID,
              rulesOnATarget
            ),
            url: a.url
          }))
      );
      return alerts;
    }
    let alerts = [];
    if (bcve.patchBase) {
      alerts.push(...getAlerts(bcve.patchBase));
    }
    if (bcve.postPatch) {
      alerts.push(...getAlerts(bcve.postPatch));
    }
    return alerts;
  }
  getAlerts(cve: CVEString): ClientTypes.Alert[] {
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return [];
    }
    return this.getAlertsForBCVE(bcve);
  }
  getWeaknesses(): { [cve: string]: ClientTypes.Weakness[] } {
    function getWeaknesses(
      cve: CVEString,
      commitDescription: CommitDescription
    ): ClientTypes.Weakness[] {
      let weaknesses = (commitDescription.weaknesses || [])
        .filter(w => w.location)
        .map(w => ({
          CVE: cve,
          commit: commitDescription.commit,
          file: w.location.file,
          line: w.location.line,
          explanation: w.explanation
        }));
      return weaknesses;
    }

    let mapped: { [cve: string]: ClientTypes.Weakness[] } = {};
    this.bcves.forEach(bcve => {
      let weaknesses = [];
      if (bcve.patchBase) {
        weaknesses.push(...getWeaknesses(bcve.CVE, bcve.patchBase));
      }
      if (bcve.postPatch) {
        weaknesses.push(...getWeaknesses(bcve.CVE, bcve.postPatch));
      }
      mapped[bcve.CVE] = weaknesses;
    });
    return mapped;
  }
  getCVEWeaknesses(cve: CVEString): ClientTypes.Weakness[] {
    function getWeaknesses(
      kind: "patchBase" | "postPatch",
      commitDescription: CommitDescription
    ): ClientTypes.Weakness[] {
      let weaknesses = (commitDescription.weaknesses || [])
        .filter(w => !!w.location)
        .map(w => ({
          CVE: cve,
          commitKind: kind,
          commit: commitDescription.commit,
          file: w.location.file,
          line: w.location.line,
          explanation: w.explanation
        }));
      return weaknesses;
    }
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return [];
    }
    let weaknesses = [];
    if (bcve.patchBase) {
      weaknesses.push(...getWeaknesses("patchBase", bcve.patchBase));
    }
    if (bcve.postPatch) {
      weaknesses.push(...getWeaknesses("postPatch", bcve.postPatch));
    }
    return weaknesses;
  }
  getAlertCounts(
    cve: CVEString,
    commit: CommitID,
    file?: File
  ): ClientTypes.AlertCounts {
    function getAlertCounts(
      commitDescription: CommitDescription
    ): ClientTypes.AlertCounts {
      let counts: ClientTypes.AlertCounts = {};
      (commitDescription.runs || []).forEach(r => {
        counts[r.toolID] = counts[r.toolID] || 0;
        counts[r.toolID] += (r.alerts || []).filter(a =>
          file === undefined ? true : a.location.file === file
        ).length;
      });
      return counts;
    }
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return {};
    }
    if (bcve.patchBase && bcve.patchBase.commit === commit) {
      return getAlertCounts(bcve.patchBase);
    }
    if (bcve.postPatch && bcve.postPatch.commit === commit) {
      return getAlertCounts(bcve.postPatch);
    }
  }

  listen(req: http.IncomingMessage, res: http.ServerResponse) {
    try {
      console.log(`Got request: ${req.url}`);
      let parsedUrl = url.parse(req.url, true);
      switch (parsedUrl.pathname) {
        case "/": {
          res.setHeader("Content-Type", "text/html");
          let html = path.resolve(
            path.join(__dirname, "../../src/explore/index.html")
          );
          fs.createReadStream(html).pipe(res);
          break;
        }
        case "/main.js": {
          res.setHeader("Content-Type", "text/javascript");
          fs.createReadStream(path.join(__dirname, "../../dist/main.js")).pipe(
            res
          );
          break;
        }
        case "/main.css": {
          res.setHeader("Content-Type", "text/css");
          res.writeHead(200);
          fs.createReadStream("../../dist/main.css").pipe(res);
          break;
        }
        case "/sources": /*?CVE=...&commit=...&file=...*/ {
          let file;
          try {
            file = this.resolveSourceFileRequest(
              parsedUrl.query.CVE as string,
              parsedUrl.query.commit as string,
              parsedUrl.query.file as string
            );
          } catch (e) {
            console.error("Ignoring `resolveSourceFileRequest` error:");
            console.error(e);
            file = undefined;
          }
          if (file === undefined) {
            // XXX support downloading on the fly
            res.writeHead(404);
            res.end();
          } else {
            let src = fs.readFileSync(file);
            res.setHeader("Content-Type", "text/plain");
            res.writeHead(200);
            res.end(src);
          }
          break;
        }
        case "/data/getBenchmarkSource": /* CVE=... */ {
          let cvesDir = path.resolve(path.join(__dirname, "../../CVEs/"));
          let cve = parsedUrl.query.CVE;
          let file = path.resolve(path.join(cvesDir, `${cve}.json`));
          res.setHeader("Content-Type", "text/plain");
          if (!file.startsWith(cvesDir)) {
            console.warn(
              `The ${file} for ${cve} does not reside in ${cvesDir}.`
            );
            res.writeHead(404);
            res.end();
            return;
          }

          res.writeHead(200);
          fs.createReadStream(file).pipe(res);
          break;
        }
        case "/data/getCommits": /* */ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(this.getCommits(this.bcves)));
          break;
        }
        case "/data/getCVECommits": /* CVE=... */ {
          let bcve = this.getBCVE(parsedUrl.query.CVE as string);
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify({
              unpatchedCommit: {
                CVE: bcve.CVE,
                commit: bcve.patchBase.commit,
                permalink: makePermalink(bcve, bcve.patchBase.commit)
              },
              patchCommit: {
                CVE: bcve.CVE,
                commit: bcve.postPatch.commit,
                permalink: makePermalink(bcve, bcve.postPatch.commit)
              }
            })
          );
          break;
        }
        case "/data/getAllCVECommits": /* */ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.bcves.map(bcve => ({
                unpatchedCommit: {
                  CVE: bcve.CVE,
                  commit: bcve.patchBase.commit,
                  permalink: makePermalink(bcve, bcve.patchBase.commit)
                },
                patchCommit: {
                  CVE: bcve.CVE,
                  commit: bcve.postPatch.commit,
                  permalink: makePermalink(bcve, bcve.postPatch.commit)
                }
              }))
            )
          );
          break;
        }
        case "/data/getCVERepository": /* CVE=... */ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(this.getBCVE(parsedUrl.query.CVE as string).repository);
          break;
        }

        case "/data/getToolIds": /* */ {
          res.setHeader("Content-Type", "application/json");
          let toolIDs = this.bcves.flatMap(bcve =>
            [bcve.patchBase, bcve.postPatch].flatMap(c =>
              (c.runs || []).map(r => r.toolID)
            )
          );
          res.writeHead(200);
          res.end(JSON.stringify(Array.from(new Set(toolIDs))));
          break;
        }
        case "/data/getCVEs": /* */ {
          let list = this.bcves.map(bcve => bcve.CVE);
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(list));
          break;
        }

        case "/data/getCVE2CWEs": /* */ {
          let map: { [cve: string]: CWEString[] } = {};
          this.bcves.forEach(bcve => (map[bcve.CVE] = bcve.CWEs));
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(map));
          break;
        }

        case "/data/getFiles": /* CVE=...&commit=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.getFiles(
                parsedUrl.query.CVE as string,
                parsedUrl.query.commit as string
              )
            )
          );
          break;
        }
        case "/data/getCVEAlertCounts": /* CVE=...&commit=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.getAlertCounts(
                parsedUrl.query.CVE as string,
                parsedUrl.query.commit as string
              )
            )
          );
          break;
        }
        case "/data/getFileAlertCounts": /* CVE=...&commit=...&file=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.getAlertCounts(
                parsedUrl.query.CVE as string,
                parsedUrl.query.commit as string,
                parsedUrl.query.file as string
              )
            )
          );
          break;
        }
        case "/data/getAllAlerts": /* */ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.bcves.flatMap(bcve => this.getAlertsForBCVE(bcve))
            )
          );
          break;
        }
        case "/data/getAlerts": /* CVE=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(this.getAlerts(parsedUrl.query.CVE as string))
          );
          break;
        }
        case "/data/getAllWeaknesses": {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              Object.values(this.getWeaknesses()).flatMap(id => id)
            )
          );
          break;
        }
        case "/data/getAllToolRuns": {
          let runs = this.bcves.flatMap(bcve =>
            [bcve.patchBase, bcve.postPatch].flatMap(c =>
              (c.runs || []).map(r => ({
                CVE: bcve.CVE,
                toolID: r.toolID,
                commit: c.commit
              }))
            )
          );

          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(runs));
          break;
        }
        case "/data/getCWENames": {
          // XXX make this data more dynamic
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify({
              "CWE-0020": "Improper Input Validation",
              "CWE-0022":
                "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
              "CWE-0023": "Relative Path Traversal",
              "CWE-0036": "Absolute Path Traversal",
              "CWE-0073": "External Control of File Name or Path",
              "CWE-0074":
                "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')",
              "CWE-0078":
                "Improper Sanitization of Special Elements used in an OS Command ('OS Command Injection')",
              "CWE-0079":
                "Failure to Preserve Web Page Structure ('Cross-site Scripting')",
              "CWE-0088": "Argument Injection or Modification",
              "CWE-0089":
                "Improper Sanitization of Special Elements used in an SQL Command ('SQL Injection')",
              "CWE-0094":
                "Failure to Control Generation of Code ('Code Injection')",
              "CWE-0099":
                "Improper Control of Resource Identifiers ('Resource Injection')",
              "CWE-0116": "Improper Encoding or Escaping of Output",
              "CWE-0200": "Information Exposure",
              "CWE-0250": "Execution with Unnecessary Privileges",
              "CWE-0290": "Authentication Bypass by Spoofing",
              "CWE-0312": "Cleartext Storage of Sensitive Information"
            })
          );
          break;
        }

        case "/data/getCVEWeaknesses": /* CVE=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(this.getCVEWeaknesses(parsedUrl.query.CVE as string))
          );
          break;
        }
        default:
          res.writeHead(404);
          res.end(JSON.stringify({ error: "Resource not found" }));
      }
    } catch (e) {
      console.error(e);
    }
  }

  public async start() {
    return new Promise((resolve, reject) => {
      try {
        const server = http.createServer((req, res) => this.listen(req, res)),
          host = "localhost";
        server.listen(this.port, host, () => {
          console.log(`Server is running on http://${host}:${this.port}`);
          server.on("close", () => {
            console.log("Server closed");
            resolve();
          });
        });
      } catch (e) {
        reject(e);
      }
    });
  }
}
