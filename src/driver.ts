/**
 * This is the driver utility for the CVE Benchmarker.
 *
 * To ease development of new drivers, the functions in this file should be used.
 * See contrib/tools/eslint/src/eslint.ts for the reference usage of these utilities.
 */
import * as cp from "child_process";
import * as fs from "fs";
import * as os from "os";
import * as path from "path";
import * as repositories from "./repositories";
import {
  BCVE,
  BCVEAlert,
  BCVELog,
  BCVEResultStatus,
  CommitDescription,
  Config,
  CVEString,
  Dir,
  DriverInputs,
  File,
  StandaloneRun,
  ToolID
} from "./types";
import {
  readDriverInputsFile,
  readLogFile,
  writeJSONFile,
  writeLogFile
} from "./util";

/**
 * The parameters of the `Analyze` function.
 */
export type AnalyzeParams = {
  /** The Benchmark CVE to analyze */
  bcve: BCVE;
  /** The specific commit to analyze */
  commitDescription: CommitDescription;
  /** A fresh temporary directory */
  tmp: Dir;
  /** Setter for the commandline reproduction step of the performed analysis. Should only be invoked once.  */
  setReproduction: (r: string) => void;
  /** Setter for the alerts produced by the analysis. Should only be invoked once.  */
  setAlerts: (a: BCVEAlert[]) => void;
  /** Setter for the status of the analysis. Should only be invoked once.  */
  setStatus: (s: BCVEResultStatus) => void;
};

/**
 * Function for analysing a single commit.
 *
 * - callbacks can be used to report back results
 * - no error handling is required, escaping exceptions are caught and handled appropriately
 */
export type Analyze = (analyzeParams: AnalyzeParams) => Promise<void>;

/**
 * State for easier argument passing.
 */
type DriverState = {
  toolID: ToolID;
  bcve: BCVE;
  commitDescription: CommitDescription;
  tmp: Dir;
  resultFile: File;
  run?: StandaloneRun;
  descriptiveRunName: string;
};

/**
 * A simple wrapper around `child_process.spawn` that suits the needs of most drivers.
 *
 * Process errors or timeouts causes the promise to be rejected with an error message.
 *
 * For advanced process interaction, roll your own `child_process.spawn`.
 *
 * @param bin the executable to spawn a process for
 * @param args the arguments to provide to the executable
 * @param cwd the working directory of the spawned process
 * @param timeout the time (ms) the spawned process is allowed to run
 * @param setStatus a callback that can be used to set the (TIMEOUT) status for the run
 */
export async function simpleSpawn(
  bin: File,
  args: string[],
  cwd: Dir,
  timeout: number,
  setStatus: (s: BCVEResultStatus) => void
): Promise<void> {
  return new Promise((resolve, reject) => {
    let isDone = false;
    /**
     * The callback that is invoked when the spawned process terminates
     */
    function finish(e?: any) {
      if (isDone) {
        return;
      }
      console.log(
        `Spawned child-process finished${
          e ? `with error: ${JSON.stringify(e)}` : ""
        }`
      );
      isDone = true;
      if (e) {
        reject(e);
      } else {
        resolve();
      }
    }

    let start = +new Date();
    let expectedEnd = start + timeout;
    console.log(
      `Spawning child-process in ${cwd}: '${bin} ${args.join(
        " "
      )}' with timeout at ${new Date(expectedEnd).toLocaleString()} after ${
        timeout / 1000
      }s`
    );
    try {
      let p = cp.spawn(bin, args, {
        cwd,
        timeout
      });
      let showOutputs = false;
      // need to attach these listeners to avoid (occasional) subprocess failures
      p.stdout.on("data", function (data: { toString: () => string }) {
        if (showOutputs) {
          console.log(`stdout: ${data.toString()}`);
        }
      });
      p.stderr.on("data", function (data: { toString: () => string }) {
        if (showOutputs) {
          console.log(`stderr: ${data.toString()}`);
        }
      });
      p.on("error", finish);
      p.on("exit", () => {
        let end = +new Date();
        let delta = end - start;
        if (delta > timeout) {
          setStatus(BCVEResultStatus.TIMEOUT);
          finish(`Timeout after ${delta / 1000}s`);
        } else {
          finish();
        }
      });
      setTimeout(() => p.kill(), timeout);
    } catch (e) {
      finish(e);
    }
  });
}

/**
 * Gets the file where the results of a specific run would be stored.
 */
function getResultFile(
  resultDir: Dir,
  toolID: ToolID,
  cve: CVEString,
  commitKind: string
) {
  return path.join(resultDir, `${toolID}_${cve}_${commitKind}.json`);
}

/**
 * Minor optimization utility: if the run for the "other" commit has status TIMEOUT or CRASH, assume this run also will get status and write store the result as that.
 *
 * @return `true` iff the current run can be skipped (because the sibling run has the TIMEOUT or CRASH status)
 */
function trySkipWithSiblingResultStatus(
  siblingResultFile: File,
  state: DriverState,
  otherCommitKind: string,
  logError: (msg: string) => void
) {
  try {
    if (fs.existsSync(siblingResultFile)) {
      let siblingResult = readLogFile(siblingResultFile, false);
      let sibling = siblingResult.runs[0];
      if (
        (siblingResult.runs.length === 1 &&
          sibling.status === BCVEResultStatus.TIMEOUT) ||
        sibling.status === BCVEResultStatus.CRASH
      ) {
        console.info(
          `Result file run of ${state.toolID} on ${state.bcve.CVE}/${otherCommitKind} has status '${sibling.status}' (see ${state.resultFile}). Assuming run of ${state.descriptiveRunName} behaves the same.`
        );
        let result: BCVELog = {
          runs: [
            {
              toolID: state.toolID,
              CVE: state.bcve.CVE,
              commit: state.commitDescription.commit,
              status: sibling.status
            }
          ]
        };
        sibling.commit = state.commitDescription.commit;
        sibling.reproduction = undefined;
        writeJSONFile(state.resultFile, result);
        return true;
      }
    }
  } catch (e) {
    logError(
      `Exception while checking for sibling status: ${(e as Error).message}`
    );
    // ignore and continue
  }
  return false;
}

/**
 * The `catch` block for the `analyze`-call.
 */
function analyzeCatch(
  e: Error,
  state: DriverState,
  logError: (msg: string) => void
) {
  if (state.run.status == BCVEResultStatus.TIMEOUT) {
    logError(
      `Timeout while running ${state.descriptiveRunName} in ${state.tmp}.`
    );
  } else {
    logError(
      `Exception while running ${state.descriptiveRunName} in ${state.tmp}: ${e.message}.`
    );
    logError(e.stack);
    if (state.run.status === undefined) {
      state.run.status = BCVEResultStatus.CRASH;
    }
  }
}

/**
 * The `finally` block for the `analyze`-call.
 */
function analyzeFinally(state: DriverState, logError: (msg: string) => void) {
  if (state.run === undefined) {
    logError(
      `Sanity: No runs for ${state.descriptiveRunName} in ${state.tmp}?`
    );
  } else if (state.run.status === undefined) {
    logError(
      `Sanity: Not writing results for ${state.descriptiveRunName} in ${state.tmp}: missing 'result.status'.`
    );
  } else {
    console.info(
      `Writing results for ${state.descriptiveRunName} to ${state.resultFile} (status = ${state.run.status}).`
    );
    writeLogFile(state.resultFile, { runs: [state.run] }, false);
  }
}
/**
 * Ensures that the source code to analyze is available.
 * @return `true` iff the source code is available
 */
function ensureSourceCodeIsPresent(
  state: DriverState,
  canonicalRepositoriesRoot: string,
  allowDownload: boolean,
  downloadAnonymously: boolean,
  logError: (msg: string) => void
): boolean {
  try {
    if (
      !fs.existsSync(state.commitDescription.localSourceDirectory) &&
      allowDownload
    ) {
      console.log(
        `Local source directory ${state.commitDescription.localSourceDirectory} does not exist. Attempting download.`
      );
      repositories.downloadCommitFromARepository(
        repositories.makeCandidateRepositoryList(
          state.bcve,
          canonicalRepositoriesRoot
        ),
        state.commitDescription.commit,
        state.commitDescription.localSourceDirectory,
        downloadAnonymously
      );
    }
    if (!fs.existsSync(state.commitDescription.localSourceDirectory)) {
      logError(
        `Local source directory ${state.commitDescription.localSourceDirectory} does not exist. Please download before attempting analysis.`
      );
      return false;
    }
  } catch (e) {
    logError(
      `Exception while getting source code for ${state.descriptiveRunName}: ${
        (e as Error).message
      }.`
    );
    logError((e as Error).stack);
    return false;
  }
  return true;
}

/**
 * Sets up the environment for analysis and runs `analyze`.
 */
async function setupAndAnalyze(
  config: Config,
  state: DriverState,
  analyze: Analyze,
  logError: (msg: string) => void,
  // aux other args - would be nice to have them in a single object...
  otherCommitKind: string,
  requiresLocalSourceDirectory: boolean,
  allowDownload: boolean,
  downloadAnonymously: boolean
): Promise<void> {
  if (
    !state.commitDescription.commit ||
    !state.commitDescription.localSourceDirectory
  ) {
    throw new Error(`Missing BCVE content in ${JSON.stringify(state.bcve)}`);
  }
  if (fs.existsSync(state.resultFile)) {
    console.info(
      `Result file run of ${state.descriptiveRunName} already exists at ${state.resultFile}. Skipping run.`
    );
    return;
  }
  if (
    trySkipWithSiblingResultStatus(
      getResultFile(
        config.results,
        state.toolID,
        state.bcve.CVE,
        otherCommitKind
      ),
      state,
      otherCommitKind,
      logError
    )
  ) {
    return;
  }

  let run: StandaloneRun = {
    CVE: state.bcve.CVE,
    commit: state.commitDescription.commit,
    toolID: state.toolID,
    status: undefined
  };
  if (requiresLocalSourceDirectory) {
    let hasSorceCode = ensureSourceCodeIsPresent(
      state,
      config.canonicalRepositoriesRoot,
      allowDownload,
      downloadAnonymously,
      logError
    );
    if (!hasSorceCode) {
      writeLogFile(
        state.resultFile,
        {
          runs: [{ ...run, status: BCVEResultStatus.NO_SOURCES }]
        },
        false
      );
      return;
    }
  }
  try {
    state.run = run;
    console.info(`Running ${state.descriptiveRunName} in ${state.tmp}.`);
    await analyze({
      bcve: state.bcve,
      commitDescription: state.commitDescription,
      tmp: state.tmp,
      setReproduction: r => (state.run.reproduction = r),
      setAlerts: a => (state.run.alerts = a),
      setStatus: s => (state.run.status = s)
    });
    console.info(`Done running ${state.descriptiveRunName} in ${state.tmp}.`);
  } catch (e) {
    analyzeCatch(e, state, logError);
  } finally {
    analyzeFinally(state, logError);
  }
}

/**
 * Analyses the commits of a collection of CVEs, storing the homogenised results as files on disk.
 *
 * Arguments are parsed directly from the command-line.
 * You can get explicit control of which CVEs to run the analysis on by using `driveCVEs`.
 *
 * @param analyze callback that performs the analyzes a single commit (see `Analyze`)
 * @param requiresLocalSourceDirectory `true` iff the source code to analyse must be present on a local disk for analysis to succeed
 * @param allowDownload `true` iff source code can be downloaded on the fly if `requiresLocalSourceDirectory` demands it
 * @param downloadAnonymously `true` iff source code downloads should be performed anonymously when possible (may hit rate limits more often)
 */
export async function drive(
  analyze: Analyze,
  requiresLocalSourceDirectory = true,
  allowDownload = true,
  downloadAnonymously = true
): Promise<void> {
  let { toolID, bcves, config } = getDriverCommandlineInputs();
  await driveCVEs(
    bcves,
    config,
    toolID,
    analyze,
    requiresLocalSourceDirectory,
    allowDownload,
    downloadAnonymously
  );
}

/**
 * Analyses the commits of a collection of CVEs, storing the homogenised results as files on disk.
 *
 * @param bcves the CVEs, and associated meta-data to analyze with an analysis tool
 * @param config the effective configuration object that led to this function being invoked by the CVE Benchmarker
 * @param toolID the ID of the analysis tool to analyze with, `config.tools[toolID]` will produce the partial configuration object that led to this function being invoked by the CVE Benchmarker
 * @param analyze callback that performs the analyzes a single commit (see `Analyze`)
 * @param requiresLocalSourceDirectory `true` iff the source code to analyse must be present on a local disk for analysis to succeed
 * @param allowDownload `true` iff source code can be downloaded on the fly if `requiresLocalSourceDirectory` demands it
 * @param downloadAnonymously `true` iff source code downloads should be performed anonymously when possible (may hit rate limits more often)
 */
export async function driveCVEs(
  bcves: BCVE[],
  config: Config,
  toolID: ToolID,
  analyze: Analyze,
  requiresLocalSourceDirectory = true,
  allowDownload = true,
  downloadAnonymously = true
): Promise<void> {
  /**
   * The errors for the current analysis tool run.
   */
  let errors: string[];
  /**
   * The errors for all analysis tool runs.
   */
  let allErrors: string[] = [];
  /**
   * Logs an error, and stores it for later processing.
   */
  function logError(msg: string) {
    console.error(`ERROR: ${msg}`);
    errors.push(msg);
    allErrors.push(msg);
  }
  try {
    let runs = 0;
    let expectedRunCount = bcves.length * 2;
    // main loop: iterate over all CVEs and their commits, running the analysis tool once per commit
    let descriptiveRunName;
    for await (const bcve of bcves) {
      for await (const { commitKind, commitDescription, otherCommitKind } of [
        {
          commitKind: "prePatch",
          commitDescription: bcve.prePatch,
          otherCommitKind: "postPatch"
        },
        {
          commitKind: "postPatch",
          commitDescription: bcve.postPatch,
          otherCommitKind: "prePatch"
        }
      ]) {
        try {
          descriptiveRunName = `${toolID} on ${bcve.CVE}/${commitKind}`;
          runs++;
          errors = [];
          console.info(
            `Preparing run of ${descriptiveRunName} (run ${runs}/${expectedRunCount}).`
          );

          let state: DriverState = {
            toolID,
            bcve,
            commitDescription,
            tmp: fs.mkdtempSync(path.join(os.tmpdir(), `${toolID}-run-`)),
            resultFile: getResultFile(
              config.results,
              toolID,
              bcve.CVE,
              commitKind
            ),
            run: undefined,
            descriptiveRunName
          };
          await setupAndAnalyze(
            config,
            state,
            analyze,
            logError,
            otherCommitKind,
            requiresLocalSourceDirectory,
            allowDownload,
            downloadAnonymously
          );
        } catch (e) {
          logError(`Uncaught exception while running ${descriptiveRunName}.`);
          throw e;
        } finally {
          if (errors.length > 0) {
            console.error(`Errors for ${descriptiveRunName}:`);
            console.error(errors.map(e => `    - ${e}`).join("\n"));
          }
        }
      }
    }
  } finally {
    if (allErrors.length > 0) {
      console.error(`All errors (${allErrors.length}):`);
      console.error(allErrors.map(e => `    - ${e}`).join("\n"));
    }
    console.log(`Finished running ${toolID} for ${bcves.length} BCVEs`);
  }
}

/**
 * Gets the driver inputs from the commandline.
 */
export function getDriverCommandlineInputs(): DriverInputs {
  return readDriverInputsFile(process.argv[process.argv.length - 1], false);
}
