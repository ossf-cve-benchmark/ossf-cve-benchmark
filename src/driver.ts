import "module-alias/register";
import * as path from "path";
import * as fs from "fs";
import * as os from "os";
import {
  BCVE,
  BCVELog,
  BCVEResultStatus,
  BCVERun,
  Dir,
  File,
  SourceLocation,
  ToolID,
  StandaloneRun,
  CommitDescription
} from "@types";

import { writeJSONFile, writeLogFile } from "@util";
import * as validation from "./validation";
import * as cp from "child_process";

export const DEFAULT_TIMEOUT = 10 * 60 * 1000;

export type DriverState<AuxDriverState> = {
  toolID: ToolID;
  bcve: BCVE;
  commitDescription: CommitDescription;
  tmp: Dir;
  log: BCVELog;
  aux: AuxDriverState;
};
export async function simpleSpawn(
  bin: File,
  args: string[],
  cwd: Dir,
  timeout: number,
  run: BCVERun
): Promise<void> {
  return new Promise((resolve, reject) => {
    let start = +new Date();
    let expectedEnd = start + timeout;
    console.log(
      `Spawning child-process in ${cwd}: '${bin} ${args.join(
        " "
      )}' with timeout at ${new Date(
        expectedEnd
      ).toLocaleString()} after ${timeout / 1000}s`
    );
    let isDone = false;
    function finish(e?: any) {
      if (isDone) {
        return;
      }
      console.log(
        `Spawned child-process finished${
          e ? `with error: ${JSON.stringify(e)}` : ""
        }`
      );
      isDone = true;
      if (e) {
        reject(e);
      } else {
        resolve();
      }
    }
    try {
      let p = cp.spawn(bin, args, {
        cwd,
        timeout
      });
      p.on("error", finish);
      p.on("exit", () => {
        let end = +new Date();
        let delta = end - start;
        if (delta > timeout) {
          run.status = BCVEResultStatus.TIMEOUT;
          finish(`Timeout after ${delta / 1000}s`);
        } else {
          finish();
        }
      });
      setTimeout(() => p.kill(), timeout);
    } catch (e) {
      finish(e);
    }
  });
}
export async function driver<AuxDriverState>(
  bcves: BCVE[],
  resultDir: Dir,
  toolID: string,
  setup: (state: DriverState<AuxDriverState>) => Promise<void>,
  run: (state: DriverState<AuxDriverState>) => Promise<void>,
  requiresLocalSourceDirectory = true
) {
  let errors: string[];
  let allErrors: string[] = [];
  function logError(msg: string) {
    console.error(`ERROR: ${msg}`);
    errors.push(msg);
    allErrors.push(msg);
  }
  try {
    let runs = 0;
    let expectedRunCount = bcves.length * 2;
    for await (const bcve of bcves) {
      for await (const { commitKind, commitDescription } of [
        { commitKind: "postPatch", commitDescription: bcve.postPatch },
        { commitKind: "patchBase", commitDescription: bcve.patchBase }
      ]) {
        try {
          errors = [];
          let tmp = fs.mkdtempSync(path.join(os.tmpdir(), `${toolID}-run-`));
          runs++;
          let state: DriverState<AuxDriverState> = {
            toolID,
            bcve,
            commitDescription,
            tmp,
            log: {
              runs: []
            } as BCVELog,
            aux: {} as AuxDriverState
          };

          let resultFile = path.join(
            resultDir,
            `${toolID}_${bcve.CVE}_${commitKind}.json`
          );

          try {
            console.info(
              `Preparing run of ${toolID} on ${bcve.CVE}/${commitKind} (run ${runs}/${expectedRunCount}).`
            );
            if (
              !commitDescription.commit ||
              !commitDescription.localSourceDirectory
            ) {
              throw new Error(
                `Missing BCVE content in ${JSON.stringify(bcve)}`
              );
            }
            if (fs.existsSync(resultFile)) {
              console.info(
                `Result file run of ${toolID} on ${bcve.CVE}/${commitKind} already exists at ${resultFile}. Skipping run.`
              );
              continue;
            }
            if (
              !fs.existsSync(commitDescription.localSourceDirectory) &&
              requiresLocalSourceDirectory
            ) {
              logError(
                `Local source directory ${commitDescription.localSourceDirectory} does not exist. Please download before attempting analysis.`
              );
              let run = makeInitialStandaloneRun(state, undefined);
              run.status = BCVEResultStatus.NO_SOURCES;
              state.log.runs.push(run);
              writeLogFile(resultFile, state.log);
              continue;
            }
            if (setup) {
              await setup(state);
            }
          } catch (e) {
            logError(
              `Exception while setting up run of ${toolID} on ${bcve.CVE}/${commitKind}: ${e.message}.`
            );
            logError(e.stack);
            continue;
          }

          try {
            console.info(
              `Runing ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp} (run ${runs}/${expectedRunCount}).`
            );
            await run(state);
            console.info(
              `Done runing ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}.`
            );
          } catch (e) {
            let timeouts = state.log.runs.filter(
              r => r.status == BCVEResultStatus.TIMEOUT
            );
            if (timeouts.length > 0) {
              logError(
                `Timeout while running ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}.`
              );
            }
            if (state.log.runs.length !== timeouts.length) {
              logError(
                `Exception while running ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}: ${e.message}.`
              );
              logError(e.stack);
            }
            state.log.runs.forEach(r => {
              if (r.status === undefined) {
                r.status = BCVEResultStatus.CRASH;
              }
            });
          } finally {
            if (state.log.runs.every(r => r.status === undefined)) {
              logError(
                `Sanity: Not writing results for ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}: missing 'result.status'.`
              );
            } else {
              console.info(
                `Writing results for ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp} to ${resultFile}.`
              );
              try {
                writeJSONFile(resultFile, state.log);
                validation.validateLog(state.log);
              } catch (e) {
                // ignore, but keep the file on disk
                logError(`Failure while writing ${resultFile}: ${e.message}`);
              }
            }
          }
        } catch (e) {
          logError(
            `Uncaught exception while running ${toolID} on ${bcve.CVE}.`
          );
          throw e;
        } finally {
          if (errors.length > 0) {
            console.error(`Errors for ${toolID} on ${bcve.CVE}/${commitKind}:`);
            console.error(errors.map(e => `    - ${e}`).join("\n"));
          }
        }
      }
    }
  } finally {
    if (allErrors.length > 0) {
      console.error(`All errors (${allErrors.length}):`);
      console.error(allErrors.map(e => `    - ${e}`).join("\n"));
    }
    console.log(`Finished running ${toolID} for ${bcves.length} BCVEs`);
  }
}

export function isKnownTPAlertLocation(location: SourceLocation, bcve: BCVE) {
  return bcve.patchBase.weaknesses.some(w => {
    if (w.format !== "simple") {
      throw new Error("Can only handle weaknesses in the 'simple' format");
    }
    return (
      w.location.file === location.file && w.location.line === location.line
    );
  });
}

export function makeInitialStandaloneRun(
  state: DriverState<any>,
  reproduction: string
): StandaloneRun {
  return {
    CVE: state.bcve.CVE,
    commit: state.commitDescription.commit,
    toolID: state.toolID,
    reproduction,
    alerts: undefined,
    status: undefined
  };
}
