import * as path from "path";
import * as fs from "fs";
import * as os from "os";
import {
  BCVE,
  BCVELog,
  BCVEResultStatus,
  BCVERun,
  Dir,
  File,
  ToolID,
  StandaloneRun,
  CommitDescription,
  CVEString
} from "./types";

import { readLogFile, writeJSONFile, writeLogFile } from "./util";
import * as validation from "./validation";
import * as cp from "child_process";

export const DEFAULT_TIMEOUT = 30 * 60 * 1000;

export type DriverState<AuxDriverState> = {
  toolID: ToolID;
  bcve: BCVE;
  commitDescription: CommitDescription;
  tmp: Dir;
  log: BCVELog;
  aux: AuxDriverState;
};
export async function simpleSpawn(
  bin: File,
  args: string[],
  cwd: Dir,
  timeout: number,
  run: BCVERun
): Promise<void> {
  return new Promise((resolve, reject) => {
    let start = +new Date();
    let expectedEnd = start + timeout;
    console.log(
      `Spawning child-process in ${cwd}: '${bin} ${args.join(
        " "
      )}' with timeout at ${new Date(
        expectedEnd
      ).toLocaleString()} after ${timeout / 1000}s`
    );
    let isDone = false;
    function finish(e?: any) {
      if (isDone) {
        return;
      }
      console.log(
        `Spawned child-process finished${
          e ? `with error: ${JSON.stringify(e)}` : ""
        }`
      );
      isDone = true;
      if (e) {
        reject(e);
      } else {
        resolve();
      }
    }
    try {
      let p = cp.spawn(bin, args, {
        cwd,
        timeout
      });
      let showOutputs = false;
      // XXX need to attach a listener to avoid occasional subprocess failures?!
      p.stdout.on("data", function(data) {
        if (showOutputs) {
          console.log("stdout: " + data.toString());
        }
      });
      p.stderr.on("data", function(data) {
        if (showOutputs) {
          console.log("stderr: " + data.toString());
        }
      });
      p.on("error", finish);
      p.on("exit", () => {
        let end = +new Date();
        let delta = end - start;
        if (delta > timeout) {
          run.status = BCVEResultStatus.TIMEOUT;
          finish(`Timeout after ${delta / 1000}s`);
        } else {
          finish();
        }
      });
      setTimeout(() => p.kill(), timeout);
    } catch (e) {
      finish(e);
    }
  });
}

function getResultFile(
  resultDir: Dir,
  toolID: ToolID,
  cve: CVEString,
  commitKind: string
) {
  return path.join(resultDir, `${toolID}_${cve}_${commitKind}.json`);
}

export async function driver<AuxDriverState>(
  bcves: BCVE[],
  resultDir: Dir,
  toolID: string,
  setup: (state: DriverState<AuxDriverState>) => Promise<void>,
  run: (state: DriverState<AuxDriverState>) => Promise<void>,
  requiresLocalSourceDirectory = true
) {
  let errors: string[];
  let allErrors: string[] = [];
  function logError(msg: string) {
    console.error(`ERROR: ${msg}`);
    errors.push(msg);
    allErrors.push(msg);
  }
  try {
    let runs = 0;
    let expectedRunCount = bcves.length * 2;
    for await (const bcve of bcves) {
      for await (const { commitKind, commitDescription, otherCommitKind } of [
        {
          commitKind: "patchBase",
          commitDescription: bcve.patchBase,
          otherCommitKind: "postPatch"
        },
        {
          commitKind: "postPatch",
          commitDescription: bcve.postPatch,
          otherCommitKind: "patchBase"
        }
      ]) {
        try {
          errors = [];
          let tmp = fs.mkdtempSync(path.join(os.tmpdir(), `${toolID}-run-`));
          runs++;
          let state: DriverState<AuxDriverState> = {
            toolID,
            bcve,
            commitDescription,
            tmp,
            log: {
              runs: []
            } as BCVELog,
            aux: {} as AuxDriverState
          };
          let resultFile = getResultFile(
            resultDir,
            toolID,
            bcve.CVE,
            commitKind
          );

          try {
            console.info(
              `Preparing run of ${toolID} on ${bcve.CVE}/${commitKind} (run ${runs}/${expectedRunCount}).`
            );
            if (
              !commitDescription.commit ||
              !commitDescription.localSourceDirectory
            ) {
              throw new Error(
                `Missing BCVE content in ${JSON.stringify(bcve)}`
              );
            }
            if (fs.existsSync(resultFile)) {
              console.info(
                `Result file run of ${toolID} on ${bcve.CVE}/${commitKind} already exists at ${resultFile}. Skipping run.`
              );
              continue;
            }
            try {
              let siblingResultFile = getResultFile(
                resultDir,
                toolID,
                bcve.CVE,
                otherCommitKind
              );

              if (fs.existsSync(siblingResultFile)) {
                let siblingResult = readLogFile(siblingResultFile);
                let sibling = siblingResult.runs[0];
                if (
                  (siblingResult.runs.length === 1 &&
                    sibling.status === BCVEResultStatus.TIMEOUT) ||
                  sibling.status === BCVEResultStatus.CRASH
                ) {
                  console.info(
                    `Result file run of ${toolID} on ${bcve.CVE}/${otherCommitKind} has status '${sibling.status}' (see ${resultFile}). Assuming run of ${bcve.CVE}/${commitKind} behaves the same.`
                  );

                  let result: BCVELog = {
                    runs: [
                      {
                        toolID: toolID,
                        CVE: bcve.CVE,
                        commit: commitDescription.commit,
                        status: sibling.status
                      }
                    ]
                  };
                  sibling.commit = commitDescription.commit;
                  sibling.reproduction = undefined;
                  writeJSONFile(resultFile, result);
                  continue;
                }
              }
            } catch (e) {
              logError(
                `Exception while checking for sibling status: ${e.message}`
              );
              // ignore and continue
            }

            if (
              !fs.existsSync(commitDescription.localSourceDirectory) &&
              requiresLocalSourceDirectory
            ) {
              logError(
                `Local source directory ${commitDescription.localSourceDirectory} does not exist. Please download before attempting analysis.`
              );
              let run = makeInitialStandaloneRun(state, undefined);
              run.status = BCVEResultStatus.NO_SOURCES;
              state.log.runs.push(run);
              writeLogFile(resultFile, state.log);
              continue;
            }
            if (setup) {
              await setup(state);
            }
          } catch (e) {
            logError(
              `Exception while setting up run of ${toolID} on ${bcve.CVE}/${commitKind}: ${e.message}.`
            );
            logError(e.stack);
            continue;
          }

          try {
            console.info(
              `Runing ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp} (run ${runs}/${expectedRunCount}).`
            );
            await run(state);
            console.info(
              `Done runing ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}.`
            );
          } catch (e) {
            let timeouts = state.log.runs.filter(
              r => r.status == BCVEResultStatus.TIMEOUT
            );
            if (timeouts.length > 0) {
              logError(
                `Timeout while running ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}.`
              );
            }
            if (
              state.log.runs.length === 0 ||
              state.log.runs.length !== timeouts.length
            ) {
              logError(
                `Exception while running ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}: ${e.message}.`
              );
              logError(e.stack);
            }
            state.log.runs.forEach(r => {
              if (r.status === undefined) {
                r.status = BCVEResultStatus.CRASH;
              }
            });
          } finally {
            if (state.log.runs.length === 0) {
              logError(
                `Sanity: No runs for ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}?`
              );
            } else if (state.log.runs.every(r => r.status === undefined)) {
              logError(
                `Sanity: Not writing results for ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp}: missing 'result.status'.`
              );
            } else {
              console.info(
                `Writing results for ${toolID} on ${bcve.CVE}/${commitKind} in ${tmp} to ${resultFile}.`
              );
              try {
                writeJSONFile(resultFile, state.log);
                validation.validateLog(state.log);
              } catch (e) {
                // ignore, but keep the file on disk
                logError(`Failure while writing ${resultFile}: ${e.message}`);
              }
            }
          }
        } catch (e) {
          logError(
            `Uncaught exception while running ${toolID} on ${bcve.CVE}.`
          );
          throw e;
        } finally {
          if (errors.length > 0) {
            console.error(`Errors for ${toolID} on ${bcve.CVE}/${commitKind}:`);
            console.error(errors.map(e => `    - ${e}`).join("\n"));
          }
        }
      }
    }
  } finally {
    if (allErrors.length > 0) {
      console.error(`All errors (${allErrors.length}):`);
      console.error(allErrors.map(e => `    - ${e}`).join("\n"));
    }
    console.log(`Finished running ${toolID} for ${bcves.length} BCVEs`);
  }
}

export function makeInitialStandaloneRun(
  state: DriverState<any>,
  reproduction: string
): StandaloneRun {
  return {
    CVE: state.bcve.CVE,
    commit: state.commitDescription.commit,
    toolID: state.toolID,
    reproduction,
    alerts: undefined,
    status: undefined
  };
}
