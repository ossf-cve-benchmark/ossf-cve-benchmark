# Benchmark CVEs

This directory contains benchmark CVE entries, encoded as a JSON file per
CVE. A benchmark CVE entry consists of a CVE identifier, and some additional
information that isn't normally available in an ordinary CVE.

For a CVE to be eligible for as a benchmark CVE, the CVE must be
publicly accessible and it must be for open-source software.

The basic content of a benchmark CVE is described by the following
(informal) TypeScript type:

```typescript
{
  CVE: CVEString;
  state: CVEState;
  repository: URLString;
  patchBase: {
    commit: CommitID;
    weaknesses: {
      location: SourceLocation;
      explanation: string;
    }[];
  };
  postPatch: {
    commit: CommitID;
  };
}
```

The formal benchmark CVE format is defined by this [JSON-schema](../schemas/BCVE.schema.json).

With an an example instantiation being:

```json
{
    "CVE": "CVE-2020-8203",
    "state": "ACCEPT",
    "repository": "https://github.com/lodash/lodash.git",
    "patchBase": {
        "commit": "e7b28ea6cb17b4ca021e7c9d66218c8c89782f32",
        "weaknesses": [
            {
                "location": {
                    "file": "lodash.js",
                    "line": 2559
                },
                "explanation": "Prototype pollution in utility function"
            }
        ]
    },
    "postPatch": {
        "commit": "c84fe82760fb2d3e03a63379b297a1cc1a2fce12"
    }
}
```

Additionally. A benchmark CVE is considered "complete" if all of the following hold:

- `state` is `ACCEPTED`, meaning that no further work on the CVE is expected, and that the vulnerability has been acknowleged
- `patchBase` exists and contains at least one relevant weakness, meaning that the vulnerability was caused by a source code mistake
- `postPatch` exists and contains zero relevant weaknesses, meaning that the vulnerability has beeen fixed properly

With this definition, the ideal analysis tool produces at least one
relevant alert on the `patchBase` commit, and all such alerts are gone
in the `postPatch` commit for a complete benchmark CVE. This means
that the ideal analysis tool could have prevented the vulnerability in
the first place, and that it recognizes the patch as sufficient.

Incomplete benchmark CVEs are not as valuable as complete benchmark
CVEs for benchmarking due to their inherent ambiguities: "Do the
maintainers agree that this is an unintended behaviour?", "Could an
analysis have produced an alert?", "Should the analysis produce fewer
alerts on the `postPatch` commit?". As a consequence, incomplete
benchmark CVEs are ignored by default in the tooling of this project
(in particular `bin/cli export`).


## Theory: commits related to a CVE

Generally speaking, there are five different kinds of commits that are
relevant for a CVE. This classification also suits the situation where
multiple parallel versions of an application are vulnerable to the
same CVE.

- `preIntroduction`: the commit just before the vulnerability was introduced
- `postIntroduction`: the commit that introducses the vulnerability
- `patchBase`: the commit that a complete patch is applied to
- `prePatch`: the commit just before the vulnerability is fixed
- `postPatch`: the commit that fixes the vulnerability

That is: the `preIntroduction` and `postPatch` commits are not
expected to be affected by the vulnerability described in the CVE,
while `postIntroduction`, `patchBase`, and `prePatch` are.

## Practice: commits related to a CVE

In practice, it may be hard to find the exact `preIntroduction` and
`postIntroduction` commits. 

Ideally, security fixes are small, surgical commits, resulting in
`patchBase` being equal to `prePatch`. Practically speaking, a
security fix may involve several commits that together enables
`postPatch` to address the vulnerability completely. That is, there
may be several commit between `patchBase` and `prePatch` that each
partially address the vulnerability.

Finally, it may be the case that it is later discovered that
`preIntroduction` or `postPatch` actually are vulnerable to the CVE as
well for reasons that were unknown at the time the CVE was published.

## Examples of bencmark CVEs

- TODO: no `postPatch`
- TODO: improper `postPatch`
- TODO: DISPUTED/REJECTED
- TODO: multiple locations
- TODO: multiple reasons

