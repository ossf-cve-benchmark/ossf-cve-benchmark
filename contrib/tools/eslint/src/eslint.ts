/**
 * This is the eslint driver for the CVE Benchmarker.
 * See ../README.md for how to use this driver.
 *
 * This driver is the reference driver for the CVE Benchmarker.
 */

import * as fs from "fs-extra";
import * as path from "path";
import {
  Analyze,
  AnalyzeParams,
  drive,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVEAlert,
  BCVEResultStatus,
  CVEString,
  Dir,
  File,
  RuleID
} from "../../../../src/types";
import { readJSONFile, writeJSONFile } from "../../../../src/util";

/**
 * Gets an ESLint configuration object for the provided CVE.
 */
function getESLintConfig(_cve: CVEString) {
  // TODO make this use external data for the CVEs where this default config wrongly leads to parse errors
  return {
    parserOptions: {
      ecmaVersion: 12,
      sourceType: "module",
      ecmaFeatures: {
        globalReturn: true,
        jsx: true
      }
    },
    plugins: ["security", "security-node"],
    extends: ["plugin:security/recommended", "plugin:security-node/recommended"]
  };
}

/**
 * Converts the eslint rule violations in an output file to an array of alerts.
 *
 * @param eslintOutputFile the output from an eslint run (`--format json`)
 * @param localSourceDirectory the directory to make absolute violation locations relative to
 */
function convertEslintOutputToAlerts(
  eslintOutputFile: File,
  localSourceDirectory: Dir
): BCVEAlert[] {
  /*
    eslint outputs a json array with an array of rule violations per file:

    ```
    [ ...
      { "filePath": "/tmp/foo.js",
        "messages": [ ... { "ruleId": "xss", "line": 42 } ... ]
      }
      ... ]
  */
  type ESLintMessage = { ruleId: RuleID; line: number };
  type ESLintFileOutput = { filePath: File; messages: ESLintMessage[] };
  let eslintOutput: ESLintFileOutput[] = readJSONFile(eslintOutputFile);
  return eslintOutput.flatMap((f: ESLintFileOutput): BCVEAlert[] =>
    f.messages
      .filter(m => m.ruleId !== undefined /* parsing error */)
      .map(m => ({
        ruleID: m.ruleId,
        location: {
          file: path.relative(localSourceDirectory, f.filePath),
          line: m.line
        }
      }))
  );
}
/**
 * @param eslintDir The directory where `npm i eslint ...` has been run.
 * @return The analyze function that the driver invokes for each CVE
 */
function makeAnalyzeFunction(eslintDir: Dir): Analyze {
  return async function ({
    bcve,
    commitDescription,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    // STEP 1: preparations for the run
    let eslintConfig = getESLintConfig(bcve.CVE);
    let eslint = path.join(
      eslintDir,
      "node_modules",
      "eslint",
      "bin",
      "eslint.js"
    );
    let tmpEslintDir = path.join(tmp, "eslint");
    // XXX this is a terrible hack to make the plugins be resolved appropriately wrt. the provided config file!
    fs.copySync(eslintDir, tmpEslintDir);
    let configFile = path.join(tmpEslintDir, "config.json");
    writeJSONFile(configFile, eslintConfig);

    let outputFile: File = path.join(tmp, "output.json"),
      args: string[] = [
        "--no-inline-config",
        "--no-eslintrc",
        "--config",
        configFile,
        "--output-file",
        outputFile,
        "--format",
        "json",
        "--no-error-on-unmatched-pattern",
        commitDescription.localSourceDirectory
      ];

    setReproduction(`# navigate to project
cd ${tmp}
# run eslint
${eslint} ${args.join(" ")}`);

    // STEP 2: run eslint
    try {
      await simpleSpawn(
        eslint,
        args,
        tmp,
        config.tools[toolID].timeout,
        setStatus
      );
    } catch (e) {
      if (e.code !== 1) {
        throw e;
      }
      // ignore exit code -1: it simply means that some rules matched
    }

    // STEP 3: process the eslint outputs
    setAlerts(
      convertEslintOutputToAlerts(
        outputFile,
        commitDescription.localSourceDirectory
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  };
}
let { toolID, bcves, config } = getDriverCommandlineInputs();
drive(
  bcves,
  config,
  toolID,
  makeAnalyzeFunction(config.tools[toolID].options.eslintDir)
)
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
