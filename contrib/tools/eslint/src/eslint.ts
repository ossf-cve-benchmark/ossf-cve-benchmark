import "module-alias/register";
import {
  AlertClassification,
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Dir,
  File,
  RuleID,
  SourceLocation
} from "@types";
import { readJSONFile, readExportFile, writeJSONFile } from "@util";
import * as path from "path";
import {
  driver,
  DriverState,
  DEFAULT_TIMEOUT,
  simpleSpawn,
  isKnownTPAlertLocation,
  makeInitialStandaloneRun
} from "@driver";
import * as cp from "child_process";

function inferClassification(
  bcve: BCVE,
  location: SourceLocation,
  _rule: RuleID
): AlertClassification {
  if (isKnownTPAlertLocation(location, bcve)) {
    return AlertClassification.ASSUMED_TP;
  }
  return AlertClassification.UNDECIDED;
}

async function runWithDriver(
  toolID: string,
  bcves: BCVE[],
  resultDir: Dir,
  eslintDir: Dir
) {
  type AuxState = {
    eslint: File;
    config: File;
  };

  type State = DriverState<AuxState>;
  async function setup(state: State) {
    let eslintConfig = {
      parserOptions: {
        ecmaVersion: 12,
        sourceType: "module",
        ecmaFeatures: {
          globalReturn: true,
          jsx: true
        }
      },
      plugins: ["security", "security-node"],
      extends: [
        "plugin:security/recommended",
        "plugin:security-node/recommended"
      ]
    };
    state.aux.eslint = path.join(
      eslintDir,
      "node_modules",
      "eslint",
      "bin",
      "eslint.js"
    );
    let tmpEslintDir = path.join(state.tmp, "eslint");
    // XXX this is a terrible hack to make the plugins be resolved appropriately wrt. the provided config file!
    cp.execFileSync("cp", ["-r", `${eslintDir}/.`, tmpEslintDir]);
    let configFile = path.join(tmpEslintDir, "config.json");
    writeJSONFile(configFile, eslintConfig);
    state.aux.config = configFile;
    if (state.aux.config === undefined) {
      throw new Error();
    }
  }
  async function run(state: State) {
    let outputFile: File = path.join(state.tmp, "output.json"),
      args: string[] = [
        "--no-inline-config",
        "--no-eslintrc",
        "--config",
        state.aux.config,
        "--output-file",
        outputFile,
        "--format",
        "json", // https://eslint.org/docs/user-guide/formatters/#json
        state.commitDescription.localSourceDirectory
      ];

    let reproduction = [
      `cd ${state.tmp}`,
      `${state.aux.eslint} ${args.join(" ")}`
    ].join(" &&\n ");

    let run = makeInitialStandaloneRun(state, reproduction);
    state.log.runs.push(run);
    try {
      await simpleSpawn(
        state.aux.eslint,
        args,
        state.tmp,
        DEFAULT_TIMEOUT,
        run
      );
    } catch (e) {
      if (e.code !== 1) {
        throw e;
      }
      // ignore exit code -1: it simply means that some rules matched
    }
    type ESLintMessage = { ruleId: RuleID; message: string; line: number };
    type ESLintFileOutput = { filePath: string; messages: ESLintMessage[] };
    let eslintOutput: ESLintFileOutput[] = readJSONFile(outputFile);

    run.alerts = eslintOutput.flatMap((f: ESLintFileOutput): BCVEAlert[] =>
      f.messages.map(
        (m: ESLintMessage): BCVEAlert => {
          let location = {
            file: path.relative(
              state.commitDescription.localSourceDirectory,
              f.filePath
            ),
            line: m.line
          };
          return {
            format: "simple",
            ruleID:
              m.ruleId ||
              m.message /* A parsing error message do not have a rule ID*/,
            explanation: m.message,
            location,
            classification: inferClassification(state.bcve, location, m.ruleId)
          };
        }
      )
    );
    run.status = BCVEResultStatus.SUCCESS;
  }
  return driver(bcves, resultDir, toolID, setup, run);
}

let eslintDir = process.argv[2],
  toolID = process.argv[3],
  targetsFile = process.argv[4],
  resultDir = process.argv[5],
  bcves = readExportFile(targetsFile);
runWithDriver(toolID, bcves, resultDir, eslintDir)
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
