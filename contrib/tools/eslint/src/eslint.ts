/**
 * This is the eslint driver for the CVE Benchmarker.
 * See ../README.md for how to use this driver.
 *
 * This driver is the reference driver for the CVE Benchmarker.
 */

import * as fs from "fs-extra";
import * as path from "path";
import {
  Analyze,
  AnalyzeParams,
  drive,
  execFileSyncWithImprovedExceptionMessage,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVEAlert,
  BCVEResultStatus,
  CVEString,
  Dir,
  DriverConfig,
  File,
  RuleID
} from "../../../../src/persistent-types";
import { readJSONFile, writeJSONFile } from "../../../../src/util";

function main() {
  let { toolID, config } = getDriverCommandlineInputs();
  let driverConfig: DriverConfig<{ eslintDir: string }> = config.tools[toolID];
  let analyzer = makeAnalyzeFunction(
    driverConfig.options.eslintDir,
    driverConfig.timeout
  );

  drive(analyzer)
    .then(() => process.exit(0))
    .catch(e => {
      console.error(e);
      process.exit(1);
    });
}
main();

/**
 * @param eslintDir The directory where `npm i eslint ...` has been run.
 * @param timeout The number of milliseconds the analysis can run before it's forced to stop.
 * @return The analyze function that the driver invokes for each CVE
 */
function makeAnalyzeFunction(eslintDir: Dir, timeout: number): Analyze {
  return async function ({
    bcve,
    commitDescription,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    // STEP 1: preparations for the run
    let eslintConfig = getESLintConfig(bcve.CVE);
    let eslint = path.join(
        eslintDir,
        "node_modules",
        "eslint",
        "bin",
        "eslint.js"
      ),
      // avoid relying on the `#!/usr/bin/env node` of eslint.js: explicitly reuse the parent `node` executable
      node = process.argv[0];

    // check if `eslint` works as expected
    execFileSyncWithImprovedExceptionMessage(node, [eslint, "--help"]);

    let tmpEslintDir = path.join(tmp, "eslint");
    // XXX this is a terrible hack to make the plugins be resolved appropriately wrt. the provided config file!
    fs.copySync(eslintDir, tmpEslintDir);
    let configFile = path.join(tmpEslintDir, "config.json");
    writeJSONFile(configFile, eslintConfig);

    let outputFile: File = path.join(tmp, "output.json"),
      args: string[] = [
        eslint,
        "--no-inline-config",
        "--no-eslintrc",
        "--config",
        configFile,
        "--output-file",
        outputFile,
        "--format",
        "json",
        "--no-error-on-unmatched-pattern",
        commitDescription.localSourceDirectory
      ];

    setReproduction(`# navigate to project
cd ${tmp}
# run eslint
${node} ${args.join(" ")}`);

    // STEP 2: run eslint
    try {
      await simpleSpawn(node, args, tmp, timeout, setStatus);
    } catch (e) {
      if (e.code !== 1) {
        throw e;
      }
      // ignore exit code -1: it simply means that some rules matched
    }

    // STEP 3: process the eslint outputs
    setAlerts(
      convertEslintOutputToAlerts(
        outputFile,
        commitDescription.localSourceDirectory
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  };
}

/**
 * Gets an ESLint configuration object for the provided CVE.
 */
function getESLintConfig(_cve: CVEString) {
  // TODO make this use external data for the CVEs where this default config wrongly leads to parse errors
  return {
    parserOptions: {
      ecmaVersion: 12,
      sourceType: "module",
      ecmaFeatures: {
        globalReturn: true,
        jsx: true
      }
    },
    plugins: ["security", "security-node"],
    extends: ["plugin:security/recommended", "plugin:security-node/recommended"]
  };
}

/**
 * Converts the eslint rule violations in an output file to an array of alerts.
 *
 * @param eslintOutputFile the output from an eslint run (`--format json`)
 * @param localSourceDirectory the directory to make absolute violation locations relative to
 */
function convertEslintOutputToAlerts(
  eslintOutputFile: File,
  localSourceDirectory: Dir
): BCVEAlert[] {
  /*
    eslint outputs a json array with an array of rule violations per file:

    ```
    [ ...
      { "filePath": "/tmp/foo.js",
        "messages": [ ... { "ruleId": "xss", "line": 42 } ... ]
      }
      ... ]
  */
  type ESLintMessage = { ruleId: RuleID; line: number };
  type ESLintFileOutput = { filePath: File; messages: ESLintMessage[] };
  let eslintOutput: ESLintFileOutput[] = readJSONFile(eslintOutputFile);
  let alertsMap: { [id: string]: {ruleId: string, lines: number[]} } = {};
  let result: BCVEAlert[] = [];
  eslintOutput.forEach((f: ESLintFileOutput) =>
      f.messages
          .filter(m => !!m.ruleId /* parsing error */)
          .forEach(m => {
              let filePath = path.relative(localSourceDirectory, f.filePath);
              if (!alertsMap[filePath]) {
                  alertsMap[filePath] = {ruleId: m.ruleId, lines: []};
              }
              alertsMap[filePath].lines.push(m.line);
          })
  );
  Object.keys(alertsMap).forEach(e => result.push({
      ruleID: alertsMap[e].ruleId,
      location: {
          file: e,
          lines: alertsMap[e].lines
      }
  }));
  return result;
}
