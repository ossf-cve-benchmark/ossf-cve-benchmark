import * as cp from "child_process";
import * as path from "path";
import {
  DEFAULT_TIMEOUT,
  driver,
  DriverState,
  makeInitialStandaloneRun
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Dir,
  File,
  RuleID
} from "../../../../src/types";
import { readExportFile } from "../../../../src/util";

async function runWithDriver(
  toolID: string,
  bcves: BCVE[],
  resultDir: Dir,
  runsh: File
) {
  type AuxState = {
    run: File;
  };

  type State = DriverState<AuxState>;
  async function setup(state: State) {
    state.aux.run = runsh;
  }
  async function run(state: State) {
    // this is awfully slow on any realistic project!?
    let args: string[] = [
        "pmd",
        "-dir",
        state.commitDescription.localSourceDirectory,
        "-language",
        "ecmascript",
        "-rulesets",
        "category/ecmascript/errorprone.xml",
        "-format",
        "json",
        "-failOnViolation",
        "false"
      ],
      reproduction = [
        `cd ${state.tmp}`,
        `${state.aux.run} ${args.join(" ")}`
      ].join(" &&\n ");
    let run = makeInitialStandaloneRun(state, reproduction);
    state.log.runs.push(run);

    let start = +new Date(),
      timeout = DEFAULT_TIMEOUT,
      response: string;

    try {
      response = cp
        .execFileSync(state.aux.run, args, {
          cwd: state.tmp,
          timeout
        })
        .toString("utf8");
    } catch (e) {
      let end = +new Date();
      let delta = end - start;
      if (delta > timeout) {
        run.status = BCVEResultStatus.TIMEOUT;
      }
      throw e;
    }

    let output = JSON.parse(response);

    type PMDViolation = {
      rule: RuleID;
      description: string;
      beginline: number;
    };
    type PMDOutput = {
      files: { filename: File; violations: PMDViolation[] }[];
    };
    run.alerts = output.flatMap((f: PMDOutput): BCVEAlert[] =>
      f.files.flatMap(({ filename, violations }): BCVEAlert[] =>
        violations.map(v => {
          let location = {
            file: path.relative(
              state.commitDescription.localSourceDirectory,
              filename
            ),
            line: v.beginline
          };
          return {
            format: "simple",
            ruleID: v.rule,
            explanation: v.description,
            location
          };
        })
      )
    );
    run.status = BCVEResultStatus.SUCCESS;
  }
  return driver(bcves, resultDir, toolID, setup, run);
}
let sourceanalyzer = process.argv[2],
  toolID = process.argv[3],
  targetsFile = process.argv[4],
  resultDir = process.argv[5],
  bcves = readExportFile(targetsFile);
runWithDriver(toolID, bcves, resultDir, sourceanalyzer)
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
