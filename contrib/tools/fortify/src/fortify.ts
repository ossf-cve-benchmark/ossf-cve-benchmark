import * as cp from "child_process";
import * as path from "path";
import {
  DEFAULT_TIMEOUT,
  driver,
  DriverState,
  makeInitialStandaloneRun,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Dir,
  File
} from "../../../../src/types";
import { readExportFile } from "../../../../src/util";

async function runWithDriver(
  toolID: string,
  bcves: BCVE[],
  resultDir: Dir,
  sourceanalyzer: File
) {
  type AuxState = {
    sourceanalyzer: File;
    fvdlReaderJq: string;
  };

  type State = DriverState<AuxState>;
  async function setup(state: State) {
    state.aux.sourceanalyzer = sourceanalyzer;
    /**
     * jq script to be used with xq to read an fvdl file into a simple alert format.
     *
     * Emits an object of the following form per alert in the project at
     *  /home/user/my-projects/project-x:
     *
     * { "base": "/home/user", "alerts": [["XSS", "Through DOM", "my-projects/project-x/file.js", 42]] }
     *
     * (it is not clear why .base is chosen to be the home directory)
     *
     * Although the string "UNKNOWN" is a possible output of the script, it
     *  should be considered a bug in the script whenever it appears.
     */
    let fvdlReaderJq = `
{
 alerts:
  [
   (.FVDL.Vulnerabilities.Vulnerability // [])[] |
   select(.ClassInfo) |
   [
    . as $parent |
    (.ClassInfo |
     # .alerts[][0]
     .Type // "UNKNOWN"
      # .alerts[][1]
      , .Subtype // ""
    )
     , (.AnalysisInfo.Unified.Trace |
        if type == "array" then . else [.] end |
        .[].Primary.Entry |
        if type == "array" then . else [.] end |
        .[] |
        select(.Node["@isDefault"] == "true" and .Node.SourceLocation) |
        .Node.SourceLocation |
        .["@path"]
         , .["@line"]) // ["UNKNOWN", -1]
   ]
  ]
   , base: .FVDL.Build.SourceBasePath
}
`;
    state.aux.fvdlReaderJq = fvdlReaderJq;
    // early syntax check
    cp.execFileSync("jq", ["-n", fvdlReaderJq]);
  }
  async function run(state: State) {
    let buildID = `build-${state.bcve.CVE}-${state.commitDescription.commit}`;
    let resultsFpr: File = path.join(state.tmp, "results.fpr"),
      logFile1 = path.join(state.tmp, "log1.log"),
      logFile2 = path.join(state.tmp, "log2.log"),
      args1: string[] = [
        `-Dcom.fortify.WorkingDirectory=${state.tmp}`,
        `-Dcom.fortify.sca.ProjectRoot=${state.tmp}`,
        "-logfile",
        logFile1,
        "-b",
        buildID,
        "-exclude",
        "node_modules/**/*",
        `${state.commitDescription.localSourceDirectory}/**/*.js`
      ],
      args2: string[] = [
        `-Dcom.fortify.WorkingDirectory=${state.tmp}`,
        `-Dcom.fortify.sca.ProjectRoot=${state.tmp}`,
        "-logfile",
        logFile2,
        "-b",
        buildID,
        "-scan",
        "-f",
        resultsFpr
      ];

    let reproduction = [
      `cd ${state.tmp}`,
      `${state.aux.sourceanalyzer} ${args1.join(" ")}`,
      `${state.aux.sourceanalyzer} ${args2.join(" ")}`
    ].join(" &&\n ");
    let run = makeInitialStandaloneRun(state, reproduction);
    state.log.runs.push(run);

    // analysis
    await simpleSpawn(
      state.aux.sourceanalyzer,
      args1,
      state.tmp,
      DEFAULT_TIMEOUT,
      run
    );
    await simpleSpawn(
      state.aux.sourceanalyzer,
      args2,
      state.tmp,
      DEFAULT_TIMEOUT,
      run
    );

    // hacky unwrapping of the results
    let fvdlFileName = "audit.fvdl",
      fvdlFile = path.join(state.tmp, fvdlFileName);
    cp.execFileSync(
      "unzip",
      ["-j", resultsFpr, fvdlFileName, "-d", state.tmp],
      {
        cwd: state.tmp
      }
    );
    let parsedFvdl = cp
      .execFileSync("xq", [state.aux.fvdlReaderJq, fvdlFile], {
        cwd: state.tmp
      })
      .toString();
    type SimpleFVDLContent = {
      base: string;
      alerts: [string, string, string, string][];
    };
    type FVDLAlert = {
      fullType: string;
      file: File;
      line: number;
    };
    let simpleFVDLContent: SimpleFVDLContent = JSON.parse(parsedFvdl),
      fvdlObjects: FVDLAlert[] = simpleFVDLContent.alerts.map(
        ([type, subtype, file, line]) => ({
          fullType: `${type}${subtype ? `: ${subtype}` : ""}`,
          file: path.relative(
            state.commitDescription.localSourceDirectory,
            path.join(simpleFVDLContent.base, file)
          ),
          line: +line
        })
      );

    // processing results
    let alerts = fvdlObjects.map(
      (a: FVDLAlert): BCVEAlert => {
        let location = {
          file: a.file,
          line: a.line
        };
        return {
          format: "simple",
          ruleID: a.fullType,
          explanation: a.fullType,
          location
        };
      }
    );
    run.alerts = alerts;
    run.status = BCVEResultStatus.SUCCESS;
  }
  return driver(bcves, resultDir, toolID, setup, run);
}
let sourceanalyzer = process.argv[2],
  toolID = process.argv[3],
  targetsFile = process.argv[4],
  resultDir = process.argv[5],
  bcves = readExportFile(targetsFile);
runWithDriver(toolID, bcves, resultDir, sourceanalyzer)
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
