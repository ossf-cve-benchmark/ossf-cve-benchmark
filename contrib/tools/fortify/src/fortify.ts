import * as cp from "child_process";
import * as path from "path";
import {
  AnalyzeParams,
  drive,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Config,
  File
} from "../../../../src/types";

function analyzeWithDriver(
  toolID: string,
  bcves: BCVE[],
  config: Config,
  sourceanalyzer: File
): Promise<void> {
  async function analyze({
    bcve,
    commitDescription,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    /**
     * jq script to be used with xq to read an fvdl file into a simple alert format.
     *
     * Emits an object of the following form per alert in the project at
     *  /home/user/my-projects/project-x:
     *
     * { "base": "/home/user", "alerts": [["XSS", "Through DOM", "my-projects/project-x/file.js", 42]] }
     *
     * (it is not clear why .base is chosen to be the home directory)
     *
     * Although the string "UNKNOWN" is a possible output of the script, it
     *  should be considered a bug in the script whenever it appears.
     */
    let fvdlReaderJq = `
{
 alerts:
  [
   (.FVDL.Vulnerabilities.Vulnerability // [])[] |
   select(.ClassInfo) |
   [
    . as $parent |
    (.ClassInfo |
     # .alerts[][0]
     .Type // "UNKNOWN"
      # .alerts[][1]
      , .Subtype // ""
    )
     , (.AnalysisInfo.Unified.Trace |
        if type == "array" then . else [.] end |
        .[].Primary.Entry |
        if type == "array" then . else [.] end |
        .[] |
        select(.Node["@isDefault"] == "true" and .Node.SourceLocation) |
        .Node.SourceLocation |
        .["@path"]
         , .["@line"]) // ["UNKNOWN", -1]
   ]
  ]
   , base: .FVDL.Build.SourceBasePath
}
`;

    // early syntax check
    cp.execFileSync("jq", ["-n", fvdlReaderJq]);
    let buildID = `build-${bcve.CVE}-${commitDescription.commit}`;
    let resultsFpr: File = path.join(tmp, "results.fpr"),
      logFile1 = path.join(tmp, "log1.log"),
      logFile2 = path.join(tmp, "log2.log"),
      args1: string[] = [
        `-Dcom.fortify.WorkingDirectory=${tmp}`,
        `-Dcom.fortify.sca.ProjectRoot=${tmp}`,
        "-logfile",
        logFile1,
        "-b",
        buildID,
        "-exclude",
        "node_modules/**/*",
        `${commitDescription.localSourceDirectory}/**/*.js`
      ],
      args2: string[] = [
        `-Dcom.fortify.WorkingDirectory=${tmp}`,
        `-Dcom.fortify.sca.ProjectRoot=${tmp}`,
        "-logfile",
        logFile2,
        "-b",
        buildID,
        "-scan",
        "-f",
        resultsFpr
      ];

    let reproduction = [
      `cd ${tmp}`,
      `${sourceanalyzer} ${args1.join(" ")}`,
      `${sourceanalyzer} ${args2.join(" ")}`
    ].join(" &&\n ");
    setReproduction(reproduction);

    // analysis
    await simpleSpawn(
      sourceanalyzer,
      args1,
      tmp,
      config.tools[toolID].timeout,
      setStatus
    );
    await simpleSpawn(
      sourceanalyzer,
      args2,
      tmp,
      config.tools[toolID].timeout, // XXX the two uses of .timeout gives the tool twice the timeout time, a manual clock should be maintained here instead.
      setStatus
    );

    // hacky unwrapping of the results
    let fvdlFileName = "audit.fvdl",
      fvdlFile = path.join(tmp, fvdlFileName);
    cp.execFileSync("unzip", ["-j", resultsFpr, fvdlFileName, "-d", tmp], {
      cwd: tmp
    });
    let parsedFvdl = cp
      .execFileSync("xq", [fvdlReaderJq, fvdlFile], {
        cwd: tmp
      })
      .toString();
    type SimpleFVDLContent = {
      base: string;
      alerts: [string, string, string, string][];
    };
    type FVDLAlert = {
      fullType: string;
      file: File;
      line: number;
    };
    let simpleFVDLContent: SimpleFVDLContent = JSON.parse(parsedFvdl),
      fvdlObjects: FVDLAlert[] = simpleFVDLContent.alerts.map(
        ([type, subtype, file, line]) => ({
          fullType: `${type}${subtype ? `: ${subtype}` : ""}`,
          file: path.relative(
            commitDescription.localSourceDirectory,
            path.join(simpleFVDLContent.base, file)
          ),
          line: +line
        })
      );

    // processing results
    setAlerts(
      fvdlObjects.map(
        (a: FVDLAlert): BCVEAlert => {
          let location = {
            file: a.file,
            line: a.line
          };
          return {
            ruleID: a.fullType,
            location
          };
        }
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  }
  return drive(bcves, config, toolID, analyze);
}
let { toolID, bcves, config } = getDriverCommandlineInputs();
analyzeWithDriver(
  toolID,
  bcves,
  config,
  config.tools[toolID].options.sourceanalyzer
)
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
