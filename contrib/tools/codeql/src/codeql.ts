/**
 * This is the codeql driver for the CVE Benchmarker.
 * See ../README.md for how to use this driver.
 */

import * as cp from "child_process";
import * as fs from "fs";
import * as path from "path";
import * as sarif from "sarif";
import {
  AnalyzeParams,
  drive,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Config,
  Dir,
  File,
  RuleID
} from "../../../../src/types";
import { readJSONFile, writeJSONFile } from "../../../../src/util";

/**
 * @returns true iff file `query` has `@id <queryId>`.
 */
function hasQueryID(query: File, queryId: RuleID, codeql: File) {
  if (
    !query.endsWith(".ql") ||
    // huge performance improvement over running codeql on all ql files
    !fs.readFileSync(query, "utf8").includes(queryId)
  ) {
    return false;
  }
  let response = cp.execFileSync(codeql, [
    "resolve",
    "metadata",
    "--format",
    "json",
    query
  ]);
  let meta = JSON.parse(response);
  return meta.id === queryId;
}

/**
 * Searches a directory structure recursively for a query file with a specific id.
 *
 * @return the query file with the given id.
 */
function getQueryFileByID(queryId: RuleID, dir: Dir, codeql: File): File[] {
  const dirents = fs.readdirSync(dir, { withFileTypes: true });
  const files: File[] = dirents.flatMap((dirent: fs.Dirent): File[] => {
    if (dirent.isSymbolicLink() || dirent.name.startsWith(".")) {
      return [];
    }
    const res = path.resolve(dir, dirent.name);
    if (dirent.isDirectory()) {
      return getQueryFileByID(queryId, res, codeql);
    }
    if (hasQueryID(res, queryId, codeql)) {
      return [res];
    }
    return [];
  });
  return files;
}

/**
 * Gets the on-disk locations of the queries that are relevant for `bcve`.
 */
function getRelevantQueries(
  bcve: BCVE,
  options: ResolvedDriverOptions
): { language: string; files: File[] } {
  let info = options.cveInformation[bcve.CVE],
    packs = JSON.parse(
      cp.execFileSync(options.codeql, [
        "resolve",
        "qlpacks",
        ...(options.searchPath ? ["--search-path", options.searchPath] : []),
        "--format",
        "json"
      ])
    ),
    pack: Dir = packs[`codeql-${info.language}`]?.[0]; // TODO support multiple packs?
  if (pack === undefined) {
    throw new Error(`Could not find qlpack for '${info.language}'`);
  }
  return {
    language: info.language,
    files: info.queries.map(queryId => {
      let files = getQueryFileByID(queryId, pack, options.codeql);
      if (files.length === 0) {
        throw new Error(`Could not find query with id: ${queryId}`);
      }
      if (files.length > 1) {
        throw new Error(`Found ${files.length} queries with id: ${queryId}`);
      }
      return files[0];
    })
  };
}

function analyzeWithDriver(
  options: ResolvedDriverOptions,
  timeout?: number
): Promise<void> {
  async function analyze({
    bcve,
    commitDescription,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    let logdir = path.join(tmp, "logs"),
      queries = getRelevantQueries(bcve, options);
    fs.mkdirSync(logdir);
    if (queries.files.length === 0) {
      setStatus(BCVEResultStatus.UNSUPPORTED_CVE);
      return;
    }
    let sarifFile: File = path.join(tmp, "results.sarif"),
      databaseDir: Dir = path.join(tmp, "database");
    let queryCompileArgs = ["query", "compile", ...queries.files],
      databaseCreateArgs = [
        "database",
        "create",
        "--logdir",
        logdir,
        "--source-root",
        commitDescription.localSourceDirectory,
        "--language",
        queries.language,
        databaseDir
      ],
      databaseAnalyzeArgs = [
        "database",
        "analyze",
        "--logdir",
        logdir,
        "--format",
        "sarifv2.1.0",
        "--output",
        sarifFile,
        databaseDir,
        ...queries.files
      ];

    let reproduction = [
      `cd ${tmp}`,
      `${options.codeql} ${queryCompileArgs.join(" ")}`,
      `${options.codeql} ${databaseCreateArgs.join(" ")}`,
      `${options.codeql} ${databaseAnalyzeArgs.join(" ")}`
    ].join(" &&\n ");
    setReproduction(reproduction);

    // compile queries ahead of time with a fixed time limit, without influencing the permitted analysis time
    await simpleSpawn(
      options.codeql,
      queryCompileArgs,
      tmp,
      60 * 60 * 1000,
      setStatus
    );

    // analysis
    await simpleSpawn(
      options.codeql,
      databaseCreateArgs,
      tmp,
      timeout,
      setStatus
    );
    await simpleSpawn(
      options.codeql,
      databaseAnalyzeArgs,
      tmp,
      timeout, // XXX the two uses of `timeout` gives the tool twice the timeout time, a manual clock should be maintained here instead.
      setStatus
    );

    let sarif: sarif.Log = readJSONFile(sarifFile);
    writeJSONFile("/home/esben/tmp/results.sarif.json", sarif);
    setAlerts(
      sarif.runs[0].results.map(
        (r: sarif.Result): BCVEAlert => {
          let loc = getAlertLocation(r),
            file = loc.artifactLocation.uri,
            line = loc.region.startLine,
            location = { file, line };
          return {
            location,
            ruleID: r.ruleId
          };
        }
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  }
  return drive(analyze);
}

function getAlertLocation(result: sarif.Result): sarif.PhysicalLocation {
  switch (result.ruleId) {
    case "js/shell-command-constructed-from-inputs": {
      // minor compatibility correction:
      // this alert appears at the command-construction location, and links to the command-execution from within its message
      return result.relatedLocations.find(l => l.id === 2).physicalLocation;
    }
    default:
      return result.locations[0].physicalLocation;
  }
}

type CVEInformation = {
  [CVE: string]: {
    language: string;
    queries: RuleID[];
  };
};
type DriverOptions = {
  codeql: File;
  searchPath?: Dir;
  cveInformation: File;
};
type ResolvedDriverOptions = {
  codeql: File;
  searchPath?: Dir;
  cveInformation: CVEInformation;
};

let { toolID, config } = getDriverCommandlineInputs(),
  options: DriverOptions = config.tools[toolID].options,
  resolvedOptions: ResolvedDriverOptions = {
    codeql: options.codeql,
    searchPath: options.searchPath,
    cveInformation: readJSONFile(options.cveInformation)
  };
let p = analyzeWithDriver(resolvedOptions, config.tools[toolID].timeout);
p.then(() => process.exit(0)).catch(e => {
  console.error(e);
  process.exit(1);
});
