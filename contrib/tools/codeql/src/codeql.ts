import * as cp from "child_process";
import * as fs from "fs";
import * as I from "immutable";
import * as path from "path";
import * as sarif from "sarif";
import {
  AnalyzeParams,
  drive,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Config,
  CVEString,
  Dir,
  File,
  RuleID
} from "../../../../src/types";
import { readJSONFile } from "../../../../src/util";

let aux = (() => {
  function getAuxFile(auxDir: Dir, name: File | Dir): File | Dir {
    let aux = path.join(auxDir, name);
    if (!fs.existsSync(aux)) {
      throw new Error(`File ${aux} does not exist.`);
    }
    return aux;
  }

  return {
    getCVERelevantQueryIDs(cve: CVEString, auxDir: Dir): RuleID[] {
      return (
        (readJSONFile(getAuxFile(auxDir, "cve-to-query.json")) as any)[cve] ||
        []
      );
    },
    getCodeQL(version: string, auxDir: Dir): File {
      return (readJSONFile(getAuxFile(auxDir, "paths.json")) as any)[version]
        .codeql;
    },
    getQlLangDir(language: string, version: string, auxDir: Dir): Dir {
      return (readJSONFile(getAuxFile(auxDir, "paths.json")) as any)[version]
        .ql[language];
    }
  };
})();

function inferLanguage(bcve: BCVE, auxDir: Dir): string {
  let queryIDs = aux.getCVERelevantQueryIDs(bcve.CVE, auxDir);
  let short2long: { [short: string]: string } = {
    js: "javascript",
    cpp: "cpp",
    java: "java",
    py: "python",
    go: "go",
    cs: "csharp"
  };
  let languages = I.Set(queryIDs)
    .map(id => id.split("/")[0])
    .map(short => short2long[short])
    .toArray();

  if (languages.length === 1) {
    return languages[0];
  }

  let relevantExtensions = I.Set(
    bcve.prePatch.weaknesses.map(w => {
      return path.extname(w.location.file).toLowerCase();
    })
  );
  let javascriptAnalysisExtensions = I.Set([
    // See com.semmle.js.extractor.FileExtractor.java
    // HTML
    ".htm",
    ".html",
    ".xhtm",
    ".xhtml",
    ".vue",
    // JS
    ".js",
    ".jsx",
    ".mjs",
    ".cjs",
    ".es6",
    ".es",
    // JSON
    ".json",
    // TYPESCRIPT
    ".ts",
    ".tsx"
  ]);

  if (!relevantExtensions.intersect(javascriptAnalysisExtensions).isEmpty()) {
    languages.push("javascript");
  }
  if (I.Set(languages).size !== 1) {
    throw new Error(
      `Inffered languages ${JSON.stringify(languages)} for ${JSON.stringify(
        I.Set(languages).sort().toArray()
      )}`
    );
  }
  return languages[0];
}
function inferBuildCommand(_language: string, _bcve: BCVE): string {
  return undefined;
}

function hasQueryID(query: File, queryId: RuleID, codeql: File) {
  let response = cp.execFileSync(codeql, [
    "resolve",
    "metadata",
    "--format",
    "json",
    query
  ]);
  let meta = JSON.parse(response);
  return meta.id === queryId;
}

function getQueryFile(queryId: RuleID, dir: Dir, codeql: File): File[] {
  const dirents = fs.readdirSync(dir, { withFileTypes: true });
  const files: File[] = dirents.flatMap((dirent: fs.Dirent): File[] => {
    if (dirent.isSymbolicLink() || dirent.name.startsWith(".")) {
      return [];
    }
    const res = path.resolve(dir, dirent.name);
    if (dirent.isDirectory()) {
      return getQueryFile(queryId, res, codeql);
    }
    if (
      dirent.name.endsWith(".ql") &&
      // huge performance improvement over running codeql on all ql files
      fs.readFileSync(res, "utf8").includes(queryId) &&
      hasQueryID(res, queryId, codeql)
    ) {
      return [res];
    }
    return [];
  });
  return files;
}

function inferQueryLocations(
  qlLangDir: Dir,
  bcve: BCVE,
  auxDir: Dir,
  version: string
): File[] {
  return aux.getCVERelevantQueryIDs(bcve.CVE, auxDir).map(queryId => {
    let files = getQueryFile(
      queryId,
      qlLangDir,
      aux.getCodeQL(version, auxDir)
    );
    if (files.length === 0) {
      throw new Error(`Could not find query with id: ${queryId}`);
    }
    if (files.length > 1) {
      throw new Error(`Found ${files.length} queries with id: ${queryId}`);
    }
    return files[0];
  });
}

function analyzeWithDriver(
  toolID: string,
  bcves: BCVE[],
  config: Config,
  auxDir: Dir,
  version: string
): Promise<void> {
  async function analyze({
    bcve,
    commitDescription,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    let language = inferLanguage(bcve, auxDir),
      buildCommand = inferBuildCommand(language, bcve),
      logdir = path.join(tmp, "logs"),
      qlLangDir = aux.getQlLangDir(language, version, auxDir),
      queryFiles = inferQueryLocations(qlLangDir, bcve, auxDir, version),
      codeql = aux.getCodeQL(version, auxDir);
    fs.mkdirSync(logdir);
    if (queryFiles.length === 0) {
      setStatus(BCVEResultStatus.UNSUPPORTED_CVE);
      return;
    }
    let sarifFile: File = path.join(tmp, "results.sarif"),
      databaseDir: Dir = path.join(tmp, "database");
    let databaseCreateArgs = [
        "database",
        "create",
        "--logdir",
        logdir,
        "--source-root",
        commitDescription.localSourceDirectory,
        "--language",
        language,
        databaseDir
      ],
      databaseAnalyzeArgs = [
        "database",
        "analyze",
        "--logdir",
        logdir,
        "--full-library-path",
        qlLangDir,
        "--format",
        "sarifv2.1.0",
        "--output",
        sarifFile,
        databaseDir,
        queryFiles.join(" ")
      ];
    if (buildCommand) {
      databaseCreateArgs.push("--command");
      databaseCreateArgs.push(buildCommand);
    }

    let reproduction = [
      `cd ${tmp}`,
      `${codeql} ${databaseCreateArgs.join(" ")}`,
      `${codeql} ${databaseAnalyzeArgs.join(" ")}`
    ].join(" &&\n ");
    setReproduction(reproduction);
    // analysis
    await simpleSpawn(
      codeql,
      databaseCreateArgs,
      tmp,
      config.tools[toolID].timeout,
      setStatus
    );
    await simpleSpawn(
      codeql,
      databaseAnalyzeArgs,
      tmp,
      config.tools[toolID].timeout, // XXX the two uses of .timeout gives the tool twice the timeout time, a manual clock should be maintained here instead.
      setStatus
    );

    let sarif: sarif.Log = readJSONFile(sarifFile);
    setAlerts(
      sarif.runs[0].results.map(
        (r: sarif.Result): BCVEAlert => {
          let loc = r.locations[0].physicalLocation,
            file = loc.artifactLocation.uri,
            line = loc.region.startLine,
            location = { file, line };
          return {
            location,
            ruleID: r.ruleId
          };
        }
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  }
  return drive(bcves, config, toolID, analyze);
}

let { toolID, bcves, config } = getDriverCommandlineInputs(),
  options = config.tools[toolID].options;
let p = analyzeWithDriver(
  toolID,
  bcves,
  config,
  options.auxDir,
  options.version
);
p.then(() => process.exit(0)).catch(e => {
  console.error(e);
  process.exit(1);
});
