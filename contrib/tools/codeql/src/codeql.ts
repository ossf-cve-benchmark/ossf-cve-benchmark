/**
 * This is the codeql driver for the CVE Benchmarker.
 * See ../README.md for how to use this driver.
 */

import * as fs from "fs";
import * as path from "path";
import * as sarif from "sarif";
import {
  AnalyzeParams,
  drive,
  execFileSyncWithImprovedExceptionMessage,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Dir,
  File,
  RuleID
} from "../../../../src/persistent-types";
import { readJSONFile } from "../../../../src/util";

type CodeQLMetaData = {
  kind: string;
  precision: string;
  id: string;
  tags: string;
};

/**
 * Cache for `getMetaData/2`
 */
const metadataCache: Map<File, CodeQLMetaData> = new Map();
/**
 * @returns the codeql metadata for `query`.
 */
function getMetaData(query: File, codeql: File): CodeQLMetaData {
  if (!metadataCache.has(query)) {
    metadataCache.set(
      query,
      JSON.parse(
        execFileSyncWithImprovedExceptionMessage(codeql, [
          "resolve",
          "metadata",
          "--format",
          "json",
          query
        ]).toString()
      )
    );
  }
  return metadataCache.get(query);
}

/**
 * @returns true iff file `query` has `@id <queryId>`.
 */
function hasQueryID(query: File, queryId: RuleID, codeql: File) {
  if (
    !query.endsWith(".ql") ||
    // huge performance improvement over running codeql on all ql files
    !fs.readFileSync(query, "utf8").includes(queryId)
  ) {
    return false;
  }
  let meta = getMetaData(query, codeql);
  return meta.id === queryId;
}

/**
 * @returns true iff file `query` has `@tags external/cwe/cwe-<cweNumber>`.
 */
function queryHasCweNumber(query: File, cweNumber: number, codeql: File) {
  if (!query.endsWith(".ql")) {
    return false;
  }

  let content = fs.readFileSync(query, "utf8");
  if (
    // huge performance improvement over running codeql on all ql files
    !["", "0", "00"].some(prefix =>
      content.includes(`external/cwe/cwe-${prefix}${cweNumber}`)
    )
  ) {
    return false;
  }
  let meta = getMetaData(query, codeql);
  return meta.tags.split(" ").some((tag: string) => {
    let match = /external\/cwe\/cwe-(\d+)/.exec(tag);
    return match && +match[1] === cweNumber;
  });
}

/**
 * Searches a directory structure recursively for a query file with a specific id.
 *
 * @returns the query file with the given id.
 */
function getQueryFileByID(queryId: RuleID, dir: Dir, codeql: File): File[] {
  const dirents = fs.readdirSync(dir, { withFileTypes: true });
  const files: File[] = dirents.flatMap((dirent: fs.Dirent): File[] => {
    if (dirent.isSymbolicLink() || dirent.name.startsWith(".")) {
      return [];
    }
    const res = path.resolve(dir, dirent.name);
    if (dirent.isDirectory()) {
      return getQueryFileByID(queryId, res, codeql);
    }
    if (hasQueryID(res, queryId, codeql)) {
      return [res];
    }
    return [];
  });
  return files;
}

/**
 * Searches a directory structure recursively for a query file with a specific CWE number.
 *
 * @returns the query files with the given CWE.
 */
function getQueryFilesByCWENumber(
  cweNumber: number,
  dir: Dir,
  codeql: File
): File[] {
  const dirents = fs.readdirSync(dir, { withFileTypes: true });
  const files: File[] = dirents.flatMap((dirent: fs.Dirent): File[] => {
    if (dirent.isSymbolicLink() || dirent.name.startsWith(".")) {
      return [];
    }
    const res = path.resolve(dir, dirent.name);
    if (dirent.isDirectory()) {
      return getQueryFilesByCWENumber(cweNumber, res, codeql);
    }
    if (queryHasCweNumber(res, cweNumber, codeql)) {
      return [res];
    }
    return [];
  });
  return files;
}

/**
 * Gets the on-disk locations of the queries that are relevant for `bcve`.
 */
function getRelevantQueries(
  bcve: BCVE,
  options: ResolvedDriverOptions
): { language: string; files: File[] } {
  let language = "javascript", // TODO de-hardcode this
    packs = JSON.parse(
      execFileSyncWithImprovedExceptionMessage(options.codeql, [
        "resolve",
        "qlpacks",
        ...(options.searchPath ? ["--search-path", options.searchPath] : []),
        "--format",
        "json"
      ]).toString()
    ),
    pack: Dir = packs[`codeql-${language}`]?.[0];
  if (pack === undefined) {
    throw new Error(`Could not find qlpack for '${language}'`);
  }
  let files;
  if (options.cveInformation && options.cveInformation[bcve.CVE]) {
    files = options.cveInformation[bcve.CVE].queries.flatMap(queryId =>
      getQueryFileByID(queryId, pack, options.codeql)
    );
  } else {
    files = bcve.CWEs.flatMap(cwe =>
      getQueryFilesByCWENumber(+/CWE-(\d+)/.exec(cwe)[1], pack, options.codeql)
    ).filter(query => {
      let meta = getMetaData(query, options.codeql);
      return (
        !query.includes("/ql/src/experimental/") &&
        ["problem", "path-problem"].includes(meta.kind) &&
        ["medium", "high", "very-high"].includes(meta.precision)
      );
    });
  }
  return {
    language,
    files
  };
}

function analyzeWithDriver(
  options: ResolvedDriverOptions,
  timeout?: number
): Promise<void> {
  async function analyze({
    bcve,
    commitDescription,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    // check if `codeql` works as expected
    execFileSyncWithImprovedExceptionMessage(options.codeql, ["--help"]);

    let logdir = path.join(tmp, "logs"),
      queries = getRelevantQueries(bcve, options),
      sarifFile: File = path.join(tmp, "results.sarif"),
      databaseDir: Dir = path.join(tmp, "database");

    if (queries.files.length === 0) {
      setStatus(BCVEResultStatus.UNSUPPORTED);
      return;
    }
    fs.mkdirSync(logdir);
    let queryCompileArgs = ["query", "compile", ...queries.files],
      databaseCreateArgs = [
        "database",
        "create",
        "--logdir",
        logdir,
        "--source-root",
        commitDescription.localSourceDirectory,
        "--language",
        queries.language,
        databaseDir
      ],
      databaseAnalyzeArgs = [
        "database",
        "analyze",
        "--logdir",
        logdir,
        "--format",
        "sarifv2.1.0",
        "--output",
        sarifFile,
        databaseDir,
        ...queries.files
      ];

    let reproduction = [
      `cd ${tmp}`,
      `${options.codeql} ${queryCompileArgs.join(" ")}`,
      `${options.codeql} ${databaseCreateArgs.join(" ")}`,
      `${options.codeql} ${databaseAnalyzeArgs.join(" ")}`
    ].join(" &&\n ");
    setReproduction(reproduction);

    // compile queries ahead of time with a fixed time limit, without influencing the permitted analysis time
    await simpleSpawn(
      options.codeql,
      queryCompileArgs,
      tmp,
      60 * 60 * 1000,
      setStatus
    );

    // analysis
    await simpleSpawn(
      options.codeql,
      databaseCreateArgs,
      tmp,
      timeout,
      setStatus
    );
    await simpleSpawn(
      options.codeql,
      databaseAnalyzeArgs,
      tmp,
      timeout, // TODO the two uses of `timeout` gives the tool twice the timeout time, a manual clock should be maintained here instead.
      setStatus
    );

    let sarif: sarif.Log = readJSONFile(sarifFile);
    setAlerts(
      sarif.runs[0].results.map(
        (r: sarif.Result): BCVEAlert => {
          let loc = getAlertLocation(r);
          return {
            location: {
              file: loc.artifactLocation.uri,
              lineStart: loc.region.startLine,
              lineEnd: loc.region.endLine
            },
            ruleID: r.ruleId
          };
        }
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  }
  return drive(analyze);
}

function getAlertLocation(result: sarif.Result): sarif.PhysicalLocation {
  switch (result.ruleId) {
    case "js/shell-command-constructed-from-input": {
      // minor compatibility correction:
      // this alert appears at the command-construction location, and links to the command-execution from within its message
      return result.relatedLocations.find(l => l.id === 2).physicalLocation;
    }
    default:
      return result.locations[0].physicalLocation;
  }
}

/**
 * A map from CVE to query ids. Used for forcing the driver to used a
 * specific query for a CVE instead of using heuristics to select the
 * relevant queries.
 */
type CVEInformation = {
  [CVE: string]: {
    queries: RuleID[];
  };
};

/**
 * The options provided in config.json for this driver.
 */
type DriverOptions = {
  /**
   * The codeql binary
   */
  codeql: File;
  /**
   * Controls the qlpack that `codeql` makes use of.
   */
  searchPath?: Dir;

  /**
   * The path to a JSON file that map CVE to query ids. Used for forcing
   * the driver to used a specific query for a CVE instead of using
   * heuristics to select the relevant queries.
   */
  cveInformation?: File;
};

type ResolvedDriverOptions = {
  codeql: File;
  searchPath?: Dir;
  cveInformation?: CVEInformation;
};

let { toolID, config } = getDriverCommandlineInputs(),
  options: DriverOptions = config.tools[toolID].options,
  resolvedOptions: ResolvedDriverOptions = {
    codeql: options.codeql,
    searchPath: options.searchPath,
    cveInformation: options.cveInformation
      ? readJSONFile(options.cveInformation)
      : undefined
  };
let p = analyzeWithDriver(resolvedOptions, config.tools[toolID].timeout);
p.then(() => process.exit(0)).catch(e => {
  console.error(e);
  process.exit(1);
});
