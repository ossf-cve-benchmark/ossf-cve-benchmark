import * as cp from "child_process";
import * as fs from "fs";
import * as I from "immutable";
import * as path from "path";
import * as sarif from "sarif";
import {
  DEFAULT_TIMEOUT,
  driver,
  DriverState,
  makeInitialStandaloneRun,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  CVEString,
  Dir,
  File,
  RuleID
} from "../../../../src/types";
import { readExportFile, readJSONFile } from "../../../../src/util";

let aux = (() => {
  function getAuxFile(auxDir: Dir, name: File | Dir): File | Dir {
    let aux = path.join(auxDir, name);
    if (!fs.existsSync(aux)) {
      throw new Error(`File ${aux} does not exist.`);
    }
    return aux;
  }

  return {
    getCVERelevantQueryIDs(cve: CVEString, auxDir: Dir): RuleID[] {
      return readJSONFile(getAuxFile(auxDir, "cve-to-query.json"))[cve] || [];
    },
    getCodeQL(version: string, auxDir: Dir): File {
      return readJSONFile(getAuxFile(auxDir, "paths.json"))[version].codeql;
    },
    getQlLangDir(language: string, version: string, auxDir: Dir): Dir {
      return readJSONFile(getAuxFile(auxDir, "paths.json"))[version].ql[
        language
      ];
    }
  };
})();

function inferLanguage(bcve: BCVE, auxDir: Dir): string {
  let queryIDs = aux.getCVERelevantQueryIDs(bcve.CVE, auxDir);
  let short2long: { [short: string]: string } = {
    js: "javascript",
    cpp: "cpp",
    java: "java",
    py: "python",
    go: "go",
    cs: "csharp"
  };
  let languages = I.Set(queryIDs)
    .map(id => id.split("/")[0])
    .map(short => short2long[short])
    .toArray();

  if (languages.length === 1) {
    return languages[0];
  }

  let relevantExtensions = I.Set(
    bcve.patchBase.weaknesses.map(w => {
      if (w.format !== "simple") {
        throw new Error("Can only handle weaknesses in the 'simple' format");
      }
      return path.extname(w.location.file).toLowerCase();
    })
  );
  let javascriptAnalysisExtensions = I.Set([
    // See com.semmle.js.extractor.FileExtractor.java
    // HTML
    ".htm",
    ".html",
    ".xhtm",
    ".xhtml",
    ".vue",
    // JS
    ".js",
    ".jsx",
    ".mjs",
    ".cjs",
    ".es6",
    ".es",
    // JSON
    ".json",
    // TYPESCRIPT
    ".ts",
    ".tsx"
  ]);

  if (!relevantExtensions.intersect(javascriptAnalysisExtensions).isEmpty()) {
    languages.push("javascript");
  }
  if (I.Set(languages).size !== 1) {
    throw new Error(
      `Inffered languages ${JSON.stringify(languages)} for ${JSON.stringify(
        I.Set(languages)
          .sort()
          .toArray()
      )}`
    );
  }
  return languages[0];
}
function inferBuildCommand(_language: string, _bcve: BCVE): string {
  return undefined;
}

function getQueryFile(queryID: RuleID, qlLangDir: Dir) {
  try {
    let query = cp
      .execFileSync("grep", [
        "-Hlr",
        "--include",
        "*.ql",
        ` * @id ${queryID}$`,
        qlLangDir
      ])
      .toString()
      .trim();
    return query;
  } catch (e) {
    return undefined;
  }
}
function inferQueryLocations(qlLangDir: Dir, bcve: BCVE, auxDir: Dir): File[] {
  return aux
    .getCVERelevantQueryIDs(bcve.CVE, auxDir)
    .map(queryId => getQueryFile(queryId, qlLangDir))
    .filter(f => f !== undefined);
}

async function runWithDriver(
  toolID: string,
  bcves: BCVE[],
  resultDir: Dir,
  version: string,
  auxDir: Dir
) {
  type AuxState = {
    language: string;
    buildCommand: string;
    qlLangDir: Dir;
    queryFiles: File[];
    logdir: Dir;
    codeql: File;
  };
  type State = DriverState<AuxState>;
  async function setup(state: State) {
    state.aux.language = inferLanguage(state.bcve, auxDir);
    state.aux.buildCommand = inferBuildCommand(state.aux.language, state.bcve);
    state.aux.logdir = path.join(state.tmp, "logs");
    state.aux.qlLangDir = aux.getQlLangDir(state.aux.language, version, auxDir);
    state.aux.queryFiles = inferQueryLocations(
      state.aux.qlLangDir,
      state.bcve,
      auxDir
    );
    state.aux.codeql = aux.getCodeQL(version, auxDir);
    fs.mkdirSync(state.aux.logdir);
  }
  async function run(state: State) {
    if (state.aux.queryFiles.length === 0) {
      let run = makeInitialStandaloneRun(state, undefined);
      run.status = BCVEResultStatus.UNSUPPORTED_CVE;
      state.log.runs.push(run);

      return;
    }
    let sarifFile: File = path.join(state.tmp, "results.sarif"),
      databaseDir: Dir = path.join(state.tmp, "database");

    let databaseCreateArgs = [
        "database",
        "create",
        "--logdir",
        state.aux.logdir,
        "--source-root",
        state.commitDescription.localSourceDirectory,
        "--language",
        state.aux.language,
        databaseDir
      ],
      databaseAnalyzeArgs = [
        "database",
        "analyze",
        "--logdir",
        state.aux.logdir,
        "--full-library-path",
        state.aux.qlLangDir,
        "--format",
        "sarifv2.1.0",
        "--output",
        sarifFile,
        databaseDir,
        state.aux.queryFiles.join(" ")
      ];
    if (state.aux.buildCommand) {
      databaseCreateArgs.push("--command");
      databaseCreateArgs.push(state.aux.buildCommand);
    }

    let reproduction = [
      `cd ${state.tmp}`,
      `${state.aux.codeql} ${databaseCreateArgs.join(" ")}`,
      `${state.aux.codeql} ${databaseAnalyzeArgs.join(" ")}`
    ].join(" &&\n ");
    let run = makeInitialStandaloneRun(state, reproduction);
    state.log.runs.push(run);

    // analysis
    await simpleSpawn(
      state.aux.codeql,
      databaseCreateArgs,
      state.tmp,
      DEFAULT_TIMEOUT,
      run
    );
    await simpleSpawn(
      state.aux.codeql,
      databaseAnalyzeArgs,
      state.tmp,
      DEFAULT_TIMEOUT,
      run
    );

    let sarif: sarif.Log = readJSONFile(sarifFile);
    run.alerts = sarif.runs[0].results.map(
      (r: sarif.Result): BCVEAlert => {
        let loc = r.locations[0].physicalLocation,
          file = loc.artifactLocation.uri,
          line = loc.region.startLine,
          location = { file, line };
        return {
          format: "simple",
          explanation: r.message.text,
          location,
          ruleID: r.ruleId
        };
      }
    );
    run.status = BCVEResultStatus.SUCCESS;
  }
  return driver(bcves, resultDir, toolID, setup, run);
}

let auxDir = process.argv[2],
  version = process.argv[3],
  toolID = process.argv[4],
  targetsFile = process.argv[5],
  resultDir = process.argv[6],
  bcves = readExportFile(targetsFile);

let p = runWithDriver(toolID, bcves, resultDir, version, auxDir);
p.then(() => process.exit(0)).catch(e => {
  console.error(e);
  process.exit(1);
});
