import "module-alias/register";
import * as path from "path";
import {
  AlertClassification,
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Dir,
  File,
  RuleID,
  SourceLocation
} from "@types";
import { readExportFile, readJSONFile } from "@util";
import {
  driver,
  DEFAULT_TIMEOUT,
  DriverState,
  simpleSpawn,
  isKnownTPAlertLocation,
  makeInitialStandaloneRun
} from "@driver";

type ToolOptions = {
  [version: string]: { njsscan: File };
};

function inferClassification(
  bcve: BCVE,
  location: SourceLocation,
  _rule: RuleID
): AlertClassification {
  if (isKnownTPAlertLocation(location, bcve)) {
    return AlertClassification.ASSUMED_TP;
  }
  return AlertClassification.UNDECIDED;
}

async function runWithDriver(
  toolID: string,
  bcves: BCVE[],
  resultDir: Dir,
  njsscan: File
) {
  type AuxState = {
    njsscan: File;
  };

  type State = DriverState<AuxState>;
  async function setup(state: State) {
    state.aux.njsscan = njsscan;
  }
  async function run(state: State) {
    let outputFile: File = path.join(state.tmp, "output.json"),
      args: string[] = [
        "--json",
        "--output",
        outputFile,
        "--missing-control",
        state.commitDescription.localSourceDirectory
      ];

    let reproduction = [
      `cd ${state.tmp}`,
      `${state.aux.njsscan} ${args.join(" ")}`
    ].join(" &&\n ");
    let run = makeInitialStandaloneRun(state, reproduction);
    state.log.runs.push(run);

    try {
      await simpleSpawn(
        state.aux.njsscan,
        args,
        state.tmp,
        DEFAULT_TIMEOUT,
        run
      );
    } catch (e) {
      if (e.code !== 1) {
        throw e;
      }
      // ignore exit code -1: it simply means that some rules matched
    }

    type RuleWithAlerts = {
      file_path: File;
      match_lines: [number];
    };
    type RuleWithMetadataAndAlerts = {
      files: RuleWithAlerts[];
      metadata: { description: string };
    };
    type Output = {
      nodejs: {
        [rule: string]: RuleWithMetadataAndAlerts;
      };
    };
    let output: Output = readJSONFile(outputFile);
    run.alerts = Object.entries(output.nodejs).flatMap(
      ([rule, match]: [RuleID, RuleWithMetadataAndAlerts]): BCVEAlert[] =>
        match.files === undefined
          ? []
          : match.files.map(m => {
              let location = {
                file: path.relative(
                  state.commitDescription.localSourceDirectory,
                  m.file_path
                ),
                line: m.match_lines[0]
              };
              return {
                format: "simple",
                ruleID: rule,
                explanation: match.metadata.description,
                location,
                classification: inferClassification(state.bcve, location, rule)
              };
            })
    );
    run.status = BCVEResultStatus.SUCCESS;
  }
  return driver(bcves, resultDir, toolID, setup, run);
}
let njsscan = process.argv[2],
  toolID = process.argv[3],
  targetsFile = process.argv[4],
  resultDir = process.argv[5],
  bcves = readExportFile(targetsFile);
runWithDriver(toolID, bcves, resultDir, njsscan)
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
