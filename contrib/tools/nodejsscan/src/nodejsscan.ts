import * as path from "path";
import {
  AnalyzeParams,
  drive,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  Config,
  File,
  RuleID
} from "../../../../src/types";
import { readJSONFile } from "../../../../src/util";

function analyzeWithDriver(
  toolID: string,
  bcves: BCVE[],
  config: Config,
  njsscan: File
): Promise<void> {
  async function analyze({
    commitDescription,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    let outputFile: File = path.join(tmp, "output.json"),
      args: string[] = [
        "--json",
        "--output",
        outputFile,
        "--missing-control",
        commitDescription.localSourceDirectory
      ];

    let reproduction = [`cd ${tmp}`, `${njsscan} ${args.join(" ")}`].join(
      " &&\n "
    );
    setReproduction(reproduction);
    try {
      await simpleSpawn(
        njsscan,
        args,
        tmp,
        config.tools[toolID].timeout,
        setStatus
      );
    } catch (e) {
      if (e.code !== 1) {
        throw e;
      }
      // ignore exit code -1: it simply means that some rules matched
    }

    type RuleWithAlerts = {
      file_path: File;
      match_lines: [number];
    };
    type RuleWithMetadataAndAlerts = {
      files: RuleWithAlerts[];
      metadata: { description: string };
    };
    type Output = {
      nodejs: {
        [rule: string]: RuleWithMetadataAndAlerts;
      };
    };
    let output: Output = readJSONFile(outputFile);
    setAlerts(
      Object.entries(output.nodejs).flatMap(
        ([rule, match]: [RuleID, RuleWithMetadataAndAlerts]): BCVEAlert[] =>
          match.files === undefined
            ? []
            : match.files.map(m => {
                let location = {
                  file: path.relative(
                    commitDescription.localSourceDirectory,
                    m.file_path
                  ),
                  line: m.match_lines[0]
                };
                return {
                  format: "simple",
                  ruleID: rule,
                  explanation: match.metadata.description,
                  location
                };
              })
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  }
  return drive(bcves, config, toolID, analyze);
}
let { toolID, bcves, config } = getDriverCommandlineInputs();
analyzeWithDriver(toolID, bcves, config, config.tools[toolID].options.njsscan)
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
