import * as http from "http";
import * as path from "path";
import * as fs from "fs";
import * as url from "url";
import {
  File,
  BCVE,
  CVEString,
  CommitID,
  CommitDescription,
  ToolID,
  RuleID,
  CWEString
} from "../../../../../src/persistent-types";
import * as ClientTypes from "../shared/shared-types";

function makePermalink(repository: string, commit: CommitID) {
  let githubRepoPattern = /^https:\/\/github.com\/([^/]+)\/([^/]+)\.git$/;
  let github = repository.match(githubRepoPattern);
  if (github) {
    let [, owner, repo] = github;
    return `https://github.com/${owner}/${repo}/commit/${commit}`;
  }
  return undefined; // TODO support non-github.com URLs
}
function makeCommitData(
  cve: CVEString,
  repository: string,
  commit: CommitDescription
): ClientTypes.CommitData {
  return {
    CVE: cve,
    commitID: commit.commit,
    permalink: makePermalink(repository, commit.commit)
  };
}
function buildTargetsMap(bcves: BCVE[]): TargetsMap {
  let weaknessLocations = bcves
    .flatMap(bcve =>
      [bcve.prePatch, bcve.postPatch].map(c => ({
        CVE: bcve.CVE,
        commit: c.commit,
        weaknesses: c.weaknesses
      }))
    )
    .flatMap(g =>
      (g.weaknesses || [])
        .filter(w => !!w.location)
        .map(w => ({
          CVE: g.CVE,
          commit: g.commit,
          file: w.location.file,
          line: w.location.line
        }))
    );
  let targets = new Map();
  weaknessLocations.forEach(l => {
    if (!targets.has(l.CVE)) {
      targets.set(l.CVE, new Map());
    }

    let byCVE = targets.get(l.CVE);
    if (!byCVE.has(l.commit)) {
      byCVE.set(l.commit, new Map());
    }

    let byCVEAndCommit = byCVE.get(l.commit);
    if (!byCVEAndCommit.has(l.file)) {
      byCVEAndCommit.set(l.file, new Set());
    }

    let byCVEAndCommitAndFile = byCVEAndCommit.get(l.file);
    byCVEAndCommitAndFile.add(l.line);
  });
  return targets;
}

function buildRulesOnATargetMap(
  bcves: BCVE[],
  targets: TargetsMap
): RulesOnTargetMap {
  let unmapped = bcves.flatMap(bcve =>
    (bcve.prePatch.runs || []).flatMap(r =>
      (r.alerts || [])
        .filter(
          a =>
            a.location &&
            isOnTarget(
              bcve.CVE,
              bcve.prePatch.commit,
              a.location.file,
              a.location.lineStart,
              a.location.lineEnd,
              targets
            )
        )
        .map(a => ({
          CVE: bcve.CVE,
          toolID: r.toolID,
          ruleID: a.ruleID
        }))
    )
  );
  let rulesOnATarget = new Map();
  unmapped.forEach(u => {
    if (!rulesOnATarget.has(u.CVE)) {
      rulesOnATarget.set(u.CVE, new Map());
    }

    let byCVE = rulesOnATarget.get(u.CVE);
    if (!byCVE.has(u.toolID)) {
      byCVE.set(u.toolID, new Set());
    }

    let byCVEAndToolID = byCVE.get(u.toolID);
    byCVEAndToolID.add(u.ruleID);
  });
  return rulesOnATarget;
}

function isOnTarget(
  cve: CVEString,
  commit: CommitID,
  file: File,
  lineStart: number,
  lineEnd: number,
  targets: TargetsMap
): boolean {
  let targetLines = [...(targets.get(cve)?.get(commit)?.get(file) || [])];
  return targetLines.some(line => lineStart <= line && line <= lineEnd);
}

function isForRuleOnATarget(
  cve: CVEString,
  toolID: ToolID,
  ruleID: RuleID,
  rulesOnATarget: RulesOnTargetMap
): boolean {
  return !!rulesOnATarget.get(cve)?.get(toolID)?.has(ruleID);
}

type TargetsMap = Map<CVEString, Map<CommitID, Map<File, Set<number>>>>;
type RulesOnTargetMap = Map<CVEString, Map<ToolID, Set<RuleID>>>;
export default class ExploreServer {
  private targets: TargetsMap = new Map();
  private rulesOnATarget: RulesOnTargetMap = new Map();
  constructor(private bcves: BCVE[], private port: number) {
    this.targets = buildTargetsMap(bcves);
    this.rulesOnATarget = buildRulesOnATargetMap(bcves, this.targets);
  }

  resolveSourceFileRequest(CVE: CVEString, commit: CommitID, file: File) {
    if (file === undefined) {
      return undefined;
    }
    let bcve = this.bcves.find(bcve => bcve.CVE === CVE);
    if (bcve === undefined) {
      console.warn(`Could not find ${CVE} among the hosted CVEs.`);
      return undefined;
    }
    let localSourceDirectory;
    if (bcve.prePatch?.commit === commit) {
      localSourceDirectory = bcve.prePatch.localSourceDirectory;
    } else if (bcve.postPatch?.commit === commit) {
      localSourceDirectory = bcve.postPatch.localSourceDirectory;
    } else {
      console.warn(
        `Could not find commit ${commit} for ${CVE} among the hosted CVEs.`
      );
      return undefined;
    }

    if (localSourceDirectory === undefined) {
      console.warn(`No local sources for commit ${commit} of ${CVE}.`);
      return undefined;
    }

    let resolved = path.resolve(path.join(localSourceDirectory, file));
    if (!resolved.startsWith(localSourceDirectory)) {
      console.warn(
        `The ${file} for ${commit} of ${CVE} does not reside in ${localSourceDirectory}.`
      );
      return undefined;
    }
    if (!fs.existsSync(resolved)) {
      console.warn(
        `The file ${resolved} for ${commit} of ${CVE} does not exist.`
      );
      return undefined;
    }
    return resolved;
  }

  getCommits(bcves: BCVE[]): ClientTypes.CommitData[] {
    return bcves.flatMap(bcve => {
      let commits: ClientTypes.CommitData[] = [];
      if (bcve.prePatch) {
        commits.push(makeCommitData(bcve.CVE, bcve.repository, bcve.prePatch));
      }
      if (bcve.postPatch) {
        commits.push(makeCommitData(bcve.CVE, bcve.repository, bcve.postPatch));
      }
      return commits;
    });
  }

  getBCVE(cve: CVEString) {
    return this.bcves.find(bcve => bcve.CVE === cve);
  }

  getFiles(cve: CVEString, commit: CommitID): ClientTypes.FileData[] {
    function getFiles(commitDescription: CommitDescription): string[] {
      let alerts = (commitDescription.runs || []).flatMap(r =>
        (r.alerts || []).map(a => a.location?.file).filter(f => f !== undefined)
      );
      return alerts;
    }
    let bcve = this.getBCVE(cve);
    let files = [];
    if (bcve.prePatch && bcve.prePatch.commit === commit) {
      files.push(...getFiles(bcve.prePatch));
    }
    if (bcve.postPatch && bcve.postPatch.commit === commit) {
      files.push(...getFiles(bcve.postPatch));
    }
    files = Array.from(new Set(files));
    return files.map(f => ({ file: f }));
  }
  getAlertsForBCVE(bcve: BCVE): ClientTypes.Alert[] {
    let targets = this.targets,
      rulesOnATarget = this.rulesOnATarget;

    function addAlerts(
      commitDescription: CommitDescription, alerts: ClientTypes.Alert[]
    ): void {
      (commitDescription.runs || []).forEach(r =>
        (r.alerts || [])
          .filter(a => !!a.location)
          .forEach(a => alerts.push({
            CVE: bcve.CVE,
            commit: makeCommitData(
              bcve.CVE,
              bcve.repository,
              commitDescription
            ),
            file: a.location.file,
            lineStart: a.location.lineStart,
            lineEnd: a.location.lineEnd,
            toolID: r.toolID,
            ruleID: a.ruleID,
            isOnTarget: isOnTarget(
              bcve.CVE,
              commitDescription.commit,
              a.location.file,
              a.location.lineStart,
              a.location.lineEnd,
              targets
            ),
            isForRuleOnATarget: isForRuleOnATarget(
              bcve.CVE,
              r.toolID,
              a.ruleID,
              rulesOnATarget
            ),
            url: a.url
          }))
      );
    }
    let alerts: ClientTypes.Alert[] = [];
    if (bcve.prePatch) {
      addAlerts(bcve.prePatch, alerts);
    }
    if (bcve.postPatch) {
      addAlerts(bcve.postPatch, alerts);
    }
    return alerts;
  }
  getAlerts(cve: CVEString): ClientTypes.Alert[] {
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return [];
    }
    return this.getAlertsForBCVE(bcve);
  }
  getWeaknesses(): { [cve: string]: ClientTypes.Weakness[] } {
    function getWeaknesses(
      cve: CVEString,
      repository: string,
      commitDescription: CommitDescription
    ): ClientTypes.Weakness[] {
      let weaknesses = (commitDescription.weaknesses || [])
        .filter(w => w.location)
        .map(w => ({
          CVE: cve,
          commit: makeCommitData(cve, repository, commitDescription),
          file: w.location.file,
          line: w.location.line,
          explanation: w.explanation
        }));
      return weaknesses;
    }

    let mapped: { [cve: string]: ClientTypes.Weakness[] } = {};
    this.bcves.forEach(bcve => {
      let weaknesses = [];
      if (bcve.prePatch) {
        weaknesses.push(
          ...getWeaknesses(bcve.CVE, bcve.repository, bcve.prePatch)
        );
      }
      if (bcve.postPatch) {
        weaknesses.push(
          ...getWeaknesses(bcve.CVE, bcve.repository, bcve.postPatch)
        );
      }
      mapped[bcve.CVE] = weaknesses;
    });
    return mapped;
  }
  getCVEWeaknesses(cve: CVEString): ClientTypes.Weakness[] {
    function getWeaknesses(
      kind: "prePatch" | "postPatch",
      commitDescription: CommitDescription
    ): ClientTypes.Weakness[] {
      let weaknesses = (commitDescription.weaknesses || [])
        .filter(w => !!w.location)
        .map(w => ({
          CVE: cve,
          commitKind: kind,
          commit: makeCommitData(bcve.CVE, bcve.repository, commitDescription),
          file: w.location.file,
          line: w.location.line,
          explanation: w.explanation
        }));
      return weaknesses;
    }
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return [];
    }
    let weaknesses = [];
    if (bcve.prePatch) {
      weaknesses.push(...getWeaknesses("prePatch", bcve.prePatch));
    }
    if (bcve.postPatch) {
      weaknesses.push(...getWeaknesses("postPatch", bcve.postPatch));
    }
    return weaknesses;
  }
  getAlertCounts(
    cve: CVEString,
    commit: CommitID,
    file?: File
  ): ClientTypes.AlertCounts {
    function getAlertCounts(
      commitDescription: CommitDescription
    ): ClientTypes.AlertCounts {
      let counts: ClientTypes.AlertCounts = {};
      (commitDescription.runs || []).forEach(r => {
        counts[r.toolID] = counts[r.toolID] || 0;
        counts[r.toolID] += (r.alerts || []).filter(a =>
          file === undefined ? true : a.location.file === file
        ).length;
      });
      return counts;
    }
    let bcve = this.getBCVE(cve);
    if (!bcve) {
      console.warn(`No BCVE for ${cve}`);
      return {};
    }
    if (bcve.prePatch && bcve.prePatch.commit === commit) {
      return getAlertCounts(bcve.prePatch);
    }
    if (bcve.postPatch && bcve.postPatch.commit === commit) {
      return getAlertCounts(bcve.postPatch);
    }
  }

  listen(req: http.IncomingMessage, res: http.ServerResponse) {
    try {
      console.log(`Got request: ${req.url}`);
      let parsedUrl = url.parse(req.url, true);
      switch (parsedUrl.pathname) {
        case "/": {
          res.setHeader("Content-Type", "text/html");
          res.end(`
<!doctype html>
<html>
  <head>
  </head>
  <body>
    <div id="main"></div>
    <script type="text/javascript" src="main.js"></script>
  </body>
</html>
`);
          break;
        }
        case "/main.js": {
          res.setHeader("Content-Type", "text/javascript");
          fs.createReadStream(
            path.join(__dirname, "../../../../../../webpack/dist/main.js")
          ).pipe(res);
          break;
        }
        case "/main.css": {
          res.setHeader("Content-Type", "text/css");
          res.writeHead(200);
          fs.createReadStream("../../dist/main.css").pipe(res);
          break;
        }
        case "/sources": /*?CVE=...&commit=...&file=...*/ {
          let file;
          try {
            file = this.resolveSourceFileRequest(
              parsedUrl.query.CVE as string,
              parsedUrl.query.commit as string,
              parsedUrl.query.file as string
            );
          } catch (e) {
            console.error("Ignoring `resolveSourceFileRequest` error:");
            console.error(e);
            file = undefined;
          }
          if (file === undefined) {
            // TODO support downloading on the fly
            res.writeHead(404);
            res.end();
          } else {
            let src = fs.readFileSync(file);
            res.setHeader("Content-Type", "text/plain");
            res.writeHead(200);
            res.end(src);
          }
          break;
        }
        case "/data/getBenchmarkSource": /* CVE=... */ {
          let cvesDir = path.resolve(
            path.join(__dirname, "../../../../../../../CVEs/")
          );
          let cve = parsedUrl.query.CVE;
          let file = path.resolve(path.join(cvesDir, `${cve}.json`));
          res.setHeader("Content-Type", "text/plain");
          if (!file.startsWith(cvesDir)) {
            console.warn(
              `The ${file} for ${cve} does not reside in ${cvesDir}.`
            );
            res.writeHead(404);
            res.end();
            return;
          }

          res.writeHead(200);
          fs.createReadStream(file).pipe(res);
          break;
        }
        case "/data/getCommits": /* */ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(this.getCommits(this.bcves)));
          break;
        }
        case "/data/getCVECommits": /* CVE=... */ {
          let bcve = this.getBCVE(parsedUrl.query.CVE as string);
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify({
              unpatchedCommit: makeCommitData(
                bcve.CVE,
                bcve.repository,
                bcve.prePatch
              ),
              patchCommit: makeCommitData(
                bcve.CVE,
                bcve.repository,
                bcve.postPatch
              )
            })
          );
          break;
        }
        case "/data/getAllCVECommits": /* */ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.bcves.map(bcve => ({
                unpatchedCommit: makeCommitData(
                  bcve.CVE,
                  bcve.repository,
                  bcve.prePatch
                ),
                patchCommit: makeCommitData(
                  bcve.CVE,
                  bcve.repository,
                  bcve.postPatch
                )
              }))
            )
          );
          break;
        }
        case "/data/getCVERepository": /* CVE=... */ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(this.getBCVE(parsedUrl.query.CVE as string).repository);
          break;
        }

        case "/data/getToolIds": /* */ {
          res.setHeader("Content-Type", "application/json");
          let toolIDs = this.bcves.flatMap(bcve =>
            [bcve.prePatch, bcve.postPatch].flatMap(c =>
              (c.runs || []).map(r => r.toolID)
            )
          );
          res.writeHead(200);
          res.end(JSON.stringify(Array.from(new Set(toolIDs))));
          break;
        }
        case "/data/getCVEs": /* */ {
          let list = this.bcves.map(bcve => bcve.CVE);
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(list));
          break;
        }

        case "/data/getCVE2CWEs": /* */ {
          let map: { [cve: string]: CWEString[] } = {};
          this.bcves.forEach(bcve => (map[bcve.CVE] = bcve.CWEs));
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(map));
          break;
        }

        case "/data/getFiles": /* CVE=...&commit=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.getFiles(
                parsedUrl.query.CVE as string,
                parsedUrl.query.commit as string
              )
            )
          );
          break;
        }
        case "/data/getCVEAlertCounts": /* CVE=...&commit=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.getAlertCounts(
                parsedUrl.query.CVE as string,
                parsedUrl.query.commit as string
              )
            )
          );
          break;
        }
        case "/data/getFileAlertCounts": /* CVE=...&commit=...&file=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              this.getAlertCounts(
                parsedUrl.query.CVE as string,
                parsedUrl.query.commit as string,
                parsedUrl.query.file as string
              )
            )
          );
          break;
        }
        case "/data/getAllAlerts": /* */ {
          let response = this.bcves.flatMap(bcve =>
            this.getAlertsForBCVE(bcve)
          );
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(response));
          break;
        }
        case "/data/getAlerts": /* CVE=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(this.getAlerts(parsedUrl.query.CVE as string))
          );
          break;
        }
        case "/data/getAllWeaknesses": {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(
              Object.values(this.getWeaknesses()).flatMap(id => id)
            )
          );
          break;
        }
        case "/data/getAllToolRuns": {
          let runs = this.bcves.flatMap(bcve =>
            [bcve.prePatch, bcve.postPatch].flatMap(c =>
              (c.runs || []).map(r => ({
                CVE: bcve.CVE,
                toolID: r.toolID,
                commit: c.commit
              }))
            )
          );

          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(JSON.stringify(runs));
          break;
        }
        case "/data/getCWENames": {
          // TODO fetch this data from somewhere
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify({
              "CWE-0020": "Improper Input Validation",
              "CWE-0022":
                "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
              "CWE-0023": "Relative Path Traversal",
              "CWE-0036": "Absolute Path Traversal",
              "CWE-0073": "External Control of File Name or Path",
              "CWE-0074":
                "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')",
              "CWE-0078":
                "Improper Sanitization of Special Elements used in an OS Command ('OS Command Injection')",
              "CWE-0079":
                "Failure to Preserve Web Page Structure ('Cross-site Scripting')",
              "CWE-0088": "Argument Injection or Modification",
              "CWE-0089":
                "Improper Sanitization of Special Elements used in an SQL Command ('SQL Injection')",
              "CWE-0094":
                "Failure to Control Generation of Code ('Code Injection')",
              "CWE-0099":
                "Improper Control of Resource Identifiers ('Resource Injection')",
              "CWE-0116": "Improper Encoding or Escaping of Output",
              "CWE-0200": "Information Exposure",
              "CWE-0250": "Execution with Unnecessary Privileges",
              "CWE-0290": "Authentication Bypass by Spoofing",
              "CWE-0312": "Cleartext Storage of Sensitive Information"
            })
          );
          break;
        }

        case "/data/getCVEWeaknesses": /* CVE=...*/ {
          res.setHeader("Content-Type", "application/json");
          res.writeHead(200);
          res.end(
            JSON.stringify(this.getCVEWeaknesses(parsedUrl.query.CVE as string))
          );
          break;
        }
        default:
          res.writeHead(404);
          res.end(JSON.stringify({ error: "Resource not found" }));
      }
    } catch (e) {
      console.error(e);
    }
  }

  public async start(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        const server = http.createServer((req, res) => this.listen(req, res)),
          host = "localhost";
        server.listen(this.port, host, () => {
          console.log(`Server is running on http://${host}:${this.port}`);
          server.on("close", () => {
            console.log("Server closed");
            resolve();
          });
        });
      } catch (e) {
        reject(e);
      }
    });
  }
}
