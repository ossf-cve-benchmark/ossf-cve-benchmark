import Tooltip from "./MyTooltip";
import * as React from "react";
import { MyTable } from "./MyTables";
import * as Conclusions from "./Conclusions";
import * as MaterialTable from "material-table";
import {
  AlertCountComparison,
  cachingJSONFetch,
  getCve2tool2commitRuns,
  makeComparisons,
  mkSimpleURL,
  RelevantQueryResultCountChangeConclusion,
  createPrettyPercentages
} from "./util";
import { Alert, CommitData, Weakness } from "../shared/shared-types";
type Props = { CVEs: string[]; toolIDs: string[] };
type State = {
  cve2cwes: Map<string, Set<string>>;
  cwe2cves: Map<string, Set<string>>;
  cwe2name: Map<string, string>;
  cve2alerts: Map<string, Alert[]>;
  cve2weaknesses: Map<string, Weakness[]>;
  cve2comparisons: Map<string, AlertCountComparison[]>;
  cve2tool2commitsMap: Map<string, Map<string, string[]>>;
  competitiveBaseline: Set<string>;
  cve2commits: Map<
    string,
    {
      patchCommit: CommitData;
      unpatchedCommit: CommitData;
    }
  >;
};
enum RowKind {
  CWE = "CWE",
  CVE = "CVE",
  Summary = "Summary",
  SuccessRate = "SuccessRate",
  Ranking = "Ranking",
  SPACER = "Spacer"
}
type Row =
  | RankingRow
  | SuccessRateRow
  | SummaryRow
  | CWERow
  | CVERow
  | SpacerRow;

type BaseRow<T> = {
  name: string | React.ReactNode;
  kind: RowKind;
  tools: { [toolID: string]: T };
};
type RankingRow = BaseRow<number> & {
  kind: RowKind.Ranking;
};
type SuccessRateRow = BaseRow<ConclusionCounts> & {
  kind: RowKind.SuccessRate;
};
type SpacerRow = {
  name: string;
  kind: RowKind.SPACER;
};
type Conclusion = RelevantQueryResultCountChangeConclusion;
type ConclusionCounts = {
  [conclusion in keyof typeof RelevantQueryResultCountChangeConclusion]: number;
};
type CVERow = BaseRow<Conclusion> & {
  kind: RowKind.CVE;
  CVE: string;
  parentCWE: string;
  inBaseline: boolean;
};
type SummaryRow = BaseRow<ConclusionCounts> & {
  kind: RowKind.Summary;
};
type CWERow = BaseRow<ConclusionCounts> & {
  kind: RowKind.CWE;
  CWE: string;
};

function computePercentagesFromCounts(counts: ConclusionCounts) {
  let order = [
    {
      kind: RelevantQueryResultCountChangeConclusion.Negative,
      count: counts.Negative
    },
    {
      kind: RelevantQueryResultCountChangeConclusion.NeutralOrPositive,
      count: counts.NeutralOrPositive
    },
    {
      kind: RelevantQueryResultCountChangeConclusion.Uncomputable,
      count: counts.Uncomputable
    },
    {
      kind: RelevantQueryResultCountChangeConclusion.Missing,
      count: counts.Missing
    }
  ];
  let sum = order.reduce((acc, e) => acc + e.count, 0);
  let percentages = createPrettyPercentages(order.map(e => e.count));
  return {
    order,
    sum,
    percentages
  };
}

function ConclusionCountsSparklines(props: {
  counts: ConclusionCounts;
  showCounts?: boolean;
}) {
  const { order, sum, percentages } = computePercentagesFromCounts(
    props.counts
  );

  return (
    <Tooltip
      ordinary={true}
      title={
        <ul>
          {order.map((e, i) => (
            <li key={i}>
              {Conclusions.Recognition.getConclusionDescription(e.kind)}:{" "}
              {e.count}
            </li>
          ))}
        </ul>
      }
    >
      <div>
        <div>
          <span
            style={{ width: "100%", height: "25px", display: "inline-block" }}
            className="barchart-container"
          >
            {order
              .filter(
                e =>
                  true ||
                  e.kind ===
                    RelevantQueryResultCountChangeConclusion.Negative ||
                  e.kind ===
                    RelevantQueryResultCountChangeConclusion.NeutralOrPositive
              )
              .map((e, i) => (
                <span
                  key={i}
                  style={{
                    backgroundColor: Conclusions.Recognition.getColor(e.kind),
                    width: (1 * (100 * e.count)) / sum + "%",
                    height: "25px",
                    display: "inline-block"
                  }}
                >
                  {" "}
                </span>
              ))}
          </span>
        </div>
        {props.showCounts && (
          <div>
            <table style={{ width: "100%" }}>
              <tbody>
                <tr>
                  {order.map((e, i) => {
                    if (
                      e.kind ===
                        RelevantQueryResultCountChangeConclusion.Missing &&
                      e.count === 0
                    ) {
                      return undefined;
                    }
                    return (
                      <td
                        key={i}
                        style={{
                          color: Conclusions.Recognition.getColor(e.kind)
                        }}
                      >
                        {percentages[i]}%
                      </td>
                    );
                  })}
                </tr>
              </tbody>
            </table>
          </div>
        )}
      </div>
    </Tooltip>
  );
}
export default class CVEBenchmarkScoreTable extends React.Component<
  Props,
  State
> {
  constructor(props: Props) {
    super(props);
    this.state = {
      cve2cwes: null,
      cwe2cves: null,
      cwe2name: null,
      cve2commits: null,
      cve2alerts: null,
      cve2weaknesses: null,
      cve2comparisons: null,
      cve2tool2commitsMap: null,
      competitiveBaseline: null
    };
  }
  private getRankings() {
    let counts = this.getConclusionCounts(
      this.filterToCompetitiveBaseline(new Set(this.props.CVEs))
    );
    let sorted = Object.keys(counts).sort((t1, t2) => {
      let cmp = counts[t2].Negative - counts[t1].Negative;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = counts[t2].NeutralOrPositive - counts[t1].NeutralOrPositive;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = counts[t2].Uncomputable - counts[t1].Uncomputable;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = counts[t2].Missing - counts[t1].Missing;
      if (cmp !== 0) {
        return cmp;
      }
      return t2.localeCompare(t1);
    });
    let rankings: { [toolID: string]: number } = {};
    sorted.forEach((t, i) => (rankings[t] = i + 1));
    return rankings;
  }
  private getSuccessRateExplanation(successes: number, ideal: number) {
    return `Conclusion: ${Conclusions.Recognition.getConclusionDescription(
      RelevantQueryResultCountChangeConclusion.Negative
    )} (${successes} of ${ideal})`;
  }

  private getSuccessConclusions(cves: Set<string>) {
    let successes: { [toolID: string]: number } = {};
    let counts = this.getConclusionCounts(cves);
    this.props.toolIDs.forEach(t => {
      successes[t] = counts[t].Negative;
    });

    return successes;
  }
  private getCompetitiveBaselineExplanation(actual: number, ideal: number) {
    return `Only considering CVEs that could be detected by at least one tool (${actual} of ${ideal})`;
  }
  private filterToCompetitiveBaseline(cves: Set<string>): Set<string> {
    return new Set(
      [...cves].filter(cve => this.state.competitiveBaseline.has(cve))
    );
  }

  private getConclusionCounts(cves: Set<string>) {
    let scores: { [toolID: string]: ConclusionCounts } = {};
    this.props.toolIDs.forEach(t => {
      let score = {
        [RelevantQueryResultCountChangeConclusion.Negative]: 0,
        [RelevantQueryResultCountChangeConclusion.NeutralOrPositive]: 0,
        [RelevantQueryResultCountChangeConclusion.Uncomputable]: 0,
        [RelevantQueryResultCountChangeConclusion.Missing]: 0
      };
      cves.forEach(cve => {
        let comparisons = this.state.cve2comparisons.get(cve);
        comparisons
          .filter(cmp => cmp.toolID === t)
          .forEach(cmp => {
            score[cmp.conclusion as keyof ConclusionCounts]++;
          });
      });
      scores[t] = score;
    });

    return scores;
  }

  private getCVEConclusion(cve: string) {
    let hash = 0;
    for (let i = 0; i < cve.length; i++) {
      hash = (hash << 5) - hash + cve.charCodeAt(i);
    }
    let potentialConclusions = Object.values(
      RelevantQueryResultCountChangeConclusion
    );
    let conclusions: { [toolID: string]: Conclusion } = {};
    this.props.toolIDs.forEach(
      t =>
        (conclusions[t] =
          potentialConclusions[hash % potentialConclusions.length]) // XXX hardwired
    );
    return conclusions;
  }
  private getCWEs() {
    return Array.from(
      new Set(
        Array.from(this.state.cve2cwes.values()).flatMap(e => Array.from(e))
      )
    ).sort();
  }

  async componentDidMount() {
    let cve2cwes = (
        await cachingJSONFetch(mkSimpleURL("/data/getCVE2CWEs", {}))
      ).json,
      cveCommits: {
        patchCommit: CommitData;
        unpatchedCommit: CommitData;
      }[] = (await cachingJSONFetch(mkSimpleURL("/data/getAllCVECommits", {})))
        .json,
      alerts: Alert[] = (
        await cachingJSONFetch(mkSimpleURL("/data/getAllAlerts", {}))
      ).json,
      weaknesses: Weakness[] = (
        await cachingJSONFetch(mkSimpleURL("/data/getAllWeaknesses", {}))
      ).json,
      cwe2name = (await cachingJSONFetch(mkSimpleURL("/data/getCWENames", {})))
        .json,
      cve2cwesMap = new Map(),
      cwe2cvesMap = new Map(),
      cwe2nameMap = new Map(),
      cve2commitsMap: Map<
        string,
        {
          patchCommit: CommitData;
          unpatchedCommit: CommitData;
        }
      > = new Map(),
      cve2alertsMap = new Map(),
      cve2comparisonsMap = new Map<string, AlertCountComparison[]>(),
      cve2weaknessesMap = new Map();

    Object.entries(cve2cwes).forEach(([cve, cwes]: [string, string[]]) => {
      cve2cwesMap.set(cve, new Set(cwes));
      cwes.forEach(cwe => {
        if (!cwe2cvesMap.has(cwe)) {
          cwe2cvesMap.set(cwe, new Set());
        }
        cwe2cvesMap.get(cwe).add(cve);
      });
    });
    Object.entries(cwe2name).forEach(([cwe, name]) => {
      cwe2nameMap.set(cwe, name);
    });
    cveCommits.forEach(e => cve2commitsMap.set(e.unpatchedCommit.CVE, e));
    alerts.forEach(a => {
      if (!cve2alertsMap.has(a.CVE)) {
        cve2alertsMap.set(a.CVE, []);
      }
      cve2alertsMap.get(a.CVE).push(a);
    });
    weaknesses.forEach(w => {
      if (!cve2weaknessesMap.has(w.CVE)) {
        cve2weaknessesMap.set(w.CVE, []);
      }
      cve2weaknessesMap.get(w.CVE).push(w);
    });
    let toolRuns: {
      CVE: string;
      toolID: string;
      commit: string;
    }[] = (await cachingJSONFetch(mkSimpleURL("/data/getAllToolRuns", {})))
      .json;

    let cve2tool2commits = getCve2tool2commitRuns(toolRuns);
    let cve2tool2commitsMap = new Map();
    Object.entries(cve2tool2commits).forEach(([cve, m]) => {
      let map = new Map();
      cve2tool2commitsMap.set(cve, map);
      Object.entries(m).forEach(([t, cs]) => map.set(t, cs));
    });

    this.props.CVEs.forEach(cve => {
      let comparisons: AlertCountComparison[] = makeComparisons(
        this.props.toolIDs,
        cve2alertsMap.get(cve) || [],
        cve2commitsMap.get(cve).unpatchedCommit.commitID,
        cve2commitsMap.get(cve).patchCommit.commitID,
        cve2tool2commits[cve] || {}
      );
      cve2comparisonsMap.set(cve, comparisons);
    });

    let competitiveBaseline: Set<string> = new Set(
      this.props.CVEs.filter(cve =>
        cve2comparisonsMap
          .get(cve)
          .some(
            cmp =>
              cmp.conclusion ===
                RelevantQueryResultCountChangeConclusion.Negative ||
              cmp.conclusion ===
                RelevantQueryResultCountChangeConclusion.NeutralOrPositive
          )
      )
    );

    this.setState({
      cve2cwes: cve2cwesMap,
      cwe2cves: cwe2cvesMap,
      cwe2name: cwe2nameMap,
      cve2commits: cve2commitsMap,
      cve2alerts: cve2alertsMap,
      cve2weaknesses: cve2weaknessesMap,
      cve2comparisons: cve2comparisonsMap,
      cve2tool2commitsMap: cve2tool2commitsMap,
      competitiveBaseline: competitiveBaseline
    });
  }
  private getAlertHits(cve: string, toolID: string) {
    return (this.state.cve2alerts.get(cve) || []).filter(
      a => a.toolID === toolID && a.isOnTarget
    );
  }
  private getWeaknesses(cve: string) {
    return this.state.cve2weaknesses.get(cve) || [];
  }

  private makeScoringRows(cves: Set<string>): Row[] {
    let showSuccessRateRow = false;
    let baseline = this.filterToCompetitiveBaseline(cves);
    let conclusionCounts = this.getConclusionCounts(baseline);

    let successRateRow: Row[] = showSuccessRateRow
      ? [
          {
            kind: RowKind.SuccessRate,
            name: (
              <Tooltip
                title={this.getCompetitiveBaselineExplanation(
                  this.state.competitiveBaseline.size,
                  this.props.CVEs.length
                )}
                hint={true}
              >
                <span>Success rate</span>
              </Tooltip>
            ),
            tools: conclusionCounts
          }
        ]
      : [];
    return [
      ...successRateRow,
      {
        kind: RowKind.Summary,
        name: (
          <Tooltip
            title={this.getCompetitiveBaselineExplanation(
              this.state.competitiveBaseline.size,
              this.props.CVEs.length
            )}
            hint={true}
          >
            <span>Summary</span>
          </Tooltip>
        ),
        tools: conclusionCounts
      },
      {
        kind: RowKind.SPACER,
        name: " "
      }
    ];
  }
  render() {
    if (this.state.cve2cwes === null) {
      return null; // XXX not yet mounted
    }
    let columns: MaterialTable.Column<Row>[] = [
      {
        render: (row: Row) => {
          let text = <span className={`row-name ${row.kind}`}>{row.name}</span>;
          if (row.kind === RowKind.CVE) {
            return (
              <a
                href={mkSimpleURL("", { CVE: row.CVE })}
                className={row.inBaseline ? "" : "not-in-competitive-baseline"}
              >
                {text}
              </a>
            );
          } else {
            return text;
          }
        }
      },
      ...this.props.toolIDs.map(t => ({
        title: t,
        render: (row: Row) => {
          switch (row.kind) {
            case RowKind.CWE: {
              return <ConclusionCountsSparklines counts={row.tools[t]} />;
            }
            case RowKind.CVE: {
              let { patchCommit, unpatchedCommit } = this.state.cve2commits.get(
                  row.CVE
                ),
                comparison = this.state.cve2comparisons
                  .get(row.CVE)
                  .find(c => c.toolID === t);
              return (
                <Conclusions.Recognition.DetailedTableCellIcon
                  conclusion={comparison.conclusion}
                  toolID={t}
                  patchCommit={patchCommit}
                  unpatchedCommit={unpatchedCommit}
                  hits={this.getAlertHits(row.CVE, t)}
                  weaknesses={this.getWeaknesses(row.CVE)}
                  commitRuns={
                    (
                      this.state.cve2tool2commitsMap.get(row.CVE) || new Map()
                    ).get(t) || []
                  }
                />
              );
            }
            case RowKind.Summary: {
              return (
                <ConclusionCountsSparklines
                  counts={row.tools[t]}
                  showCounts={true}
                />
              );
            }
            case RowKind.SuccessRate: {
              let tool = row.tools[t];
              const { order, sum, percentages } = computePercentagesFromCounts(
                tool
              );
              return (
                <Tooltip
                  title={this.getSuccessRateExplanation(order[0].count, sum)}
                >
                  <span>{percentages[0]}%</span>
                </Tooltip>
              );
            }
            case RowKind.Ranking: {
              let tool = row.tools[t];
              return <span>{tool}</span>;
            }
            case RowKind.SPACER: {
              return <span> </span>;
            }
            default:
              throw new Error(`Unhandled row-kind ${(row as any).kind}`);
          }
        }
      }))
    ];
    let competitiveCWEs = new Set<string>();
    this.state.cwe2cves.forEach((cves, cwe) => {
      if (this.filterToCompetitiveBaseline(cves).size > 0) {
        competitiveCWEs.add(cwe);
      }
    });

    let cweRows: CWERow[] = this.getCWEs().map(cwe => {
      let ideal = this.state.cwe2cves.get(cwe);
      let baseline = this.filterToCompetitiveBaseline(ideal);
      return {
        kind: RowKind.CWE,
        name: (
          <div>
            <Tooltip
              title={this.getCompetitiveBaselineExplanation(
                baseline.size,
                ideal.size
              )}
              hint={true}
            >
              <span
                className={
                  competitiveCWEs.has(cwe) ? "" : "not-in-competitive-baseline"
                }
              >
                <span>{cwe}</span>
              </span>
            </Tooltip>
            <div>
              {this.state.cwe2name.has(cwe) && (
                <Tooltip title={this.state.cwe2name.get(cwe)} ordinary={true}>
                  <span className="cwe-name">
                    {this.state.cwe2name.get(cwe)}
                  </span>
                </Tooltip>
              )}
            </div>
          </div>
        ),
        CWE: cwe,
        tools: this.getConclusionCounts(baseline)
      };
    });
    // put the interesting CWEs first
    cweRows.sort((a, b) => {
      return +competitiveCWEs.has(b.CWE) - +competitiveCWEs.has(a.CWE);
    });

    let cveRows: CVERow[] = this.props.CVEs.flatMap(cve =>
      Array.from(this.state.cve2cwes.get(cve)).map(cwe => ({
        kind: RowKind.CVE,
        name: <span>{cve}</span>,
        CVE: cve,
        tools: this.getCVEConclusion(cve),
        parentCWE: cwe,
        inBaseline: this.state.competitiveBaseline.has(cve)
      }))
    );
    // put the interesting CVEs first
    cveRows.sort((a, b) => {
      return (
        +this.state.competitiveBaseline.has(b.CVE) -
        +this.state.competitiveBaseline.has(a.CVE)
      );
    });
    let data: Row[] = [
      { kind: RowKind.Ranking, name: "Ranking", tools: this.getRankings() },
      ...this.makeScoringRows(new Set(this.props.CVEs)),
      ...cweRows,
      ...cveRows
    ];

    function rowStyle(row: Row): React.CSSProperties {
      if (row.kind === RowKind.SPACER) {
        return {
          backgroundColor: "#fcfcfc"
        };
      }
      return undefined;
    }
    return (
      <MyTable
        columns={columns}
        data={data}
        parentChildData={(child: Row, parents: Row[]) => {
          if (child.kind === RowKind.CVE) {
            // TODO is this really efficient enough? (it is the pattern from the documentation)
            return parents.find(
              parent =>
                parent.kind === RowKind.CWE && child.parentCWE === parent.CWE
            );
          }
          return undefined;
        }}
        options={{ rowStyle: rowStyle }}
      ></MyTable>
    );
  }
}
