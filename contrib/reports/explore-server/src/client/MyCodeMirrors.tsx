import Tooltip from "./MyTooltip";
import * as React from "react";
import * as ReactCodeMirror from "react-codemirror2";
import * as ReactDOM from "react-dom";
import * as Conclusions from "./Conclusions";
import { Alert, Weakness } from "../shared/shared-types";
import { getToolIcon, getToolOrderID } from "./util";
require("codemirror/mode/javascript/javascript");

type Props = {
  toolIDs: string[];
  source?: string;
  file?: string;
  line?: number;
  fileUrl?: string;
  lineAnnotations: Weakness[];
  gutterAnnotations: Alert[];
};
function makeToolIDGutterID(toolID: string, toolIDs: string[]): string {
  return `codemirror-gutter-class-for-tool-${getToolOrderID(toolID, toolIDs)}`;
}
function makeToolGutterIconWithAlertHover(
  icon: string,
  toolID: string,
  alerts: Alert[]
) {
  let annotationElement = document.createElement("div");
  let hover = (
    <span className="codemirror-gutter-hover">
      <Conclusions.SpecificDetection.Sentence
        toolID={toolID}
        alerts={alerts}
        hasRun={true}
      />
    </span>
  );

  ReactDOM.render(
    <Tooltip title={hover}>
      <span>{icon}</span>
    </Tooltip>,
    annotationElement
  );
  return annotationElement;
}
class AnnotatedCodeMirror extends React.Component<Props> {
  constructor(props: Props) {
    super(props);
    this.state = {};
  }
  render() {
    let self = this;
    // TODO improve language inference
    let mode, name;
    if (self.props.file.match(/.*\.jsx?$/)) {
      name = "javascript";
      mode = "typescript";
    }
    if (self.props.file.match(/.*\.tsx?$/)) {
      name = "javascript";
      mode = "typescript";
    }
    if (self.props.file.match(/.*\.json$/)) {
      name = "javascript";
      mode = "json";
    }
    function initializeCodeMirror(e: CodeMirror.Editor) {
      // hacky group-by
      let alertsByLineAndToolId: {
        [lineAndToolID: string]: {
          line: number;
          toolID: string;
          alerts: Alert[];
        };
      } = {};
      self.props.gutterAnnotations.forEach(a => {
        let key = `line:${a.line},toolID:${a.toolID}`;
        alertsByLineAndToolId[key] = alertsByLineAndToolId[key] || {
          line: a.line,
          toolID: a.toolID,
          alerts: []
        };
        alertsByLineAndToolId[key].alerts.push(a);
      });
      for (let a of Object.values(alertsByLineAndToolId)) {
        e.setGutterMarker(
          a.line - 1,
          makeToolIDGutterID(a.toolID, self.props.toolIDs),
          makeToolGutterIconWithAlertHover(
            getToolIcon(a.toolID, self.props.toolIDs),
            a.toolID,
            a.alerts
          )
        );
      }

      for (let a of self.props.lineAnnotations) {
        let annotation = <div className="alert-line">{a.explanation}</div>;
        let annotationElement = document.createElement("div");
        ReactDOM.render(annotation, annotationElement);
        e.addLineWidget(a.line - 1, annotationElement, {
          coverGutter: false
        });
      }

      let height = 600;
      e.setSize(null, height);
      e.refresh();
      if (self.props.line !== undefined) {
        let line = self.props.line - 1;
        e.markText(
          { line, ch: 0 },
          { line, ch: Infinity },
          { className: "selected-line" }
        );

        e.addLineClass(line, "background", "selected-line-background");

        let pos = { ch: 0, line };
        e.scrollIntoView(pos, height / 2);
      }
    }

    let codemirror =
      self.props.source === undefined ? (
        <div>
          Source code not found. Please check if the commits have been
          downloaded with `bin/cli download-commits`)
        </div>
      ) : (
        <ReactCodeMirror.UnControlled
          editorDidMount={e => {
            initializeCodeMirror(e);
          }}
          value={self.props.source}
          options={{
            lineNumbers: true,
            gutters: [
              ...self.props.toolIDs.map(t =>
                makeToolIDGutterID(t, self.props.toolIDs)
              ),
              "CodeMirror-linenumbers"
            ],
            readOnly: true,
            mode: { name, mode }
          }}
        />
      );
    return (
      <div>
        <a href={self.props.fileUrl}>
          <span>{self.props.file}</span>
        </a>
        {codemirror}
      </div>
    );
  }
}

export default {
  CodeMirror: ReactCodeMirror.UnControlled,
  AnnotatedCodeMirror
};
