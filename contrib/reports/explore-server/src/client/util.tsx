// TODO move most of this file elsewhere
import * as React from "react";
import { Alert, CommitData, Weakness } from "../shared/shared-types";

const fetchCache = new Map<string, any>();
export async function cachingJSONFetch(
  url: string
): Promise<Promise<{ json: any; status: number }>> {
  if (!fetchCache.has(url)) {
    let response = await fetch(url);
    let json = await response.json();
    fetchCache.set(url, { json: json, status: response.status });
  }
  return fetchCache.get(url);
}
export async function cachingTextFetch(
  url: string
): Promise<{ text: string; status: number }> {
  if (!fetchCache.has(url)) {
    let response = await fetch(url);
    let text = await response.text();
    fetchCache.set(url, { text: text, status: response.status });
  }
  return fetchCache.get(url);
}

export function mkSimpleURL(
  path: string,
  params: { [k: string]: string }
): string {
  let paramsString = Object.entries(params)
    .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    .join("&");
  return `${path}?${paramsString}`;
}

export function compareToolIDs(t1: string, t2: string) {
  return t1.localeCompare(t2);
}

export function groupAlertsByTool(alerts: Alert[], toolIDs: string[]) {
  return toolIDs.map(toolID => ({
    toolID,
    alerts: alerts.filter(a => a.toolID === toolID)
  }));
}

export function makeToolColumnKey(toolID: string) {
  return "tool-column-for-" + toolID;
}
export function getToolIcon(toolID: string, toolIDs: string[]) {
  let order = getToolOrderID(toolID, toolIDs);
  let icons = [
    "\u25A2",
    "\u25B3",
    "\u25EF",
    "\u25C7",
    "\u25A3",
    "\u25C8",
    "\u25C9"
  ];
  return icons[order] || "?";
}
export function getToolOrderID(toolID: string, toolIDs: string[]): number {
  return toolIDs.indexOf(toolID);
}

export function makeCompactLocationString(file: string, line: number) {
  return `${file}:${line}`;
}
export type SetSourceFocus = (o: {
  line: number;
  file: string;
  commit: CommitData;
}) => void;
export type AlertCountComparison = {
  toolID: string;
  conclusion: RelevantQueryResultCountChangeConclusion;
  counts: { before: number; after: number; ruleID: string; ruleURL: string }[];
};
export enum RelevantQueryResultCountChangeConclusion {
  Negative = "Negative",
  NeutralOrPositive = "NeutralOrPositive",
  Uncomputable = "Uncomputable",
  Missing = "Missing"
}

export function mkRuleListSentence(
  rulesAndUrls: { ruleID: string; url?: string }[]
) {
  rulesAndUrls = Array.from(rulesAndUrls).sort((r1, r2) =>
    r1.ruleID.localeCompare(r2.ruleID)
  );
  return rulesAndUrls.map(({ ruleID, url }, i) => {
    return (
      <span key={i}>
        {i > 0 && ", "}
        <a href={url}>
          <span className="ruleID">{ruleID}</span>
        </a>
      </span>
    );
  });
}
export function mkToolIDString(toolID: string) {
  return <span className="toolID">{toolID}</span>;
}

export const icons = {
  // TODO move this closer to the React components
  // TODO control the colors in a less hacky way
  checkmark: (
    <span
      style={{
        textShadow: `0px 0px lightgray`,
        color: "transparent"
      }}
    >
      {"\u2714"}
    </span>
  ),
  cross: (
    <span
      style={{
        textShadow: `0px 0px lightgray`,
        color: "transparent"
      }}
    >
      {"\u274C"}
    </span>
  )
};

export function mkCommitUrl(commit: CommitData) {
  return <a href={commit.permalink}>{commit.commitID.slice(0, 7)}</a>;
}
type RelevantRuleAlertCounts = {
  before: number;
  after: number;
  ruleID: string;
  ruleURL: string;
};
export function getRelevantRuleAlertCounts(
  alerts: Alert[],
  unpatchedCommit: string,
  patchedCommit: string
): RelevantRuleAlertCounts[] {
  let relevantRuleAlertsMap: {
    [ruleID: string]: RelevantRuleAlertCounts;
  } = {};
  alerts
    .filter(a => a.isForRuleOnATarget)
    .forEach(a => {
      relevantRuleAlertsMap[a.ruleID] = relevantRuleAlertsMap[a.ruleID] || {
        ruleID: a.ruleID,
        ruleURL: a.url, // (assuming a 1:1 relationship between ID and URL)
        before: 0,
        after: 0
      };
      if (a.commit.commitID === unpatchedCommit) {
        relevantRuleAlertsMap[a.ruleID].before+=a.lines.length;
      }
      if (a.commit.commitID === patchedCommit) {
        relevantRuleAlertsMap[a.ruleID].after+=a.lines.length;
      }
    });
  return Object.values(relevantRuleAlertsMap);
}

export function getRelevantRuleAlertCountsConclusion(
  counts: RelevantRuleAlertCounts[],
  hasBeforeAndAfter: boolean
) {
  if (!hasBeforeAndAfter) {
    return RelevantQueryResultCountChangeConclusion.Missing;
  }
  if (counts.every(v => v.before === 0)) {
    return RelevantQueryResultCountChangeConclusion.Uncomputable;
  }
  if (counts.some(v => v.after - v.before < 0)) {
    return RelevantQueryResultCountChangeConclusion.Negative;
  }
  return RelevantQueryResultCountChangeConclusion.NeutralOrPositive;
}
export function getCSSQualifierClassForConclusion(
  conclusion: RelevantQueryResultCountChangeConclusion
) {
  let map = {
    [RelevantQueryResultCountChangeConclusion.Negative]: "good",
    [RelevantQueryResultCountChangeConclusion.NeutralOrPositive]: "bad",
    [RelevantQueryResultCountChangeConclusion.Uncomputable]: "uncomputable",
    [RelevantQueryResultCountChangeConclusion.Missing]: "missing"
  };
  return map[conclusion];
}

export function makeComparisons(
  toolIDs: string[],
  alerts: Alert[],
  unpatchedCommit: string,
  patchCommit: string,
  tool2commitWithRun: { [toolID: string]: string[] }
) {
  let comparisons: AlertCountComparison[] = [];
  toolIDs.forEach(toolID => {
    let counts = getRelevantRuleAlertCounts(
      alerts.filter(a => a.toolID === toolID),
      unpatchedCommit,
      patchCommit
    );
    let conclusion = getRelevantRuleAlertCountsConclusion(
      counts,
      (tool2commitWithRun[toolID] || []).includes(unpatchedCommit) &&
        (tool2commitWithRun[toolID] || []).includes(patchCommit)
    );

    comparisons.push({
      toolID,
      conclusion: conclusion,
      counts: counts
    });
  });
  return comparisons;
}
export function getCve2tool2commitRuns(
  runs: {
    CVE: string;
    toolID: string;
    commit: string;
  }[]
) {
  let mapped: {
    [cve: string]: { [toolID: string]: string[] };
  } = {};
  runs.forEach(r => {
    mapped[r.CVE] = mapped[r.CVE] || {};
    mapped[r.CVE][r.toolID] = mapped[r.CVE][r.toolID] || [];
    mapped[r.CVE][r.toolID].push(r.commit);
  });
  return mapped;
}
export function countWeaknessLocations(es: Weakness[]): number {
  return new Set(es.map(e => `${e.file}:${e.line}`)).size;
}
export function countAlertLocations(es: Alert[]): number {
  return new Set(es.flatMap(e => e.lines.map(line => `${e.file}:${line}`))).size;
}

// Outputs whole number percentages that sum to 100.
export function createPrettyPercentages(nums: number[]): number[] {
  const sum = nums.reduce((acc, e) => acc + e, 0);

  let result = nums.map(e => (100 * e) / sum);
  // the index of the largest remainders, sorted descending by remainder.
  let remainders = result
    .map((x, i) => [x - Math.floor(x), i])
    .sort(([a], [b]) => b - a)
    .map(([, i]) => i);

  result = result.map(x => Math.floor(x));

  // How much below 100 the sum of the results is.
  var toAdd = 100 - result.reduce((acc, e) => acc + e, 0);

  for (let i = 0; i < toAdd; i++) {
    result[remainders[i % remainders.length]]++;
  }

  return result;
}
