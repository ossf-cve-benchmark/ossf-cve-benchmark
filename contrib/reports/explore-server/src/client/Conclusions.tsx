import Tooltip from "./MyTooltip";
import * as React from "react";
import CompactLocationURL from "./CompactLocationURL";
import { Alert, CommitData, Weakness } from "../shared/shared-types";
import {
  AlertCountComparison,
  countAlertLocations,
  countWeaknessLocations,
  icons,
  mkCommitUrl,
  mkRuleListSentence,
  mkToolIDString,
  RelevantQueryResultCountChangeConclusion,
  SetSourceFocus
} from "./util";

namespace Icons {
  function mkStyle(color?: string) {
    if (!color) {
      return {};
    }
    return {
      color: color
    };
  }

  type Props = { color?: string; style?: React.CSSProperties };
  export class Cross extends React.Component<Props> {
    render() {
      return (
        <span
          style={{
            color: "transparent",
            textShadow: "0px 0px " + this.props.color,
            ...(this.props.style || {})
          }}
        >
          {"\u274C"}
        </span>
      );
    }
  }
  export class Empty extends React.Component<Props> {
    render() {
      return (
        <span
          style={{ ...mkStyle(this.props.color), ...(this.props.style || {}) }}
        >
          &nbsp;
        </span>
      );
    }
  }
  export class Dash extends React.Component<Props> {
    render() {
      return (
        <span
          style={{ ...mkStyle(this.props.color), ...(this.props.style || {}) }}
        >
          {"--"}
        </span>
      );
    }
  }
  export class Checkmark extends React.Component<Props> {
    render() {
      return (
        <span
          style={{ ...mkStyle(this.props.color), ...(this.props.style || {}) }}
        >
          {"\u2714"}
        </span>
      );
    }
  }
  export class Box extends React.Component<Props & { color: string }> {
    render() {
      // this is actually a large white square, made transparent, and with a shadow of the right color.
      return (
        <span
          style={{
            color: "transparent",
            textShadow: "0px 0px " + this.props.color,
            ...(this.props.style || {})
          }}
        >
          {"\u2B1C"}
        </span>
      );
    }
  }
  export class QuestionMark extends React.Component<Props> {
    render() {
      return (
        <span
          style={{ ...mkStyle(this.props.color), ...(this.props.style || {}) }}
        >
          {"?"}
        </span>
      );
    }
  }
}

export namespace Missing {
  type Props = { toolID: string; commit: CommitData };
  export class Sentence extends React.Component<Props> {
    render() {
      return (
        <span>
          {mkToolIDString(this.props.toolID)} has not been run on{" "}
          {mkCommitUrl(this.props.commit)}
        </span>
      );
    }
  }

  export class Icon extends React.Component<Props> {
    render() {
      return (
        <Tooltip
          title={
            <Sentence toolID={this.props.toolID} commit={this.props.commit} />
          }
        >
          <span>
            <Icons.QuestionMark color="lightgray" />
          </span>
        </Tooltip>
      );
    }
  }
}
export namespace SpecificDetection {
  type IconProps = {
    toolID: string;
    alerts: Alert[];
    hasRun: boolean;
    commit?: CommitData;
  };
  function getColor(_props: IconProps): string {
    return "lightgray";
  }
  export class Sentence extends React.Component<IconProps> {
    render() {
      let props = this.props;
      if (!props.hasRun) {
        return <Missing.Sentence toolID={props.toolID} commit={props.commit} />;
      }
      let detected = props.alerts.length > 0;
      let relevantRulesAndUrlsMap: Map<
        string,
        { ruleID: string; url: string }
      > = new Map();
      props.alerts.forEach(a =>
        relevantRulesAndUrlsMap.set(a.ruleID, { ruleID: a.ruleID, url: a.url })
      );
      let relevantRulesAndUrls: { ruleID: string; url: string }[] = Array.from(
        relevantRulesAndUrlsMap.values()
      );

      return detected ? (
        <span>
          {mkToolIDString(props.toolID)} flagged this with rule
          {relevantRulesAndUrls.length > 1 && "s"}:{" "}
          {mkRuleListSentence(relevantRulesAndUrls)}.
        </span>
      ) : (
        <span>{mkToolIDString(props.toolID)} did not detect this.</span>
      );
    }
  }
  export class TableCellIcon extends React.Component<IconProps> {
    constructor(props: IconProps) {
      super(props);
    }
    render() {
      let props = this.props;
      let icon;
      if (!props.hasRun) {
        icon = <Icons.QuestionMark color={getColor(props)} />;
      } else if (props.alerts.length > 0) {
        icon = <Icons.Checkmark color={getColor(props)} />;
      } else {
        icon = <Icons.Empty color={getColor(props)} />;
      }
      return (
        <Tooltip title={<Sentence {...this.props} />}>
          <span>{icon}</span>
        </Tooltip>
      );
    }
  }
}
export namespace Detection {
  type IconProps = {
    toolID: string;
    hasRun: boolean;
    unpatchedCommit: CommitData;
    detected: boolean;
    hits: Alert[];
    weaknesses: Weakness[];
  };
  function getColor(_props: IconProps): string {
    return "lightgray";
  }
  export class Sentence extends React.Component<IconProps> {
    render() {
      // TODO unify this with RecognitionConclusion (currently 50% duplication)
      let props = this.props;
      let detectionSummary: React.ReactNode, hitsSummary: React.ReactNode;
      if (props.detected) {
        detectionSummary = (
          <span className="tool-summary weakness-detected">
            detected this CVE
          </span>
        );
        hitsSummary = (
          <span>
            (flagging {props.weaknesses.length} weaknesses with{" "}
            {props.hits.length} alerts on {mkCommitUrl(props.unpatchedCommit)})
          </span>
        );
      } else {
        detectionSummary = (
          <span className="tool-summary weakness-not-detected">
            did not detect this CVE
          </span>
        );
      }
      return (
        <>
          {mkToolIDString(props.toolID)} {detectionSummary} {hitsSummary}.
        </>
      );
    }
  }
  export class TableCellIcon extends React.Component<IconProps> {
    constructor(props: IconProps) {
      super(props);
    }
    render() {
      let props = this.props;
      let icon;
      if (!props.hasRun) {
        icon = <Icons.QuestionMark color={getColor(props)} />;
      } else if (props.detected) {
        icon = <Icons.Checkmark color={getColor(props)} />;
      } else {
        icon = <Icons.Empty color={getColor(props)} />;
      }
      return (
        <Tooltip title={<Sentence {...this.props} />}>
          <span>{icon}</span>
        </Tooltip>
      );
    }
  }

  export function FlaggedLineSentence(props: {
    toolID: string;
    rules: { ruleID: string; url: string }[];
  }) {
    return (
      <>
        {mkToolIDString(props.toolID)} flagged this with rule
        {props.rules.length > 1 && "s"}: {mkRuleListSentence(props.rules)}
      </>
    );
  }
  export function DetectionConclusionLine(props: {
    toolID: string;
    weakness: Weakness;
    alerts: Alert[];
    setSourceFocus: SetSourceFocus;
  }) {
    let detected = props.alerts.length > 0;
    let relevantRulesAndUrlsMap: Map<
      string,
      { ruleID: string; url: string }
    > = new Map();
    props.alerts.forEach(a =>
      relevantRulesAndUrlsMap.set(a.ruleID, { ruleID: a.ruleID, url: a.url })
    );
    let relevantRulesAndUrls: { ruleID: string; url: string }[] = Array.from(
      relevantRulesAndUrlsMap.values()
    );

    let rules = detected && (
      <FlaggedLineSentence toolID={props.toolID} rules={relevantRulesAndUrls} />
    );
    return (
      <>
        {detected ? icons.checkmark : icons.cross}
        <CompactLocationURL
          commit={props.weakness.commit}
          file={props.weakness.file}
          line={props.weakness.line}
          setSourceFocus={props.setSourceFocus}
        />
        : {props.weakness.explanation}. {detected && rules}
      </>
    );
  }

  type Props = {
    toolID: string;
    weaknesses: Weakness[];
    alerts: Alert[];
    setSourceFocus: SetSourceFocus;
  };

  export class DetailedExplanation extends React.Component<Props> {
    render() {
      let props = this.props;
      return (
        <ul>
          {props.weaknesses.map((w, i) => (
            <li style={{ listStyleType: "none" }} key={i}>
              <DetectionConclusionLine
                toolID={props.toolID}
                weakness={w}
                alerts={props.alerts.filter(
                  a => a.file === w.file && a.lines.some(line => line === w.line)
                )}
                setSourceFocus={props.setSourceFocus}
              />
            </li>
          ))}
        </ul>
      );
    }
  }
}

export namespace Recognition {
  type ExplanationProps = {
    toolID: string;
    patchCommit: CommitData;
    unpatchedCommit: CommitData;
    alertCountComparison: AlertCountComparison;
    commitRuns: string[];
  };
  type IconProps = {
    conclusion: RelevantQueryResultCountChangeConclusion;
    toolID: string;
    patchCommit: CommitData;
    unpatchedCommit: CommitData;
    commitRuns: string[];
    hits: Alert[];
    weaknesses: Weakness[];
  };
  export function getConclusionDescription(
    conclusion: RelevantQueryResultCountChangeConclusion
  ): string {
    switch (conclusion) {
      case RelevantQueryResultCountChangeConclusion.Negative:
        return "Vulnerability detected, patch recognized";
      case RelevantQueryResultCountChangeConclusion.NeutralOrPositive:
        return "Vulnerability detected, patch not recognized";
      case RelevantQueryResultCountChangeConclusion.Uncomputable:
        return "Vulnerability not detected";
      case RelevantQueryResultCountChangeConclusion.Missing:
        return "Analysis run missing";
    }
  }
  export function getColor(
    conclusion: RelevantQueryResultCountChangeConclusion
  ): string {
    switch (conclusion) {
      case RelevantQueryResultCountChangeConclusion.Negative:
        return "#21b321"; // green
      case RelevantQueryResultCountChangeConclusion.NeutralOrPositive:
        return "rgb(255 175 29)"; // orange
      case RelevantQueryResultCountChangeConclusion.Uncomputable:
        return "rgb(224 9 9)"; // red
      case RelevantQueryResultCountChangeConclusion.Missing:
        return "lightgray";
    }
  }

  function getDullColor(_props: IconProps): string {
    return "lightgray";
  }

  export class Sentence extends React.Component<IconProps> {
    render() {
      let props = this.props;
      let detectionSummary: React.ReactNode,
        hitsSummary: React.ReactNode,
        separator: string,
        recognizedSummary: React.ReactNode;
      switch (props.conclusion) {
        case RelevantQueryResultCountChangeConclusion.Negative:
        case RelevantQueryResultCountChangeConclusion.NeutralOrPositive: {
          detectionSummary = (
            <span className="tool-summary weakness-detected">
              detected this CVE
            </span>
          );
          hitsSummary = (
            <span>
              (flagging {countAlertLocations(props.hits)} out of{" "}
              {countWeaknessLocations(props.weaknesses)} weakness locations in{" "}
              {mkCommitUrl(props.unpatchedCommit)})
            </span>
          );
          separator = ", ";
          if (
            props.conclusion ===
            RelevantQueryResultCountChangeConclusion.Negative
          ) {
            recognizedSummary = (
              <>
                and{" "}
                <span className="tool-summary patch-recognized">
                  correctly recognized the patch
                </span>{" "}
                in {mkCommitUrl(props.patchCommit)}
              </>
            );
          } else {
            recognizedSummary = (
              <>
                but{" "}
                <span className="tool-summary patch-not-recognized">
                  did not recognize the patch
                </span>{" "}
                in {mkCommitUrl(props.patchCommit)} (resulting in a false
                positive)
              </>
            );
          }
          break;
        }
        case RelevantQueryResultCountChangeConclusion.Uncomputable: {
          detectionSummary = (
            <span className="tool-summary weakness-not-detected">
              did not detect this CVE
            </span>
          );
          separator = ". ";
          recognizedSummary = (
            <>
              It should have produced at least one relevant alert in{" "}
              {mkCommitUrl(props.unpatchedCommit)}
            </>
          );
          break;
        }
        case RelevantQueryResultCountChangeConclusion.Missing: {
          if (!props.commitRuns.includes(props.unpatchedCommit.commitID)) {
            return (
              <Missing.Sentence
                toolID={props.toolID}
                commit={props.unpatchedCommit}
              />
            );
          }
          if (!props.commitRuns.includes(props.patchCommit.commitID)) {
            return (
              <Missing.Sentence
                toolID={props.toolID}
                commit={props.patchCommit}
              />
            );
          }
        }
      }
      return (
        <>
          {mkToolIDString(props.toolID)} {detectionSummary} {hitsSummary}
          {separator} {recognizedSummary}.
        </>
      );
    }
  }
  export class TableCellIcon extends React.Component<IconProps> {
    constructor(props: IconProps) {
      super(props);
    }
    render() {
      let props = this.props;
      let icon;
      switch (props.conclusion) {
        case RelevantQueryResultCountChangeConclusion.Negative:
          icon = <Icons.Checkmark color={getDullColor(props)} />;
          break;
        case RelevantQueryResultCountChangeConclusion.NeutralOrPositive:
        case RelevantQueryResultCountChangeConclusion.Uncomputable:
          icon = <Icons.Empty color={getDullColor(props)} />;
          break;
        case RelevantQueryResultCountChangeConclusion.Missing:
          icon = <Icons.QuestionMark color={getDullColor(props)} />;
          break;
      }
      return (
        <Tooltip title={<Sentence {...this.props} />}>
          <span style={{ fontSize: "200%" }}>{icon}</span>
        </Tooltip>
      );
    }
  }

  export class DetailedTableCellIcon extends React.Component<IconProps> {
    constructor(props: IconProps) {
      super(props);
    }
    render() {
      let props = this.props;
      let icon;
      switch (props.conclusion) {
        case RelevantQueryResultCountChangeConclusion.Negative:
          // FIXME The thing just wouldn't turn (green). So I made it transparent and put a (green) shadow behind it.
          icon = (
            <Icons.Checkmark
              style={{
                textShadow: `0px 0px ${getColor(props.conclusion)}`,
                color: "transparent"
              }}
            />
          );
          break;
        case RelevantQueryResultCountChangeConclusion.NeutralOrPositive:
          icon = <Icons.Box color={getColor(props.conclusion)} />;
          break;
        case RelevantQueryResultCountChangeConclusion.Uncomputable:
          icon = <Icons.Cross color={getColor(props.conclusion)} />;
          break;
        case RelevantQueryResultCountChangeConclusion.Missing:
          icon = <Icons.QuestionMark color={getColor(props.conclusion)} />;
          break;
      }
      return (
        <Tooltip title={<Sentence {...this.props} />}>
          <span>{icon}</span>
        </Tooltip>
      );
    }
  }

  export class DetailedExplanation extends React.Component<ExplanationProps> {
    render() {
      if (
        !this.props.commitRuns.includes(this.props.unpatchedCommit.commitID)
      ) {
        return (
          <Missing.Icon
            toolID={this.props.toolID}
            commit={this.props.unpatchedCommit}
          />
        );
      }
      if (!this.props.commitRuns.includes(this.props.patchCommit.commitID)) {
        return (
          <Missing.Icon
            toolID={this.props.toolID}
            commit={this.props.patchCommit}
          />
        );
      }

      let detected =
          this.props.alertCountComparison.conclusion ===
            RelevantQueryResultCountChangeConclusion.Negative ||
          this.props.alertCountComparison.conclusion ===
            RelevantQueryResultCountChangeConclusion.NeutralOrPositive,
        recognized =
          this.props.alertCountComparison.conclusion ===
          RelevantQueryResultCountChangeConclusion.Negative;
      let relevantRules = this.props.alertCountComparison.counts;
      let negativeDeltaRules = this.props.alertCountComparison.counts
        .map(c => ({
          ruleID: c.ruleID,
          delta: c.after - c.before,
          ruleURL: c.ruleURL
        }))
        .filter(e => e.delta < 0);
      let negativeDeltaSum = negativeDeltaRules.reduce(
        (delta, e) => (delta += e.delta),
        0
      );

      return (
        <div>
          {detected ? (
            recognized ? (
              <>
                On patch {mkCommitUrl(this.props.patchCommit)},{" "}
                {mkToolIDString(this.props.toolID)} reported {-negativeDeltaSum}{" "}
                fewer alerts for {mkRuleListSentence(negativeDeltaRules)}.
              </>
            ) : (
              <>
                On patch {mkCommitUrl(this.props.patchCommit)},{" "}
                {mkToolIDString(this.props.toolID)} reported 0 fewer alerts for{" "}
                {mkRuleListSentence(relevantRules)}.
              </>
            )
          ) : (
            <>
              {mkToolIDString(this.props.toolID)} did not detect this CVE. It is
              therefore impossible to draw any conclusions about{" "}
              {mkToolIDString(this.props.toolID)} recognising the patch in{" "}
              {mkCommitUrl(this.props.patchCommit)}.
            </>
          )}
        </div>
      );
    }
  }
}
