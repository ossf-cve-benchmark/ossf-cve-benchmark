import * as React from "react";
import CVEResultSummarization from "./CVEResultSummarization";
import * as MyCodeMirrors from "./MyCodeMirrors";
import { cachingJSONFetch, cachingTextFetch, mkSimpleURL } from "./util";
import { Alert, CommitData, Weakness } from "../shared/shared-types";

function byLineAlertSorter(a1: Alert, a2: Alert) {
  // this line-sorting is apparently important for CodeMirror performance
  let cmp = a1.lines[0] - a2.lines[0];
  if (cmp !== 0) {
    return cmp;
  }
  return a1.ruleID.localeCompare(a2.ruleID);
}

function byLineWeaknessSorter(w1: Weakness, w2: Weakness) {
  // this line-sorting is apparently important for CodeMirror performance
  let cmp = w1.line - w2.line;
  if (cmp !== 0) {
    return cmp;
  }
  return w1.explanation.localeCompare(w2.explanation);
}

async function getSortedAlerts(cve: string) {
  let alerts: Alert[] = (
    await cachingJSONFetch(
      mkSimpleURL("/data/getAlerts", {
        CVE: cve
      })
    )
  ).json;
  return alerts.sort(byLineAlertSorter);
}
async function getSortedWeaknesses(cve: string) {
  let weaknesses: Weakness[] = (
    await cachingJSONFetch(
      mkSimpleURL("/data/getCVEWeaknesses", {
        CVE: cve
      })
    )
  ).json;
  return weaknesses.sort(byLineWeaknessSorter);
}

// TODO reformulate data entirely? Rely on the stable BCVE type instead?
type Props = {
  CVE: string;
  toolIDs: string[];
  toolRuns: { [toolID: string]: string[] };
  CWEs: string[];
};
type State = {
  source?: string;
  commit?: CommitData;
  file?: string;
  line?: number;
  alerts: Alert[];
  weaknesses: Weakness[];
  unpatchedCommit?: CommitData;
  patchCommit?: CommitData;
  repository?: string;
};

export class CVEResults extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { alerts: [], weaknesses: [] };
  }
  async componentDidMount() {
    let weaknesses = await getSortedWeaknesses(this.props.CVE),
      { patchCommit, unpatchedCommit } = (
        await cachingJSONFetch(
          mkSimpleURL("/data/getCVECommits", {
            CVE: this.props.CVE
          })
        )
      ).json,
      repository = (
        await cachingTextFetch(
          mkSimpleURL("/data/getCVERepository", {
            CVE: this.props.CVE
          })
        )
      ).text,
      selection = weaknesses[0],
      alerts = await getSortedAlerts(this.props.CVE),
      source =
        selection && (await getFileSource(selection.commit, selection.file));

    this.setState({
      alerts,
      weaknesses,
      file: selection?.file,
      line: selection?.line,
      source,
      commit: selection?.commit,
      patchCommit: patchCommit,
      unpatchedCommit: unpatchedCommit,
      repository: repository
    });
  }
  render() {
    if (this.state.unpatchedCommit === undefined) {
      return null; // XXX not yet mounted
    }
    let self = this;
    function setSourceFocus(o: {
      source: string;
      line: number;
      file: string;
      commit: CommitData;
    }) {
      self.setState(o);
    }

    function isRelevant(a: Weakness & Alert) {
      return (
        a.file === self.state.file &&
        a.commit.commitID === self.state.commit.commitID
      );
    }
    return (
      <div>
        <h2>{self.props.CVE}</h2>
        <h3>
          <a href={self.state.repository}>
            {extractRepoSlug(self.state.repository)}
          </a>
        </h3>
        <CVEResultSummarization
          CVE={self.props.CVE}
          toolIDs={self.props.toolIDs}
          setSourceFocus={setSourceFocus}
          alerts={self.state.alerts}
          weaknesses={self.state.weaknesses}
          patchCommit={self.state.patchCommit}
          unpatchedCommit={self.state.unpatchedCommit}
          toolRuns={self.props.toolRuns}
          CWEs={this.props.CWEs}
        />{" "}
        <hr />
        <h2 className="source-code">Source code</h2>
        <MyCodeMirrors.default.AnnotatedCodeMirror
          toolIDs={self.props.toolIDs}
          source={self.state.source}
          file={self.state.file}
          fileUrl={getFileBrowseUrl(self.state.commit, self.state.file)}
          line={self.state.line}
          gutterAnnotations={self.state.alerts.filter(isRelevant)}
          lineAnnotations={self.state.weaknesses.filter(isRelevant)}
        />
      </div>
    );
  }
}
function extractRepoSlug(repository: string) {
  let githubRepoPattern = /^https:\/\/github.com\/([^/]+)\/([^/]+)\.git$/;
  let github = repository.match(githubRepoPattern);
  if (github) {
    let [, owner, repo] = github;
    return `${owner}/${repo}`;
  }
  return undefined; // TODO support non-github.com URLs
}

let githubCommitPattern = /^https:\/\/github.com\/([^/]+\/[^/]+)\/commit\/([a-f0-9]+)$/;
function getFileBrowseUrl(commit: CommitData, file: string): string {
  if (commit.permalink) {
    let github = commit.permalink.match(githubCommitPattern);
    if (github) {
      return `${github[1]}/blob/${github[2]}/${file}`;
    }
  }
  return undefined; // TODO support non-github.com URLs
}

async function getFileSource(commit: CommitData, file: string) {
  let urls = [];
  // prefer local sources
  urls.push(
    mkSimpleURL("/sources", {
      CVE: commit.CVE,
      commit: commit.commitID,
      file
    })
  );
  // then try hosted sources
  if (commit.permalink) {
    let github = commit.permalink.match(githubCommitPattern);
    if (github) {
      urls.push(
        `https://raw.githubusercontent.com/${github[1]}/${github[2]}/${file}`
      ); // XXX rate limited to 60/hour!
    }
  }

  for await (let url of urls) {
    let sourceResponse = await cachingTextFetch(url);
    if (sourceResponse && sourceResponse.status === 200) {
      return sourceResponse.text;
    }
  }
  return undefined;
}
