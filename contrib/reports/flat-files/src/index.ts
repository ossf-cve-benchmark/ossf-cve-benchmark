import * as csv from "csv-string";
import * as fs from "fs";
import * as I from "immutable";
import * as path from "path";
import * as txttable from "table";
import {
  BCVE,
  BCVEAlert,
  BCVEResultStatus,
  BCVERun,
  CVEString,
  Dir,
  RuleID,
  ToolID,
  Weakness
} from "../../../../src/persistent-types";
enum AlertClassification {
  TP,
  UNKNOWN
}
/**
 * An output format for a report.
 */
export enum Format {
  txt = "txt",
  csv = "csv"
}

function getClassification(alert: BCVEAlert, weaknesses: Weakness[]) {
  let classification = (weaknesses || []).some(
    w =>
      w.location.file === alert.location.file &&
      w.location.line === alert.location.line
  )
    ? AlertClassification.TP
    : AlertClassification.UNKNOWN;
  return classification;
}
enum CVECommitKind {
  prePatch = "prePatch",
  postPatch = "postPatch"
}

interface SimpleTable {
  title: string;
  headers: string[];
  rows: string[][];
}

let tableConfigs: { [kind: string]: txttable.TableUserConfig } = {
  stdTable: {
    drawHorizontalLine: (l, s) => l <= 1 || l === s
  }
};

function writeTable(
  fileNamePrefix: string,
  table: SimpleTable,
  outDir: Dir,
  format: Format
) {
  fs.mkdirSync(outDir, { recursive: true });

  let out = path.join(outDir, `${fileNamePrefix}-table.${format}`);
  console.log(`Writing table to: ${out}`);

  let tableString: string;
  switch (format) {
    case "txt":
      tableString = txttable.table(
        [table.headers].concat(table.rows),
        tableConfigs.stdTable
      );
      tableString = `${table.title}\n${tableString}`;
      break;
    case "csv":
      tableString = csv.stringify([table.headers].concat(table.rows));
      break;
    default:
      throw new Error(`Unsupported table format: ${format}`);
  }
  fs.writeFileSync(out, tableString + "\n", {
    encoding: "utf8"
  });
}

function makeResultsReports(bcves: BCVE[], outDir: Dir, format: Format) {
  let bcvesByCVE = I.Set(bcves).groupBy(bcve => bcve.CVE),
    cves = bcvesByCVE.keySeq().sort().toArray(),
    toolIDs = I.Set(bcves)
      .flatMap(bcve => [bcve.postPatch.runs, bcve.prePatch.runs])
      .flatMap(runs => runs)
      .map(run => run.toolID)
      .sort()
      .toArray();

  let cve2kind2tool2rule2classification2count: I.Map<
    CVEString,
    I.Map<
      CVECommitKind,
      I.Map<ToolID, I.Map<RuleID, I.Map<AlertClassification, number>>>
    >
  > = I.Set(bcves)
    .groupBy(bcve => bcve.CVE)
    .toMap()
    .map(bcves => {
      let map = I.Map([
        [CVECommitKind.postPatch, bcves.map(bcve => bcve.postPatch)],
        [CVECommitKind.prePatch, bcves.map(bcve => bcve.prePatch)]
      ]);
      return map.map(commits => {
        let runs = commits.flatMap(c =>
          (c.runs || []).map(run => ({ run: run, weaknesses: c.weaknesses }))
        );
        return runs
          .groupBy(({ run }) => run.toolID)
          .toMap()
          .map(runs =>
            runs
              .flatMap(({ weaknesses, run }) =>
                (run.alerts || []).map(a => ({ alert: a, weaknesses }))
              )
              .groupBy(({ alert }) => alert.ruleID)
              .toMap()
              .map(e =>
                e
                  .groupBy(({ alert, weaknesses }) =>
                    getClassification(alert, weaknesses)
                  )
                  .toMap()
                  .map(alerts => alerts.count())
              )
          );
      });
    });

  for (let { classification, classificationName } of [
    {
      classification: AlertClassification.TP,
      classificationName: "some-TPs"
    },
    {
      classification: AlertClassification.UNKNOWN,
      classificationName: "no-TPs"
    }
  ]) {
    for (let { kind, pred } of [
      { kind: "positive", pred: (n: number) => n > 0 },
      { kind: "zero", pred: (n: number) => n == 0 },
      { kind: "negative", pred: (n: number) => n < 0 }
    ]) {
      writeTable(
        `Delta-alert-counts_${kind}_${classificationName}`,
        buildResultsReportTable(
          `For each CVE/Tool: the rules with a (${kind}) result count *change* between the prePatch and the postPatch commit.
The first number is the change, the number in parenthesis is the number of remaining violations on the postPatch commit.
Only considering rules ${
            classification === AlertClassification.TP
              ? "with at least one TP on prePatch)"
              : "with no TPs on prePatch"
          }.`,
          bcves,
          bcve => (bcve.postPatch.runs || []).concat(bcve.prePatch.runs),
          (runs, cve, toolID) => {
            let prePatch = cve2kind2tool2rule2classification2count
                .get(cve)
                .get(CVECommitKind.prePatch),
              postPatch = cve2kind2tool2rule2classification2count
                .get(cve)
                .get(CVECommitKind.postPatch);
            if (
              !prePatch.has(toolID) ||
              !postPatch.has(toolID) ||
              runs.some(r => r.status !== BCVEResultStatus.SUCCESS)
            ) {
              return;
            }

            let prePatchCounts: I.Map<RuleID, number> = prePatch
                .get(toolID)
                .map(x => x.valueSeq().reduce((a, b) => a + b, 0)),
              postPatchCounts: I.Map<RuleID, number> = postPatch
                .get(toolID)
                .map(x => x.valueSeq().reduce((a, b) => a + b, 0)),
              diffCounts = prePatchCounts.map((prePatchCount, r) => {
                let hasTPs =
                  prePatch.get(toolID).get(r).get(AlertClassification.TP) > 0;
                let needsTPs = classification === AlertClassification.TP;
                if (hasTPs === needsTPs) {
                  return postPatchCounts.get(r, 0) - prePatchCount;
                }
                return undefined;
              });
            return diffCounts
              .entrySeq()
              .filter(([_, delta]) => pred(delta))
              .map(
                ([rule, delta]) =>
                  `${rule}: ${delta} (${postPatchCounts.get(rule, 0)})`
              )
              .sort()
              .join(", ");
          },
          cves,
          toolIDs
        ),
        outDir,
        format
      );
    }
  }
  function mkRunSelectorByKind(kind: CVECommitKind) {
    return function runSelectorByKind(bcve: BCVE): BCVERun[] {
      return kind === CVECommitKind.postPatch
        ? bcve.postPatch.runs || []
        : bcve.prePatch.runs || [];
    };
  }

  for (const kind of Object.keys(CVECommitKind) as CVECommitKind[]) {
    let runSelectorByKind = mkRunSelectorByKind(kind);
    writeTable(
      `Run-status-for-${kind}-runs`,
      buildResultsReportTable(
        `For each CVE/Tool: The the status for a run on the ${kind} commit.`,
        bcves,
        runSelectorByKind,
        runs => {
          return I.Set(runs)
            .map(run => run.status)
            .sort()
            .join(", ");
        },
        cves,
        toolIDs
      ),
      outDir,
      format
    );
  }
}

function buildResultsReportTable(
  title: string,
  bcves: BCVE[],
  runSelector: (bcve: BCVE) => BCVERun[],
  runsMapper: (runs: BCVERun[], cve: CVEString, toolID: ToolID) => string,
  cves: CVEString[],
  toolIDs: ToolID[]
): SimpleTable {
  let byCVEAndToolID = I.Set(bcves)
    .groupBy(bcve => bcve.CVE)
    .map((cvesByCVE, cve) =>
      cvesByCVE
        .flatMap(runSelector)
        .filter(r => r !== undefined)
        .groupBy(runByCVE => runByCVE.toolID)
        .map((allRunsByCVEAndToolID, toolID) =>
          runsMapper(allRunsByCVEAndToolID.toSet().toArray(), cve, toolID)
        )
    );
  let weaknessDescriptions = I.Set(bcves)
    .groupBy(bcve => bcve.CVE)
    .map(bcves =>
      bcves
        .flatMap(bcve => bcve.prePatch.weaknesses.map(w => w.explanation))
        .join(", ")
    );
  let rows = cves.map(cve => {
    let rowName = cve,
      rowValues = toolIDs
        .map(toolID => byCVEAndToolID.get(cve, I.Map()).get(toolID))
        .map(v => {
          return v === undefined ? "" : v + "";
        });
    return [rowName].concat([weaknessDescriptions.get(cve)]).concat(rowValues);
  });
  return {
    title,
    headers: ["CVE", "Descriptions"].concat(toolIDs),
    rows
  };
}
function makeOverviewReport(bcves: BCVE[], outDir: Dir, format: Format) {
  writeTable(
    "Overview",
    {
      title: "For each CVE: some relevant, tool-independent, information.",
      headers: ["CVE", "CWEs", "Repository", "Weaknesses", "Downloaded"],
      rows: bcves
        .map(bcve => {
          let patcbBaseDownloaded =
              bcve.prePatch.localSourceDirectory &&
              fs.existsSync(bcve.prePatch.localSourceDirectory),
            postPatchDownloaded =
              bcve.postPatch.localSourceDirectory &&
              fs.existsSync(bcve.postPatch.localSourceDirectory),
            downloaded =
              patcbBaseDownloaded && postPatchDownloaded
                ? "ALL"
                : patcbBaseDownloaded || postPatchDownloaded
                ? "SOME"
                : "NONE";
          return [
            bcve.CVE,
            bcve.CWEs.sort().join(" "),
            bcve.repository,
            "" + bcve.prePatch.weaknesses.length,
            downloaded
          ];
        })
        .sort((r1, r2) => r1.toString().localeCompare(r2.toString()))
    },
    outDir,
    format
  );
}

export async function reportMaker(
  bcves: BCVE[],
  outDir: Dir,
  format: Format
): Promise<void> {
  makeOverviewReport(bcves, outDir, format);
  makeResultsReports(bcves, outDir, format);
}
